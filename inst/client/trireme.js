var sw = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ok(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var $S = { exports: {} }, Ch = {}, YS = { exports: {} }, Bt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cw;
function EN() {
  if (cw)
    return Bt;
  cw = 1;
  var r = Symbol.for("react.element"), o = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), f = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), y = Symbol.for("react.provider"), S = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), E = Symbol.for("react.memo"), R = Symbol.for("react.lazy"), D = Symbol.iterator;
  function N(T) {
    return T === null || typeof T != "object" ? null : (T = D && T[D] || T["@@iterator"], typeof T == "function" ? T : null);
  }
  var M = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, F = Object.assign, $ = {};
  function ce(T, ue, Ae) {
    this.props = T, this.context = ue, this.refs = $, this.updater = Ae || M;
  }
  ce.prototype.isReactComponent = {}, ce.prototype.setState = function(T, ue) {
    if (typeof T != "object" && typeof T != "function" && T != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, T, ue, "setState");
  }, ce.prototype.forceUpdate = function(T) {
    this.updater.enqueueForceUpdate(this, T, "forceUpdate");
  };
  function X() {
  }
  X.prototype = ce.prototype;
  function se(T, ue, Ae) {
    this.props = T, this.context = ue, this.refs = $, this.updater = Ae || M;
  }
  var te = se.prototype = new X();
  te.constructor = se, F(te, ce.prototype), te.isPureReactComponent = !0;
  var Se = Array.isArray, Ce = Object.prototype.hasOwnProperty, Y = { current: null }, Oe = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ze(T, ue, Ae) {
    var A, Ke = {}, bt = null, at = null;
    if (ue != null)
      for (A in ue.ref !== void 0 && (at = ue.ref), ue.key !== void 0 && (bt = "" + ue.key), ue)
        Ce.call(ue, A) && !Oe.hasOwnProperty(A) && (Ke[A] = ue[A]);
    var _t = arguments.length - 2;
    if (_t === 1)
      Ke.children = Ae;
    else if (1 < _t) {
      for (var mt = Array(_t), Qt = 0; Qt < _t; Qt++)
        mt[Qt] = arguments[Qt + 2];
      Ke.children = mt;
    }
    if (T && T.defaultProps)
      for (A in _t = T.defaultProps, _t)
        Ke[A] === void 0 && (Ke[A] = _t[A]);
    return { $$typeof: r, type: T, key: bt, ref: at, props: Ke, _owner: Y.current };
  }
  function it(T, ue) {
    return { $$typeof: r, type: T.type, key: ue, ref: T.ref, props: T.props, _owner: T._owner };
  }
  function lt(T) {
    return typeof T == "object" && T !== null && T.$$typeof === r;
  }
  function he(T) {
    var ue = { "=": "=0", ":": "=2" };
    return "$" + T.replace(/[=:]/g, function(Ae) {
      return ue[Ae];
    });
  }
  var ne = /\/+/g;
  function we(T, ue) {
    return typeof T == "object" && T !== null && T.key != null ? he("" + T.key) : ue.toString(36);
  }
  function de(T, ue, Ae, A, Ke) {
    var bt = typeof T;
    (bt === "undefined" || bt === "boolean") && (T = null);
    var at = !1;
    if (T === null)
      at = !0;
    else
      switch (bt) {
        case "string":
        case "number":
          at = !0;
          break;
        case "object":
          switch (T.$$typeof) {
            case r:
            case o:
              at = !0;
          }
      }
    if (at)
      return at = T, Ke = Ke(at), T = A === "" ? "." + we(at, 0) : A, Se(Ke) ? (Ae = "", T != null && (Ae = T.replace(ne, "$&/") + "/"), de(Ke, ue, Ae, "", function(Qt) {
        return Qt;
      })) : Ke != null && (lt(Ke) && (Ke = it(Ke, Ae + (!Ke.key || at && at.key === Ke.key ? "" : ("" + Ke.key).replace(ne, "$&/") + "/") + T)), ue.push(Ke)), 1;
    if (at = 0, A = A === "" ? "." : A + ":", Se(T))
      for (var _t = 0; _t < T.length; _t++) {
        bt = T[_t];
        var mt = A + we(bt, _t);
        at += de(bt, ue, Ae, mt, Ke);
      }
    else if (mt = N(T), typeof mt == "function")
      for (T = mt.call(T), _t = 0; !(bt = T.next()).done; )
        bt = bt.value, mt = A + we(bt, _t++), at += de(bt, ue, Ae, mt, Ke);
    else if (bt === "object")
      throw ue = String(T), Error("Objects are not valid as a React child (found: " + (ue === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : ue) + "). If you meant to render a collection of children, use an array instead.");
    return at;
  }
  function ge(T, ue, Ae) {
    if (T == null)
      return T;
    var A = [], Ke = 0;
    return de(T, A, "", "", function(bt) {
      return ue.call(Ae, bt, Ke++);
    }), A;
  }
  function Qe(T) {
    if (T._status === -1) {
      var ue = T._result;
      ue = ue(), ue.then(function(Ae) {
        (T._status === 0 || T._status === -1) && (T._status = 1, T._result = Ae);
      }, function(Ae) {
        (T._status === 0 || T._status === -1) && (T._status = 2, T._result = Ae);
      }), T._status === -1 && (T._status = 0, T._result = ue);
    }
    if (T._status === 1)
      return T._result.default;
    throw T._result;
  }
  var Fe = { current: null }, ae = { transition: null }, _e = { ReactCurrentDispatcher: Fe, ReactCurrentBatchConfig: ae, ReactCurrentOwner: Y };
  return Bt.Children = { map: ge, forEach: function(T, ue, Ae) {
    ge(T, function() {
      ue.apply(this, arguments);
    }, Ae);
  }, count: function(T) {
    var ue = 0;
    return ge(T, function() {
      ue++;
    }), ue;
  }, toArray: function(T) {
    return ge(T, function(ue) {
      return ue;
    }) || [];
  }, only: function(T) {
    if (!lt(T))
      throw Error("React.Children.only expected to receive a single React element child.");
    return T;
  } }, Bt.Component = ce, Bt.Fragment = s, Bt.Profiler = h, Bt.PureComponent = se, Bt.StrictMode = f, Bt.Suspense = w, Bt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _e, Bt.cloneElement = function(T, ue, Ae) {
    if (T == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + T + ".");
    var A = F({}, T.props), Ke = T.key, bt = T.ref, at = T._owner;
    if (ue != null) {
      if (ue.ref !== void 0 && (bt = ue.ref, at = Y.current), ue.key !== void 0 && (Ke = "" + ue.key), T.type && T.type.defaultProps)
        var _t = T.type.defaultProps;
      for (mt in ue)
        Ce.call(ue, mt) && !Oe.hasOwnProperty(mt) && (A[mt] = ue[mt] === void 0 && _t !== void 0 ? _t[mt] : ue[mt]);
    }
    var mt = arguments.length - 2;
    if (mt === 1)
      A.children = Ae;
    else if (1 < mt) {
      _t = Array(mt);
      for (var Qt = 0; Qt < mt; Qt++)
        _t[Qt] = arguments[Qt + 2];
      A.children = _t;
    }
    return { $$typeof: r, type: T.type, key: Ke, ref: bt, props: A, _owner: at };
  }, Bt.createContext = function(T) {
    return T = { $$typeof: S, _currentValue: T, _currentValue2: T, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, T.Provider = { $$typeof: y, _context: T }, T.Consumer = T;
  }, Bt.createElement = ze, Bt.createFactory = function(T) {
    var ue = ze.bind(null, T);
    return ue.type = T, ue;
  }, Bt.createRef = function() {
    return { current: null };
  }, Bt.forwardRef = function(T) {
    return { $$typeof: v, render: T };
  }, Bt.isValidElement = lt, Bt.lazy = function(T) {
    return { $$typeof: R, _payload: { _status: -1, _result: T }, _init: Qe };
  }, Bt.memo = function(T, ue) {
    return { $$typeof: E, type: T, compare: ue === void 0 ? null : ue };
  }, Bt.startTransition = function(T) {
    var ue = ae.transition;
    ae.transition = {};
    try {
      T();
    } finally {
      ae.transition = ue;
    }
  }, Bt.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Bt.useCallback = function(T, ue) {
    return Fe.current.useCallback(T, ue);
  }, Bt.useContext = function(T) {
    return Fe.current.useContext(T);
  }, Bt.useDebugValue = function() {
  }, Bt.useDeferredValue = function(T) {
    return Fe.current.useDeferredValue(T);
  }, Bt.useEffect = function(T, ue) {
    return Fe.current.useEffect(T, ue);
  }, Bt.useId = function() {
    return Fe.current.useId();
  }, Bt.useImperativeHandle = function(T, ue, Ae) {
    return Fe.current.useImperativeHandle(T, ue, Ae);
  }, Bt.useInsertionEffect = function(T, ue) {
    return Fe.current.useInsertionEffect(T, ue);
  }, Bt.useLayoutEffect = function(T, ue) {
    return Fe.current.useLayoutEffect(T, ue);
  }, Bt.useMemo = function(T, ue) {
    return Fe.current.useMemo(T, ue);
  }, Bt.useReducer = function(T, ue, Ae) {
    return Fe.current.useReducer(T, ue, Ae);
  }, Bt.useRef = function(T) {
    return Fe.current.useRef(T);
  }, Bt.useState = function(T) {
    return Fe.current.useState(T);
  }, Bt.useSyncExternalStore = function(T, ue, Ae) {
    return Fe.current.useSyncExternalStore(T, ue, Ae);
  }, Bt.useTransition = function() {
    return Fe.current.useTransition();
  }, Bt.version = "18.2.0", Bt;
}
var Dh = { exports: {} };
Dh.exports;
var fw;
function CN() {
  return fw || (fw = 1, function(r, o) {
    var s = {};
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    s.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var f = "18.2.0", h = Symbol.for("react.element"), y = Symbol.for("react.portal"), S = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), w = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), R = Symbol.for("react.context"), D = Symbol.for("react.forward_ref"), N = Symbol.for("react.suspense"), M = Symbol.for("react.suspense_list"), F = Symbol.for("react.memo"), $ = Symbol.for("react.lazy"), ce = Symbol.for("react.offscreen"), X = Symbol.iterator, se = "@@iterator";
      function te(k) {
        if (k === null || typeof k != "object")
          return null;
        var j = X && k[X] || k[se];
        return typeof j == "function" ? j : null;
      }
      var Se = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, Ce = {
        transition: null
      }, Y = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, Oe = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ze = {}, it = null;
      function lt(k) {
        it = k;
      }
      ze.setExtraStackFrame = function(k) {
        it = k;
      }, ze.getCurrentStack = null, ze.getStackAddendum = function() {
        var k = "";
        it && (k += it);
        var j = ze.getCurrentStack;
        return j && (k += j() || ""), k;
      };
      var he = !1, ne = !1, we = !1, de = !1, ge = !1, Qe = {
        ReactCurrentDispatcher: Se,
        ReactCurrentBatchConfig: Ce,
        ReactCurrentOwner: Oe
      };
      Qe.ReactDebugCurrentFrame = ze, Qe.ReactCurrentActQueue = Y;
      function Fe(k) {
        {
          for (var j = arguments.length, K = new Array(j > 1 ? j - 1 : 0), ie = 1; ie < j; ie++)
            K[ie - 1] = arguments[ie];
          _e("warn", k, K);
        }
      }
      function ae(k) {
        {
          for (var j = arguments.length, K = new Array(j > 1 ? j - 1 : 0), ie = 1; ie < j; ie++)
            K[ie - 1] = arguments[ie];
          _e("error", k, K);
        }
      }
      function _e(k, j, K) {
        {
          var ie = Qe.ReactDebugCurrentFrame, ke = ie.getStackAddendum();
          ke !== "" && (j += "%s", K = K.concat([ke]));
          var Je = K.map(function(Ie) {
            return String(Ie);
          });
          Je.unshift("Warning: " + j), Function.prototype.apply.call(console[k], console, Je);
        }
      }
      var T = {};
      function ue(k, j) {
        {
          var K = k.constructor, ie = K && (K.displayName || K.name) || "ReactClass", ke = ie + "." + j;
          if (T[ke])
            return;
          ae("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", j, ie), T[ke] = !0;
        }
      }
      var Ae = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(k) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(k, j, K) {
          ue(k, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(k, j, K, ie) {
          ue(k, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(k, j, K, ie) {
          ue(k, "setState");
        }
      }, A = Object.assign, Ke = {};
      Object.freeze(Ke);
      function bt(k, j, K) {
        this.props = k, this.context = j, this.refs = Ke, this.updater = K || Ae;
      }
      bt.prototype.isReactComponent = {}, bt.prototype.setState = function(k, j) {
        if (typeof k != "object" && typeof k != "function" && k != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, k, j, "setState");
      }, bt.prototype.forceUpdate = function(k) {
        this.updater.enqueueForceUpdate(this, k, "forceUpdate");
      };
      {
        var at = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, _t = function(k, j) {
          Object.defineProperty(bt.prototype, k, {
            get: function() {
              Fe("%s(...) is deprecated in plain JavaScript React classes. %s", j[0], j[1]);
            }
          });
        };
        for (var mt in at)
          at.hasOwnProperty(mt) && _t(mt, at[mt]);
      }
      function Qt() {
      }
      Qt.prototype = bt.prototype;
      function wn(k, j, K) {
        this.props = k, this.context = j, this.refs = Ke, this.updater = K || Ae;
      }
      var An = wn.prototype = new Qt();
      An.constructor = wn, A(An, bt.prototype), An.isPureReactComponent = !0;
      function Mr() {
        var k = {
          current: null
        };
        return Object.seal(k), k;
      }
      var sr = Array.isArray;
      function kn(k) {
        return sr(k);
      }
      function Jn(k) {
        {
          var j = typeof Symbol == "function" && Symbol.toStringTag, K = j && k[Symbol.toStringTag] || k.constructor.name || "Object";
          return K;
        }
      }
      function jn(k) {
        try {
          return Dn(k), !1;
        } catch {
          return !0;
        }
      }
      function Dn(k) {
        return "" + k;
      }
      function Un(k) {
        if (jn(k))
          return ae("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Jn(k)), Dn(k);
      }
      function cr(k, j, K) {
        var ie = k.displayName;
        if (ie)
          return ie;
        var ke = j.displayName || j.name || "";
        return ke !== "" ? K + "(" + ke + ")" : K;
      }
      function rr(k) {
        return k.displayName || "Context";
      }
      function $n(k) {
        if (k == null)
          return null;
        if (typeof k.tag == "number" && ae("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof k == "function")
          return k.displayName || k.name || null;
        if (typeof k == "string")
          return k;
        switch (k) {
          case S:
            return "Fragment";
          case y:
            return "Portal";
          case w:
            return "Profiler";
          case v:
            return "StrictMode";
          case N:
            return "Suspense";
          case M:
            return "SuspenseList";
        }
        if (typeof k == "object")
          switch (k.$$typeof) {
            case R:
              var j = k;
              return rr(j) + ".Consumer";
            case E:
              var K = k;
              return rr(K._context) + ".Provider";
            case D:
              return cr(k, k.render, "ForwardRef");
            case F:
              var ie = k.displayName || null;
              return ie !== null ? ie : $n(k.type) || "Memo";
            case $: {
              var ke = k, Je = ke._payload, Ie = ke._init;
              try {
                return $n(Ie(Je));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Fr = Object.prototype.hasOwnProperty, Pr = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, fr, Hr, re;
      re = {};
      function Ee(k) {
        if (Fr.call(k, "ref")) {
          var j = Object.getOwnPropertyDescriptor(k, "ref").get;
          if (j && j.isReactWarning)
            return !1;
        }
        return k.ref !== void 0;
      }
      function $e(k) {
        if (Fr.call(k, "key")) {
          var j = Object.getOwnPropertyDescriptor(k, "key").get;
          if (j && j.isReactWarning)
            return !1;
        }
        return k.key !== void 0;
      }
      function yt(k, j) {
        var K = function() {
          fr || (fr = !0, ae("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", j));
        };
        K.isReactWarning = !0, Object.defineProperty(k, "key", {
          get: K,
          configurable: !0
        });
      }
      function Ot(k, j) {
        var K = function() {
          Hr || (Hr = !0, ae("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", j));
        };
        K.isReactWarning = !0, Object.defineProperty(k, "ref", {
          get: K,
          configurable: !0
        });
      }
      function gn(k) {
        if (typeof k.ref == "string" && Oe.current && k.__self && Oe.current.stateNode !== k.__self) {
          var j = $n(Oe.current.type);
          re[j] || (ae('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j, k.ref), re[j] = !0);
        }
      }
      var De = function(k, j, K, ie, ke, Je, Ie) {
        var vt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: h,
          // Built-in properties that belong on the element
          type: k,
          key: j,
          ref: K,
          props: Ie,
          // Record the component responsible for creating this element.
          _owner: Je
        };
        return vt._store = {}, Object.defineProperty(vt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(vt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ie
        }), Object.defineProperty(vt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ke
        }), Object.freeze && (Object.freeze(vt.props), Object.freeze(vt)), vt;
      };
      function Ye(k, j, K) {
        var ie, ke = {}, Je = null, Ie = null, vt = null, Nt = null;
        if (j != null) {
          Ee(j) && (Ie = j.ref, gn(j)), $e(j) && (Un(j.key), Je = "" + j.key), vt = j.__self === void 0 ? null : j.__self, Nt = j.__source === void 0 ? null : j.__source;
          for (ie in j)
            Fr.call(j, ie) && !Pr.hasOwnProperty(ie) && (ke[ie] = j[ie]);
        }
        var Zt = arguments.length - 2;
        if (Zt === 1)
          ke.children = K;
        else if (Zt > 1) {
          for (var nn = Array(Zt), rn = 0; rn < Zt; rn++)
            nn[rn] = arguments[rn + 2];
          Object.freeze && Object.freeze(nn), ke.children = nn;
        }
        if (k && k.defaultProps) {
          var an = k.defaultProps;
          for (ie in an)
            ke[ie] === void 0 && (ke[ie] = an[ie]);
        }
        if (Je || Ie) {
          var xn = typeof k == "function" ? k.displayName || k.name || "Unknown" : k;
          Je && yt(ke, xn), Ie && Ot(ke, xn);
        }
        return De(k, Je, Ie, vt, Nt, Oe.current, ke);
      }
      function St(k, j) {
        var K = De(k.type, j, k.ref, k._self, k._source, k._owner, k.props);
        return K;
      }
      function Ut(k, j, K) {
        if (k == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + k + ".");
        var ie, ke = A({}, k.props), Je = k.key, Ie = k.ref, vt = k._self, Nt = k._source, Zt = k._owner;
        if (j != null) {
          Ee(j) && (Ie = j.ref, Zt = Oe.current), $e(j) && (Un(j.key), Je = "" + j.key);
          var nn;
          k.type && k.type.defaultProps && (nn = k.type.defaultProps);
          for (ie in j)
            Fr.call(j, ie) && !Pr.hasOwnProperty(ie) && (j[ie] === void 0 && nn !== void 0 ? ke[ie] = nn[ie] : ke[ie] = j[ie]);
        }
        var rn = arguments.length - 2;
        if (rn === 1)
          ke.children = K;
        else if (rn > 1) {
          for (var an = Array(rn), xn = 0; xn < rn; xn++)
            an[xn] = arguments[xn + 2];
          ke.children = an;
        }
        return De(k.type, Je, Ie, vt, Nt, Zt, ke);
      }
      function Et(k) {
        return typeof k == "object" && k !== null && k.$$typeof === h;
      }
      var on = ".", Yt = ":";
      function Nr(k) {
        var j = /[=:]/g, K = {
          "=": "=0",
          ":": "=2"
        }, ie = k.replace(j, function(ke) {
          return K[ke];
        });
        return "$" + ie;
      }
      var tn = !1, dr = /\/+/g;
      function Jt(k) {
        return k.replace(dr, "$&/");
      }
      function dn(k, j) {
        return typeof k == "object" && k !== null && k.key != null ? (Un(k.key), Nr("" + k.key)) : j.toString(36);
      }
      function ua(k, j, K, ie, ke) {
        var Je = typeof k;
        (Je === "undefined" || Je === "boolean") && (k = null);
        var Ie = !1;
        if (k === null)
          Ie = !0;
        else
          switch (Je) {
            case "string":
            case "number":
              Ie = !0;
              break;
            case "object":
              switch (k.$$typeof) {
                case h:
                case y:
                  Ie = !0;
              }
          }
        if (Ie) {
          var vt = k, Nt = ke(vt), Zt = ie === "" ? on + dn(vt, 0) : ie;
          if (kn(Nt)) {
            var nn = "";
            Zt != null && (nn = Jt(Zt) + "/"), ua(Nt, j, nn, "", function(Td) {
              return Td;
            });
          } else
            Nt != null && (Et(Nt) && (Nt.key && (!vt || vt.key !== Nt.key) && Un(Nt.key), Nt = St(
              Nt,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              K + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Nt.key && (!vt || vt.key !== Nt.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                Jt("" + Nt.key) + "/"
              ) : "") + Zt
            )), j.push(Nt));
          return 1;
        }
        var rn, an, xn = 0, $t = ie === "" ? on : ie + Yt;
        if (kn(k))
          for (var jl = 0; jl < k.length; jl++)
            rn = k[jl], an = $t + dn(rn, jl), xn += ua(rn, j, K, an, ke);
        else {
          var vu = te(k);
          if (typeof vu == "function") {
            var Ts = k;
            vu === Ts.entries && (tn || Fe("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), tn = !0);
            for (var Rs = vu.call(Ts), tl, _s = 0; !(tl = Rs.next()).done; )
              rn = tl.value, an = $t + dn(rn, _s++), xn += ua(rn, j, K, an, ke);
          } else if (Je === "object") {
            var Ds = String(k);
            throw new Error("Objects are not valid as a React child (found: " + (Ds === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : Ds) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return xn;
      }
      function Ai(k, j, K) {
        if (k == null)
          return k;
        var ie = [], ke = 0;
        return ua(k, ie, "", "", function(Je) {
          return j.call(K, Je, ke++);
        }), ie;
      }
      function _l(k) {
        var j = 0;
        return Ai(k, function() {
          j++;
        }), j;
      }
      function mo(k, j, K) {
        Ai(k, function() {
          j.apply(this, arguments);
        }, K);
      }
      function yo(k) {
        return Ai(k, function(j) {
          return j;
        }) || [];
      }
      function Dl(k) {
        if (!Et(k))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return k;
      }
      function sa(k) {
        var j = {
          $$typeof: R,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: k,
          _currentValue2: k,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        j.Provider = {
          $$typeof: E,
          _context: j
        };
        var K = !1, ie = !1, ke = !1;
        {
          var Je = {
            $$typeof: R,
            _context: j
          };
          Object.defineProperties(Je, {
            Provider: {
              get: function() {
                return ie || (ie = !0, ae("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), j.Provider;
              },
              set: function(Ie) {
                j.Provider = Ie;
              }
            },
            _currentValue: {
              get: function() {
                return j._currentValue;
              },
              set: function(Ie) {
                j._currentValue = Ie;
              }
            },
            _currentValue2: {
              get: function() {
                return j._currentValue2;
              },
              set: function(Ie) {
                j._currentValue2 = Ie;
              }
            },
            _threadCount: {
              get: function() {
                return j._threadCount;
              },
              set: function(Ie) {
                j._threadCount = Ie;
              }
            },
            Consumer: {
              get: function() {
                return K || (K = !0, ae("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), j.Consumer;
              }
            },
            displayName: {
              get: function() {
                return j.displayName;
              },
              set: function(Ie) {
                ke || (Fe("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Ie), ke = !0);
              }
            }
          }), j.Consumer = Je;
        }
        return j._currentRenderer = null, j._currentRenderer2 = null, j;
      }
      var ca = -1, ji = 0, qa = 1, Zr = 2;
      function ei(k) {
        if (k._status === ca) {
          var j = k._result, K = j();
          if (K.then(function(Je) {
            if (k._status === ji || k._status === ca) {
              var Ie = k;
              Ie._status = qa, Ie._result = Je;
            }
          }, function(Je) {
            if (k._status === ji || k._status === ca) {
              var Ie = k;
              Ie._status = Zr, Ie._result = Je;
            }
          }), k._status === ca) {
            var ie = k;
            ie._status = ji, ie._result = K;
          }
        }
        if (k._status === qa) {
          var ke = k._result;
          return ke === void 0 && ae(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ke), "default" in ke || ae(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ke), ke.default;
        } else
          throw k._result;
      }
      function Ei(k) {
        var j = {
          // We use these fields to store the result.
          _status: ca,
          _result: k
        }, K = {
          $$typeof: $,
          _payload: j,
          _init: ei
        };
        {
          var ie, ke;
          Object.defineProperties(K, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return ie;
              },
              set: function(Je) {
                ae("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), ie = Je, Object.defineProperty(K, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return ke;
              },
              set: function(Je) {
                ae("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), ke = Je, Object.defineProperty(K, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return K;
      }
      function Ga(k) {
        k != null && k.$$typeof === F ? ae("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof k != "function" ? ae("forwardRef requires a render function but was given %s.", k === null ? "null" : typeof k) : k.length !== 0 && k.length !== 2 && ae("forwardRef render functions accept exactly two parameters: props and ref. %s", k.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), k != null && (k.defaultProps != null || k.propTypes != null) && ae("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var j = {
          $$typeof: D,
          render: k
        };
        {
          var K;
          Object.defineProperty(j, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return K;
            },
            set: function(ie) {
              K = ie, !k.name && !k.displayName && (k.displayName = ie);
            }
          });
        }
        return j;
      }
      var U;
      U = Symbol.for("react.module.reference");
      function me(k) {
        return !!(typeof k == "string" || typeof k == "function" || k === S || k === w || ge || k === v || k === N || k === M || de || k === ce || he || ne || we || typeof k == "object" && k !== null && (k.$$typeof === $ || k.$$typeof === F || k.$$typeof === E || k.$$typeof === R || k.$$typeof === D || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        k.$$typeof === U || k.getModuleId !== void 0));
      }
      function Ne(k, j) {
        me(k) || ae("memo: The first argument must be a component. Instead received: %s", k === null ? "null" : typeof k);
        var K = {
          $$typeof: F,
          type: k,
          compare: j === void 0 ? null : j
        };
        {
          var ie;
          Object.defineProperty(K, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ie;
            },
            set: function(ke) {
              ie = ke, !k.name && !k.displayName && (k.displayName = ke);
            }
          });
        }
        return K;
      }
      function je() {
        var k = Se.current;
        return k === null && ae(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), k;
      }
      function zt(k) {
        var j = je();
        if (k._context !== void 0) {
          var K = k._context;
          K.Consumer === k ? ae("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : K.Provider === k && ae("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return j.useContext(k);
      }
      function Pt(k) {
        var j = je();
        return j.useState(k);
      }
      function Dt(k, j, K) {
        var ie = je();
        return ie.useReducer(k, j, K);
      }
      function ot(k) {
        var j = je();
        return j.useRef(k);
      }
      function Zn(k, j) {
        var K = je();
        return K.useEffect(k, j);
      }
      function pn(k, j) {
        var K = je();
        return K.useInsertionEffect(k, j);
      }
      function hn(k, j) {
        var K = je();
        return K.useLayoutEffect(k, j);
      }
      function Lr(k, j) {
        var K = je();
        return K.useCallback(k, j);
      }
      function Ca(k, j) {
        var K = je();
        return K.useMemo(k, j);
      }
      function vn(k, j, K) {
        var ie = je();
        return ie.useImperativeHandle(k, j, K);
      }
      function ti(k, j) {
        {
          var K = je();
          return K.useDebugValue(k, j);
        }
      }
      function vs() {
        var k = je();
        return k.useTransition();
      }
      function wa(k) {
        var j = je();
        return j.useDeferredValue(k);
      }
      function Mt() {
        var k = je();
        return k.useId();
      }
      function go(k, j, K) {
        var ie = je();
        return ie.useSyncExternalStore(k, j, K);
      }
      var Xa = 0, Ol, ni, ms, Ir, ys, gs, Ss;
      function So() {
      }
      So.__reactDisabledLog = !0;
      function ou() {
        {
          if (Xa === 0) {
            Ol = console.log, ni = console.info, ms = console.warn, Ir = console.error, ys = console.group, gs = console.groupCollapsed, Ss = console.groupEnd;
            var k = {
              configurable: !0,
              enumerable: !0,
              value: So,
              writable: !0
            };
            Object.defineProperties(console, {
              info: k,
              log: k,
              warn: k,
              error: k,
              group: k,
              groupCollapsed: k,
              groupEnd: k
            });
          }
          Xa++;
        }
      }
      function Ka() {
        {
          if (Xa--, Xa === 0) {
            var k = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: A({}, k, {
                value: Ol
              }),
              info: A({}, k, {
                value: ni
              }),
              warn: A({}, k, {
                value: ms
              }),
              error: A({}, k, {
                value: Ir
              }),
              group: A({}, k, {
                value: ys
              }),
              groupCollapsed: A({}, k, {
                value: gs
              }),
              groupEnd: A({}, k, {
                value: Ss
              })
            });
          }
          Xa < 0 && ae("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ka = Qe.ReactCurrentDispatcher, Ui;
      function Ml(k, j, K) {
        {
          if (Ui === void 0)
            try {
              throw Error();
            } catch (ke) {
              var ie = ke.stack.trim().match(/\n( *(at )?)/);
              Ui = ie && ie[1] || "";
            }
          return `
` + Ui + k;
        }
      }
      var Ta = !1, xo;
      {
        var bo = typeof WeakMap == "function" ? WeakMap : Map;
        xo = new bo();
      }
      function Nl(k, j) {
        if (!k || Ta)
          return "";
        {
          var K = xo.get(k);
          if (K !== void 0)
            return K;
        }
        var ie;
        Ta = !0;
        var ke = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Je;
        Je = ka.current, ka.current = null, ou();
        try {
          if (j) {
            var Ie = function() {
              throw Error();
            };
            if (Object.defineProperty(Ie.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Ie, []);
              } catch ($t) {
                ie = $t;
              }
              Reflect.construct(k, [], Ie);
            } else {
              try {
                Ie.call();
              } catch ($t) {
                ie = $t;
              }
              k.call(Ie.prototype);
            }
          } else {
            try {
              throw Error();
            } catch ($t) {
              ie = $t;
            }
            k();
          }
        } catch ($t) {
          if ($t && ie && typeof $t.stack == "string") {
            for (var vt = $t.stack.split(`
`), Nt = ie.stack.split(`
`), Zt = vt.length - 1, nn = Nt.length - 1; Zt >= 1 && nn >= 0 && vt[Zt] !== Nt[nn]; )
              nn--;
            for (; Zt >= 1 && nn >= 0; Zt--, nn--)
              if (vt[Zt] !== Nt[nn]) {
                if (Zt !== 1 || nn !== 1)
                  do
                    if (Zt--, nn--, nn < 0 || vt[Zt] !== Nt[nn]) {
                      var rn = `
` + vt[Zt].replace(" at new ", " at ");
                      return k.displayName && rn.includes("<anonymous>") && (rn = rn.replace("<anonymous>", k.displayName)), typeof k == "function" && xo.set(k, rn), rn;
                    }
                  while (Zt >= 1 && nn >= 0);
                break;
              }
          }
        } finally {
          Ta = !1, ka.current = Je, Ka(), Error.prepareStackTrace = ke;
        }
        var an = k ? k.displayName || k.name : "", xn = an ? Ml(an) : "";
        return typeof k == "function" && xo.set(k, xn), xn;
      }
      function xs(k, j, K) {
        return Nl(k, !1);
      }
      function bs(k) {
        var j = k.prototype;
        return !!(j && j.isReactComponent);
      }
      function Ft(k, j, K) {
        if (k == null)
          return "";
        if (typeof k == "function")
          return Nl(k, bs(k));
        if (typeof k == "string")
          return Ml(k);
        switch (k) {
          case N:
            return Ml("Suspense");
          case M:
            return Ml("SuspenseList");
        }
        if (typeof k == "object")
          switch (k.$$typeof) {
            case D:
              return xs(k.render);
            case F:
              return Ft(k.type, j, K);
            case $: {
              var ie = k, ke = ie._payload, Je = ie._init;
              try {
                return Ft(Je(ke), j, K);
              } catch {
              }
            }
          }
        return "";
      }
      var Es = {}, uu = Qe.ReactDebugCurrentFrame;
      function Ll(k) {
        if (k) {
          var j = k._owner, K = Ft(k.type, k._source, j ? j.type : null);
          uu.setExtraStackFrame(K);
        } else
          uu.setExtraStackFrame(null);
      }
      function Cs(k, j, K, ie, ke) {
        {
          var Je = Function.call.bind(Fr);
          for (var Ie in k)
            if (Je(k, Ie)) {
              var vt = void 0;
              try {
                if (typeof k[Ie] != "function") {
                  var Nt = Error((ie || "React class") + ": " + K + " type `" + Ie + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof k[Ie] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Nt.name = "Invariant Violation", Nt;
                }
                vt = k[Ie](j, Ie, ie, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Zt) {
                vt = Zt;
              }
              vt && !(vt instanceof Error) && (Ll(ke), ae("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ie || "React class", K, Ie, typeof vt), Ll(null)), vt instanceof Error && !(vt.message in Es) && (Es[vt.message] = !0, Ll(ke), ae("Failed %s type: %s", K, vt.message), Ll(null));
            }
        }
      }
      function Vt(k) {
        if (k) {
          var j = k._owner, K = Ft(k.type, k._source, j ? j.type : null);
          lt(K);
        } else
          lt(null);
      }
      var su;
      su = !1;
      function Eo() {
        if (Oe.current) {
          var k = $n(Oe.current.type);
          if (k)
            return `

Check the render method of \`` + k + "`.";
        }
        return "";
      }
      function xt(k) {
        if (k !== void 0) {
          var j = k.fileName.replace(/^.*[\\\/]/, ""), K = k.lineNumber;
          return `

Check your code at ` + j + ":" + K + ".";
        }
        return "";
      }
      function fa(k) {
        return k != null ? xt(k.__source) : "";
      }
      var On = {};
      function ri(k) {
        var j = Eo();
        if (!j) {
          var K = typeof k == "string" ? k : k.displayName || k.name;
          K && (j = `

Check the top-level render call using <` + K + ">.");
        }
        return j;
      }
      function Fi(k, j) {
        if (!(!k._store || k._store.validated || k.key != null)) {
          k._store.validated = !0;
          var K = ri(j);
          if (!On[K]) {
            On[K] = !0;
            var ie = "";
            k && k._owner && k._owner !== Oe.current && (ie = " It was passed a child from " + $n(k._owner.type) + "."), Vt(k), ae('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ie), Vt(null);
          }
        }
      }
      function zl(k, j) {
        if (typeof k == "object") {
          if (kn(k))
            for (var K = 0; K < k.length; K++) {
              var ie = k[K];
              Et(ie) && Fi(ie, j);
            }
          else if (Et(k))
            k._store && (k._store.validated = !0);
          else if (k) {
            var ke = te(k);
            if (typeof ke == "function" && ke !== k.entries)
              for (var Je = ke.call(k), Ie; !(Ie = Je.next()).done; )
                Et(Ie.value) && Fi(Ie.value, j);
          }
        }
      }
      function Sn(k) {
        {
          var j = k.type;
          if (j == null || typeof j == "string")
            return;
          var K;
          if (typeof j == "function")
            K = j.propTypes;
          else if (typeof j == "object" && (j.$$typeof === D || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          j.$$typeof === F))
            K = j.propTypes;
          else
            return;
          if (K) {
            var ie = $n(j);
            Cs(K, k.props, "prop", ie, k);
          } else if (j.PropTypes !== void 0 && !su) {
            su = !0;
            var ke = $n(j);
            ae("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ke || "Unknown");
          }
          typeof j.getDefaultProps == "function" && !j.getDefaultProps.isReactClassApproved && ae("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Mn(k) {
        {
          for (var j = Object.keys(k.props), K = 0; K < j.length; K++) {
            var ie = j[K];
            if (ie !== "children" && ie !== "key") {
              Vt(k), ae("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ie), Vt(null);
              break;
            }
          }
          k.ref !== null && (Vt(k), ae("Invalid attribute `ref` supplied to `React.Fragment`."), Vt(null));
        }
      }
      function ws(k, j, K) {
        var ie = me(k);
        if (!ie) {
          var ke = "";
          (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (ke += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Je = fa(j);
          Je ? ke += Je : ke += Eo();
          var Ie;
          k === null ? Ie = "null" : kn(k) ? Ie = "array" : k !== void 0 && k.$$typeof === h ? (Ie = "<" + ($n(k.type) || "Unknown") + " />", ke = " Did you accidentally export a JSX literal instead of a component?") : Ie = typeof k, ae("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ie, ke);
        }
        var vt = Ye.apply(this, arguments);
        if (vt == null)
          return vt;
        if (ie)
          for (var Nt = 2; Nt < arguments.length; Nt++)
            zl(arguments[Nt], k);
        return k === S ? Mn(vt) : Sn(vt), vt;
      }
      var Sr = !1;
      function ii(k) {
        var j = ws.bind(null, k);
        return j.type = k, Sr || (Sr = !0, Fe("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(j, "type", {
          enumerable: !1,
          get: function() {
            return Fe("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: k
            }), k;
          }
        }), j;
      }
      function da(k, j, K) {
        for (var ie = Ut.apply(this, arguments), ke = 2; ke < arguments.length; ke++)
          zl(arguments[ke], ie.type);
        return Sn(ie), ie;
      }
      function cu(k, j) {
        var K = Ce.transition;
        Ce.transition = {};
        var ie = Ce.transition;
        Ce.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          k();
        } finally {
          if (Ce.transition = K, K === null && ie._updatedFibers) {
            var ke = ie._updatedFibers.size;
            ke > 10 && Fe("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), ie._updatedFibers.clear();
          }
        }
      }
      var Co = !1, wo = null;
      function Al(k) {
        if (wo === null)
          try {
            var j = ("require" + Math.random()).slice(0, 7), K = r && r[j];
            wo = K.call(r, "timers").setImmediate;
          } catch {
            wo = function(ke) {
              Co === !1 && (Co = !0, typeof MessageChannel > "u" && ae("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Je = new MessageChannel();
              Je.port1.onmessage = ke, Je.port2.postMessage(void 0);
            };
          }
        return wo(k);
      }
      var Pi = 0, Ja = !1;
      function fu(k) {
        {
          var j = Pi;
          Pi++, Y.current === null && (Y.current = []);
          var K = Y.isBatchingLegacy, ie;
          try {
            if (Y.isBatchingLegacy = !0, ie = k(), !K && Y.didScheduleLegacyUpdate) {
              var ke = Y.current;
              ke !== null && (Y.didScheduleLegacyUpdate = !1, el(ke));
            }
          } catch (an) {
            throw Za(j), an;
          } finally {
            Y.isBatchingLegacy = K;
          }
          if (ie !== null && typeof ie == "object" && typeof ie.then == "function") {
            var Je = ie, Ie = !1, vt = {
              then: function(an, xn) {
                Ie = !0, Je.then(function($t) {
                  Za(j), Pi === 0 ? du($t, an, xn) : an($t);
                }, function($t) {
                  Za(j), xn($t);
                });
              }
            };
            return !Ja && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Ie || (Ja = !0, ae("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), vt;
          } else {
            var Nt = ie;
            if (Za(j), Pi === 0) {
              var Zt = Y.current;
              Zt !== null && (el(Zt), Y.current = null);
              var nn = {
                then: function(an, xn) {
                  Y.current === null ? (Y.current = [], du(Nt, an, xn)) : an(Nt);
                }
              };
              return nn;
            } else {
              var rn = {
                then: function(an, xn) {
                  an(Nt);
                }
              };
              return rn;
            }
          }
        }
      }
      function Za(k) {
        k !== Pi - 1 && ae("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Pi = k;
      }
      function du(k, j, K) {
        {
          var ie = Y.current;
          if (ie !== null)
            try {
              el(ie), Al(function() {
                ie.length === 0 ? (Y.current = null, j(k)) : du(k, j, K);
              });
            } catch (ke) {
              K(ke);
            }
          else
            j(k);
        }
      }
      var Ra = !1;
      function el(k) {
        if (!Ra) {
          Ra = !0;
          var j = 0;
          try {
            for (; j < k.length; j++) {
              var K = k[j];
              do
                K = K(!0);
              while (K !== null);
            }
            k.length = 0;
          } catch (ie) {
            throw k = k.slice(j + 1), ie;
          } finally {
            Ra = !1;
          }
        }
      }
      var pu = ws, ks = da, pa = ii, hu = {
        map: Ai,
        forEach: mo,
        count: _l,
        toArray: yo,
        only: Dl
      };
      o.Children = hu, o.Component = bt, o.Fragment = S, o.Profiler = w, o.PureComponent = wn, o.StrictMode = v, o.Suspense = N, o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Qe, o.cloneElement = ks, o.createContext = sa, o.createElement = pu, o.createFactory = pa, o.createRef = Mr, o.forwardRef = Ga, o.isValidElement = Et, o.lazy = Ei, o.memo = Ne, o.startTransition = cu, o.unstable_act = fu, o.useCallback = Lr, o.useContext = zt, o.useDebugValue = ti, o.useDeferredValue = wa, o.useEffect = Zn, o.useId = Mt, o.useImperativeHandle = vn, o.useInsertionEffect = pn, o.useLayoutEffect = hn, o.useMemo = Ca, o.useReducer = Dt, o.useRef = ot, o.useState = Pt, o.useSyncExternalStore = go, o.useTransition = vs, o.version = f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Dh, Dh.exports)), Dh.exports;
}
var wN = {};
wN.NODE_ENV === "production" ? YS.exports = EN() : YS.exports = CN();
var ut = YS.exports;
const kN = /* @__PURE__ */ Ok(ut);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dw;
function TN() {
  if (dw)
    return Ch;
  dw = 1;
  var r = ut, o = Symbol.for("react.element"), s = Symbol.for("react.fragment"), f = Object.prototype.hasOwnProperty, h = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, y = { key: !0, ref: !0, __self: !0, __source: !0 };
  function S(v, w, E) {
    var R, D = {}, N = null, M = null;
    E !== void 0 && (N = "" + E), w.key !== void 0 && (N = "" + w.key), w.ref !== void 0 && (M = w.ref);
    for (R in w)
      f.call(w, R) && !y.hasOwnProperty(R) && (D[R] = w[R]);
    if (v && v.defaultProps)
      for (R in w = v.defaultProps, w)
        D[R] === void 0 && (D[R] = w[R]);
    return { $$typeof: o, type: v, key: N, ref: M, props: D, _owner: h.current };
  }
  return Ch.Fragment = s, Ch.jsx = S, Ch.jsxs = S, Ch;
}
var wh = {}, pw;
function RN() {
  if (pw)
    return wh;
  pw = 1;
  var r = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return r.NODE_ENV !== "production" && function() {
    var o = ut, s = Symbol.for("react.element"), f = Symbol.for("react.portal"), h = Symbol.for("react.fragment"), y = Symbol.for("react.strict_mode"), S = Symbol.for("react.profiler"), v = Symbol.for("react.provider"), w = Symbol.for("react.context"), E = Symbol.for("react.forward_ref"), R = Symbol.for("react.suspense"), D = Symbol.for("react.suspense_list"), N = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), F = Symbol.for("react.offscreen"), $ = Symbol.iterator, ce = "@@iterator";
    function X(U) {
      if (U === null || typeof U != "object")
        return null;
      var me = $ && U[$] || U[ce];
      return typeof me == "function" ? me : null;
    }
    var se = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function te(U) {
      {
        for (var me = arguments.length, Ne = new Array(me > 1 ? me - 1 : 0), je = 1; je < me; je++)
          Ne[je - 1] = arguments[je];
        Se("error", U, Ne);
      }
    }
    function Se(U, me, Ne) {
      {
        var je = se.ReactDebugCurrentFrame, zt = je.getStackAddendum();
        zt !== "" && (me += "%s", Ne = Ne.concat([zt]));
        var Pt = Ne.map(function(Dt) {
          return String(Dt);
        });
        Pt.unshift("Warning: " + me), Function.prototype.apply.call(console[U], console, Pt);
      }
    }
    var Ce = !1, Y = !1, Oe = !1, ze = !1, it = !1, lt;
    lt = Symbol.for("react.module.reference");
    function he(U) {
      return !!(typeof U == "string" || typeof U == "function" || U === h || U === S || it || U === y || U === R || U === D || ze || U === F || Ce || Y || Oe || typeof U == "object" && U !== null && (U.$$typeof === M || U.$$typeof === N || U.$$typeof === v || U.$$typeof === w || U.$$typeof === E || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      U.$$typeof === lt || U.getModuleId !== void 0));
    }
    function ne(U, me, Ne) {
      var je = U.displayName;
      if (je)
        return je;
      var zt = me.displayName || me.name || "";
      return zt !== "" ? Ne + "(" + zt + ")" : Ne;
    }
    function we(U) {
      return U.displayName || "Context";
    }
    function de(U) {
      if (U == null)
        return null;
      if (typeof U.tag == "number" && te("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof U == "function")
        return U.displayName || U.name || null;
      if (typeof U == "string")
        return U;
      switch (U) {
        case h:
          return "Fragment";
        case f:
          return "Portal";
        case S:
          return "Profiler";
        case y:
          return "StrictMode";
        case R:
          return "Suspense";
        case D:
          return "SuspenseList";
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case w:
            var me = U;
            return we(me) + ".Consumer";
          case v:
            var Ne = U;
            return we(Ne._context) + ".Provider";
          case E:
            return ne(U, U.render, "ForwardRef");
          case N:
            var je = U.displayName || null;
            return je !== null ? je : de(U.type) || "Memo";
          case M: {
            var zt = U, Pt = zt._payload, Dt = zt._init;
            try {
              return de(Dt(Pt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ge = Object.assign, Qe = 0, Fe, ae, _e, T, ue, Ae, A;
    function Ke() {
    }
    Ke.__reactDisabledLog = !0;
    function bt() {
      {
        if (Qe === 0) {
          Fe = console.log, ae = console.info, _e = console.warn, T = console.error, ue = console.group, Ae = console.groupCollapsed, A = console.groupEnd;
          var U = {
            configurable: !0,
            enumerable: !0,
            value: Ke,
            writable: !0
          };
          Object.defineProperties(console, {
            info: U,
            log: U,
            warn: U,
            error: U,
            group: U,
            groupCollapsed: U,
            groupEnd: U
          });
        }
        Qe++;
      }
    }
    function at() {
      {
        if (Qe--, Qe === 0) {
          var U = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ge({}, U, {
              value: Fe
            }),
            info: ge({}, U, {
              value: ae
            }),
            warn: ge({}, U, {
              value: _e
            }),
            error: ge({}, U, {
              value: T
            }),
            group: ge({}, U, {
              value: ue
            }),
            groupCollapsed: ge({}, U, {
              value: Ae
            }),
            groupEnd: ge({}, U, {
              value: A
            })
          });
        }
        Qe < 0 && te("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var _t = se.ReactCurrentDispatcher, mt;
    function Qt(U, me, Ne) {
      {
        if (mt === void 0)
          try {
            throw Error();
          } catch (zt) {
            var je = zt.stack.trim().match(/\n( *(at )?)/);
            mt = je && je[1] || "";
          }
        return `
` + mt + U;
      }
    }
    var wn = !1, An;
    {
      var Mr = typeof WeakMap == "function" ? WeakMap : Map;
      An = new Mr();
    }
    function sr(U, me) {
      if (!U || wn)
        return "";
      {
        var Ne = An.get(U);
        if (Ne !== void 0)
          return Ne;
      }
      var je;
      wn = !0;
      var zt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Pt;
      Pt = _t.current, _t.current = null, bt();
      try {
        if (me) {
          var Dt = function() {
            throw Error();
          };
          if (Object.defineProperty(Dt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Dt, []);
            } catch (ti) {
              je = ti;
            }
            Reflect.construct(U, [], Dt);
          } else {
            try {
              Dt.call();
            } catch (ti) {
              je = ti;
            }
            U.call(Dt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ti) {
            je = ti;
          }
          U();
        }
      } catch (ti) {
        if (ti && je && typeof ti.stack == "string") {
          for (var ot = ti.stack.split(`
`), Zn = je.stack.split(`
`), pn = ot.length - 1, hn = Zn.length - 1; pn >= 1 && hn >= 0 && ot[pn] !== Zn[hn]; )
            hn--;
          for (; pn >= 1 && hn >= 0; pn--, hn--)
            if (ot[pn] !== Zn[hn]) {
              if (pn !== 1 || hn !== 1)
                do
                  if (pn--, hn--, hn < 0 || ot[pn] !== Zn[hn]) {
                    var Lr = `
` + ot[pn].replace(" at new ", " at ");
                    return U.displayName && Lr.includes("<anonymous>") && (Lr = Lr.replace("<anonymous>", U.displayName)), typeof U == "function" && An.set(U, Lr), Lr;
                  }
                while (pn >= 1 && hn >= 0);
              break;
            }
        }
      } finally {
        wn = !1, _t.current = Pt, at(), Error.prepareStackTrace = zt;
      }
      var Ca = U ? U.displayName || U.name : "", vn = Ca ? Qt(Ca) : "";
      return typeof U == "function" && An.set(U, vn), vn;
    }
    function kn(U, me, Ne) {
      return sr(U, !1);
    }
    function Jn(U) {
      var me = U.prototype;
      return !!(me && me.isReactComponent);
    }
    function jn(U, me, Ne) {
      if (U == null)
        return "";
      if (typeof U == "function")
        return sr(U, Jn(U));
      if (typeof U == "string")
        return Qt(U);
      switch (U) {
        case R:
          return Qt("Suspense");
        case D:
          return Qt("SuspenseList");
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case E:
            return kn(U.render);
          case N:
            return jn(U.type, me, Ne);
          case M: {
            var je = U, zt = je._payload, Pt = je._init;
            try {
              return jn(Pt(zt), me, Ne);
            } catch {
            }
          }
        }
      return "";
    }
    var Dn = Object.prototype.hasOwnProperty, Un = {}, cr = se.ReactDebugCurrentFrame;
    function rr(U) {
      if (U) {
        var me = U._owner, Ne = jn(U.type, U._source, me ? me.type : null);
        cr.setExtraStackFrame(Ne);
      } else
        cr.setExtraStackFrame(null);
    }
    function $n(U, me, Ne, je, zt) {
      {
        var Pt = Function.call.bind(Dn);
        for (var Dt in U)
          if (Pt(U, Dt)) {
            var ot = void 0;
            try {
              if (typeof U[Dt] != "function") {
                var Zn = Error((je || "React class") + ": " + Ne + " type `" + Dt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof U[Dt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Zn.name = "Invariant Violation", Zn;
              }
              ot = U[Dt](me, Dt, je, Ne, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (pn) {
              ot = pn;
            }
            ot && !(ot instanceof Error) && (rr(zt), te("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", je || "React class", Ne, Dt, typeof ot), rr(null)), ot instanceof Error && !(ot.message in Un) && (Un[ot.message] = !0, rr(zt), te("Failed %s type: %s", Ne, ot.message), rr(null));
          }
      }
    }
    var Fr = Array.isArray;
    function Pr(U) {
      return Fr(U);
    }
    function fr(U) {
      {
        var me = typeof Symbol == "function" && Symbol.toStringTag, Ne = me && U[Symbol.toStringTag] || U.constructor.name || "Object";
        return Ne;
      }
    }
    function Hr(U) {
      try {
        return re(U), !1;
      } catch {
        return !0;
      }
    }
    function re(U) {
      return "" + U;
    }
    function Ee(U) {
      if (Hr(U))
        return te("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", fr(U)), re(U);
    }
    var $e = se.ReactCurrentOwner, yt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ot, gn, De;
    De = {};
    function Ye(U) {
      if (Dn.call(U, "ref")) {
        var me = Object.getOwnPropertyDescriptor(U, "ref").get;
        if (me && me.isReactWarning)
          return !1;
      }
      return U.ref !== void 0;
    }
    function St(U) {
      if (Dn.call(U, "key")) {
        var me = Object.getOwnPropertyDescriptor(U, "key").get;
        if (me && me.isReactWarning)
          return !1;
      }
      return U.key !== void 0;
    }
    function Ut(U, me) {
      if (typeof U.ref == "string" && $e.current && me && $e.current.stateNode !== me) {
        var Ne = de($e.current.type);
        De[Ne] || (te('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', de($e.current.type), U.ref), De[Ne] = !0);
      }
    }
    function Et(U, me) {
      {
        var Ne = function() {
          Ot || (Ot = !0, te("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", me));
        };
        Ne.isReactWarning = !0, Object.defineProperty(U, "key", {
          get: Ne,
          configurable: !0
        });
      }
    }
    function on(U, me) {
      {
        var Ne = function() {
          gn || (gn = !0, te("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", me));
        };
        Ne.isReactWarning = !0, Object.defineProperty(U, "ref", {
          get: Ne,
          configurable: !0
        });
      }
    }
    var Yt = function(U, me, Ne, je, zt, Pt, Dt) {
      var ot = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: s,
        // Built-in properties that belong on the element
        type: U,
        key: me,
        ref: Ne,
        props: Dt,
        // Record the component responsible for creating this element.
        _owner: Pt
      };
      return ot._store = {}, Object.defineProperty(ot._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ot, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: je
      }), Object.defineProperty(ot, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: zt
      }), Object.freeze && (Object.freeze(ot.props), Object.freeze(ot)), ot;
    };
    function Nr(U, me, Ne, je, zt) {
      {
        var Pt, Dt = {}, ot = null, Zn = null;
        Ne !== void 0 && (Ee(Ne), ot = "" + Ne), St(me) && (Ee(me.key), ot = "" + me.key), Ye(me) && (Zn = me.ref, Ut(me, zt));
        for (Pt in me)
          Dn.call(me, Pt) && !yt.hasOwnProperty(Pt) && (Dt[Pt] = me[Pt]);
        if (U && U.defaultProps) {
          var pn = U.defaultProps;
          for (Pt in pn)
            Dt[Pt] === void 0 && (Dt[Pt] = pn[Pt]);
        }
        if (ot || Zn) {
          var hn = typeof U == "function" ? U.displayName || U.name || "Unknown" : U;
          ot && Et(Dt, hn), Zn && on(Dt, hn);
        }
        return Yt(U, ot, Zn, zt, je, $e.current, Dt);
      }
    }
    var tn = se.ReactCurrentOwner, dr = se.ReactDebugCurrentFrame;
    function Jt(U) {
      if (U) {
        var me = U._owner, Ne = jn(U.type, U._source, me ? me.type : null);
        dr.setExtraStackFrame(Ne);
      } else
        dr.setExtraStackFrame(null);
    }
    var dn;
    dn = !1;
    function ua(U) {
      return typeof U == "object" && U !== null && U.$$typeof === s;
    }
    function Ai() {
      {
        if (tn.current) {
          var U = de(tn.current.type);
          if (U)
            return `

Check the render method of \`` + U + "`.";
        }
        return "";
      }
    }
    function _l(U) {
      {
        if (U !== void 0) {
          var me = U.fileName.replace(/^.*[\\\/]/, ""), Ne = U.lineNumber;
          return `

Check your code at ` + me + ":" + Ne + ".";
        }
        return "";
      }
    }
    var mo = {};
    function yo(U) {
      {
        var me = Ai();
        if (!me) {
          var Ne = typeof U == "string" ? U : U.displayName || U.name;
          Ne && (me = `

Check the top-level render call using <` + Ne + ">.");
        }
        return me;
      }
    }
    function Dl(U, me) {
      {
        if (!U._store || U._store.validated || U.key != null)
          return;
        U._store.validated = !0;
        var Ne = yo(me);
        if (mo[Ne])
          return;
        mo[Ne] = !0;
        var je = "";
        U && U._owner && U._owner !== tn.current && (je = " It was passed a child from " + de(U._owner.type) + "."), Jt(U), te('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ne, je), Jt(null);
      }
    }
    function sa(U, me) {
      {
        if (typeof U != "object")
          return;
        if (Pr(U))
          for (var Ne = 0; Ne < U.length; Ne++) {
            var je = U[Ne];
            ua(je) && Dl(je, me);
          }
        else if (ua(U))
          U._store && (U._store.validated = !0);
        else if (U) {
          var zt = X(U);
          if (typeof zt == "function" && zt !== U.entries)
            for (var Pt = zt.call(U), Dt; !(Dt = Pt.next()).done; )
              ua(Dt.value) && Dl(Dt.value, me);
        }
      }
    }
    function ca(U) {
      {
        var me = U.type;
        if (me == null || typeof me == "string")
          return;
        var Ne;
        if (typeof me == "function")
          Ne = me.propTypes;
        else if (typeof me == "object" && (me.$$typeof === E || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        me.$$typeof === N))
          Ne = me.propTypes;
        else
          return;
        if (Ne) {
          var je = de(me);
          $n(Ne, U.props, "prop", je, U);
        } else if (me.PropTypes !== void 0 && !dn) {
          dn = !0;
          var zt = de(me);
          te("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", zt || "Unknown");
        }
        typeof me.getDefaultProps == "function" && !me.getDefaultProps.isReactClassApproved && te("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ji(U) {
      {
        for (var me = Object.keys(U.props), Ne = 0; Ne < me.length; Ne++) {
          var je = me[Ne];
          if (je !== "children" && je !== "key") {
            Jt(U), te("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", je), Jt(null);
            break;
          }
        }
        U.ref !== null && (Jt(U), te("Invalid attribute `ref` supplied to `React.Fragment`."), Jt(null));
      }
    }
    function qa(U, me, Ne, je, zt, Pt) {
      {
        var Dt = he(U);
        if (!Dt) {
          var ot = "";
          (U === void 0 || typeof U == "object" && U !== null && Object.keys(U).length === 0) && (ot += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Zn = _l(zt);
          Zn ? ot += Zn : ot += Ai();
          var pn;
          U === null ? pn = "null" : Pr(U) ? pn = "array" : U !== void 0 && U.$$typeof === s ? (pn = "<" + (de(U.type) || "Unknown") + " />", ot = " Did you accidentally export a JSX literal instead of a component?") : pn = typeof U, te("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", pn, ot);
        }
        var hn = Nr(U, me, Ne, zt, Pt);
        if (hn == null)
          return hn;
        if (Dt) {
          var Lr = me.children;
          if (Lr !== void 0)
            if (je)
              if (Pr(Lr)) {
                for (var Ca = 0; Ca < Lr.length; Ca++)
                  sa(Lr[Ca], U);
                Object.freeze && Object.freeze(Lr);
              } else
                te("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              sa(Lr, U);
        }
        return U === h ? ji(hn) : ca(hn), hn;
      }
    }
    function Zr(U, me, Ne) {
      return qa(U, me, Ne, !0);
    }
    function ei(U, me, Ne) {
      return qa(U, me, Ne, !1);
    }
    var Ei = ei, Ga = Zr;
    wh.Fragment = h, wh.jsx = Ei, wh.jsxs = Ga;
  }(), wh;
}
var _N = {};
_N.NODE_ENV === "production" ? $S.exports = TN() : $S.exports = RN();
var V = $S.exports, Oh = {}, WS = { exports: {} }, ra = {}, My = { exports: {} }, _S = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hw;
function DN() {
  return hw || (hw = 1, function(r) {
    function o(ae, _e) {
      var T = ae.length;
      ae.push(_e);
      e:
        for (; 0 < T; ) {
          var ue = T - 1 >>> 1, Ae = ae[ue];
          if (0 < h(Ae, _e))
            ae[ue] = _e, ae[T] = Ae, T = ue;
          else
            break e;
        }
    }
    function s(ae) {
      return ae.length === 0 ? null : ae[0];
    }
    function f(ae) {
      if (ae.length === 0)
        return null;
      var _e = ae[0], T = ae.pop();
      if (T !== _e) {
        ae[0] = T;
        e:
          for (var ue = 0, Ae = ae.length, A = Ae >>> 1; ue < A; ) {
            var Ke = 2 * (ue + 1) - 1, bt = ae[Ke], at = Ke + 1, _t = ae[at];
            if (0 > h(bt, T))
              at < Ae && 0 > h(_t, bt) ? (ae[ue] = _t, ae[at] = T, ue = at) : (ae[ue] = bt, ae[Ke] = T, ue = Ke);
            else if (at < Ae && 0 > h(_t, T))
              ae[ue] = _t, ae[at] = T, ue = at;
            else
              break e;
          }
      }
      return _e;
    }
    function h(ae, _e) {
      var T = ae.sortIndex - _e.sortIndex;
      return T !== 0 ? T : ae.id - _e.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var y = performance;
      r.unstable_now = function() {
        return y.now();
      };
    } else {
      var S = Date, v = S.now();
      r.unstable_now = function() {
        return S.now() - v;
      };
    }
    var w = [], E = [], R = 1, D = null, N = 3, M = !1, F = !1, $ = !1, ce = typeof setTimeout == "function" ? setTimeout : null, X = typeof clearTimeout == "function" ? clearTimeout : null, se = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function te(ae) {
      for (var _e = s(E); _e !== null; ) {
        if (_e.callback === null)
          f(E);
        else if (_e.startTime <= ae)
          f(E), _e.sortIndex = _e.expirationTime, o(w, _e);
        else
          break;
        _e = s(E);
      }
    }
    function Se(ae) {
      if ($ = !1, te(ae), !F)
        if (s(w) !== null)
          F = !0, Qe(Ce);
        else {
          var _e = s(E);
          _e !== null && Fe(Se, _e.startTime - ae);
        }
    }
    function Ce(ae, _e) {
      F = !1, $ && ($ = !1, X(ze), ze = -1), M = !0;
      var T = N;
      try {
        for (te(_e), D = s(w); D !== null && (!(D.expirationTime > _e) || ae && !he()); ) {
          var ue = D.callback;
          if (typeof ue == "function") {
            D.callback = null, N = D.priorityLevel;
            var Ae = ue(D.expirationTime <= _e);
            _e = r.unstable_now(), typeof Ae == "function" ? D.callback = Ae : D === s(w) && f(w), te(_e);
          } else
            f(w);
          D = s(w);
        }
        if (D !== null)
          var A = !0;
        else {
          var Ke = s(E);
          Ke !== null && Fe(Se, Ke.startTime - _e), A = !1;
        }
        return A;
      } finally {
        D = null, N = T, M = !1;
      }
    }
    var Y = !1, Oe = null, ze = -1, it = 5, lt = -1;
    function he() {
      return !(r.unstable_now() - lt < it);
    }
    function ne() {
      if (Oe !== null) {
        var ae = r.unstable_now();
        lt = ae;
        var _e = !0;
        try {
          _e = Oe(!0, ae);
        } finally {
          _e ? we() : (Y = !1, Oe = null);
        }
      } else
        Y = !1;
    }
    var we;
    if (typeof se == "function")
      we = function() {
        se(ne);
      };
    else if (typeof MessageChannel < "u") {
      var de = new MessageChannel(), ge = de.port2;
      de.port1.onmessage = ne, we = function() {
        ge.postMessage(null);
      };
    } else
      we = function() {
        ce(ne, 0);
      };
    function Qe(ae) {
      Oe = ae, Y || (Y = !0, we());
    }
    function Fe(ae, _e) {
      ze = ce(function() {
        ae(r.unstable_now());
      }, _e);
    }
    r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function(ae) {
      ae.callback = null;
    }, r.unstable_continueExecution = function() {
      F || M || (F = !0, Qe(Ce));
    }, r.unstable_forceFrameRate = function(ae) {
      0 > ae || 125 < ae ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : it = 0 < ae ? Math.floor(1e3 / ae) : 5;
    }, r.unstable_getCurrentPriorityLevel = function() {
      return N;
    }, r.unstable_getFirstCallbackNode = function() {
      return s(w);
    }, r.unstable_next = function(ae) {
      switch (N) {
        case 1:
        case 2:
        case 3:
          var _e = 3;
          break;
        default:
          _e = N;
      }
      var T = N;
      N = _e;
      try {
        return ae();
      } finally {
        N = T;
      }
    }, r.unstable_pauseExecution = function() {
    }, r.unstable_requestPaint = function() {
    }, r.unstable_runWithPriority = function(ae, _e) {
      switch (ae) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ae = 3;
      }
      var T = N;
      N = ae;
      try {
        return _e();
      } finally {
        N = T;
      }
    }, r.unstable_scheduleCallback = function(ae, _e, T) {
      var ue = r.unstable_now();
      switch (typeof T == "object" && T !== null ? (T = T.delay, T = typeof T == "number" && 0 < T ? ue + T : ue) : T = ue, ae) {
        case 1:
          var Ae = -1;
          break;
        case 2:
          Ae = 250;
          break;
        case 5:
          Ae = 1073741823;
          break;
        case 4:
          Ae = 1e4;
          break;
        default:
          Ae = 5e3;
      }
      return Ae = T + Ae, ae = { id: R++, callback: _e, priorityLevel: ae, startTime: T, expirationTime: Ae, sortIndex: -1 }, T > ue ? (ae.sortIndex = T, o(E, ae), s(w) === null && ae === s(E) && ($ ? (X(ze), ze = -1) : $ = !0, Fe(Se, T - ue))) : (ae.sortIndex = Ae, o(w, ae), F || M || (F = !0, Qe(Ce))), ae;
    }, r.unstable_shouldYield = he, r.unstable_wrapCallback = function(ae) {
      var _e = N;
      return function() {
        var T = N;
        N = _e;
        try {
          return ae.apply(this, arguments);
        } finally {
          N = T;
        }
      };
    };
  }(_S)), _S;
}
var DS = {}, vw;
function ON() {
  return vw || (vw = 1, function(r) {
    var o = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    o.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var s = !1, f = !1, h = 5;
      function y(De, Ye) {
        var St = De.length;
        De.push(Ye), w(De, Ye, St);
      }
      function S(De) {
        return De.length === 0 ? null : De[0];
      }
      function v(De) {
        if (De.length === 0)
          return null;
        var Ye = De[0], St = De.pop();
        return St !== Ye && (De[0] = St, E(De, St, 0)), Ye;
      }
      function w(De, Ye, St) {
        for (var Ut = St; Ut > 0; ) {
          var Et = Ut - 1 >>> 1, on = De[Et];
          if (R(on, Ye) > 0)
            De[Et] = Ye, De[Ut] = on, Ut = Et;
          else
            return;
        }
      }
      function E(De, Ye, St) {
        for (var Ut = St, Et = De.length, on = Et >>> 1; Ut < on; ) {
          var Yt = (Ut + 1) * 2 - 1, Nr = De[Yt], tn = Yt + 1, dr = De[tn];
          if (R(Nr, Ye) < 0)
            tn < Et && R(dr, Nr) < 0 ? (De[Ut] = dr, De[tn] = Ye, Ut = tn) : (De[Ut] = Nr, De[Yt] = Ye, Ut = Yt);
          else if (tn < Et && R(dr, Ye) < 0)
            De[Ut] = dr, De[tn] = Ye, Ut = tn;
          else
            return;
        }
      }
      function R(De, Ye) {
        var St = De.sortIndex - Ye.sortIndex;
        return St !== 0 ? St : De.id - Ye.id;
      }
      var D = 1, N = 2, M = 3, F = 4, $ = 5;
      function ce(De, Ye) {
      }
      var X = typeof performance == "object" && typeof performance.now == "function";
      if (X) {
        var se = performance;
        r.unstable_now = function() {
          return se.now();
        };
      } else {
        var te = Date, Se = te.now();
        r.unstable_now = function() {
          return te.now() - Se;
        };
      }
      var Ce = 1073741823, Y = -1, Oe = 250, ze = 5e3, it = 1e4, lt = Ce, he = [], ne = [], we = 1, de = null, ge = M, Qe = !1, Fe = !1, ae = !1, _e = typeof setTimeout == "function" ? setTimeout : null, T = typeof clearTimeout == "function" ? clearTimeout : null, ue = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Ae(De) {
        for (var Ye = S(ne); Ye !== null; ) {
          if (Ye.callback === null)
            v(ne);
          else if (Ye.startTime <= De)
            v(ne), Ye.sortIndex = Ye.expirationTime, y(he, Ye);
          else
            return;
          Ye = S(ne);
        }
      }
      function A(De) {
        if (ae = !1, Ae(De), !Fe)
          if (S(he) !== null)
            Fe = !0, Ee(Ke);
          else {
            var Ye = S(ne);
            Ye !== null && $e(A, Ye.startTime - De);
          }
      }
      function Ke(De, Ye) {
        Fe = !1, ae && (ae = !1, yt()), Qe = !0;
        var St = ge;
        try {
          var Ut;
          if (!f)
            return bt(De, Ye);
        } finally {
          de = null, ge = St, Qe = !1;
        }
      }
      function bt(De, Ye) {
        var St = Ye;
        for (Ae(St), de = S(he); de !== null && !s && !(de.expirationTime > St && (!De || rr())); ) {
          var Ut = de.callback;
          if (typeof Ut == "function") {
            de.callback = null, ge = de.priorityLevel;
            var Et = de.expirationTime <= St, on = Ut(Et);
            St = r.unstable_now(), typeof on == "function" ? de.callback = on : de === S(he) && v(he), Ae(St);
          } else
            v(he);
          de = S(he);
        }
        if (de !== null)
          return !0;
        var Yt = S(ne);
        return Yt !== null && $e(A, Yt.startTime - St), !1;
      }
      function at(De, Ye) {
        switch (De) {
          case D:
          case N:
          case M:
          case F:
          case $:
            break;
          default:
            De = M;
        }
        var St = ge;
        ge = De;
        try {
          return Ye();
        } finally {
          ge = St;
        }
      }
      function _t(De) {
        var Ye;
        switch (ge) {
          case D:
          case N:
          case M:
            Ye = M;
            break;
          default:
            Ye = ge;
            break;
        }
        var St = ge;
        ge = Ye;
        try {
          return De();
        } finally {
          ge = St;
        }
      }
      function mt(De) {
        var Ye = ge;
        return function() {
          var St = ge;
          ge = Ye;
          try {
            return De.apply(this, arguments);
          } finally {
            ge = St;
          }
        };
      }
      function Qt(De, Ye, St) {
        var Ut = r.unstable_now(), Et;
        if (typeof St == "object" && St !== null) {
          var on = St.delay;
          typeof on == "number" && on > 0 ? Et = Ut + on : Et = Ut;
        } else
          Et = Ut;
        var Yt;
        switch (De) {
          case D:
            Yt = Y;
            break;
          case N:
            Yt = Oe;
            break;
          case $:
            Yt = lt;
            break;
          case F:
            Yt = it;
            break;
          case M:
          default:
            Yt = ze;
            break;
        }
        var Nr = Et + Yt, tn = {
          id: we++,
          callback: Ye,
          priorityLevel: De,
          startTime: Et,
          expirationTime: Nr,
          sortIndex: -1
        };
        return Et > Ut ? (tn.sortIndex = Et, y(ne, tn), S(he) === null && tn === S(ne) && (ae ? yt() : ae = !0, $e(A, Et - Ut))) : (tn.sortIndex = Nr, y(he, tn), !Fe && !Qe && (Fe = !0, Ee(Ke))), tn;
      }
      function wn() {
      }
      function An() {
        !Fe && !Qe && (Fe = !0, Ee(Ke));
      }
      function Mr() {
        return S(he);
      }
      function sr(De) {
        De.callback = null;
      }
      function kn() {
        return ge;
      }
      var Jn = !1, jn = null, Dn = -1, Un = h, cr = -1;
      function rr() {
        var De = r.unstable_now() - cr;
        return !(De < Un);
      }
      function $n() {
      }
      function Fr(De) {
        if (De < 0 || De > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        De > 0 ? Un = Math.floor(1e3 / De) : Un = h;
      }
      var Pr = function() {
        if (jn !== null) {
          var De = r.unstable_now();
          cr = De;
          var Ye = !0, St = !0;
          try {
            St = jn(Ye, De);
          } finally {
            St ? fr() : (Jn = !1, jn = null);
          }
        } else
          Jn = !1;
      }, fr;
      if (typeof ue == "function")
        fr = function() {
          ue(Pr);
        };
      else if (typeof MessageChannel < "u") {
        var Hr = new MessageChannel(), re = Hr.port2;
        Hr.port1.onmessage = Pr, fr = function() {
          re.postMessage(null);
        };
      } else
        fr = function() {
          _e(Pr, 0);
        };
      function Ee(De) {
        jn = De, Jn || (Jn = !0, fr());
      }
      function $e(De, Ye) {
        Dn = _e(function() {
          De(r.unstable_now());
        }, Ye);
      }
      function yt() {
        T(Dn), Dn = -1;
      }
      var Ot = $n, gn = null;
      r.unstable_IdlePriority = $, r.unstable_ImmediatePriority = D, r.unstable_LowPriority = F, r.unstable_NormalPriority = M, r.unstable_Profiling = gn, r.unstable_UserBlockingPriority = N, r.unstable_cancelCallback = sr, r.unstable_continueExecution = An, r.unstable_forceFrameRate = Fr, r.unstable_getCurrentPriorityLevel = kn, r.unstable_getFirstCallbackNode = Mr, r.unstable_next = _t, r.unstable_pauseExecution = wn, r.unstable_requestPaint = Ot, r.unstable_runWithPriority = at, r.unstable_scheduleCallback = Qt, r.unstable_shouldYield = rr, r.unstable_wrapCallback = mt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(DS)), DS;
}
var mw;
function Mk() {
  if (mw)
    return My.exports;
  mw = 1;
  var r = {};
  return r.NODE_ENV === "production" ? My.exports = DN() : My.exports = ON(), My.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yw;
function MN() {
  if (yw)
    return ra;
  yw = 1;
  var r = ut, o = Mk();
  function s(n) {
    for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, u = 1; u < arguments.length; u++)
      i += "&args[]=" + encodeURIComponent(arguments[u]);
    return "Minified React error #" + n + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var f = /* @__PURE__ */ new Set(), h = {};
  function y(n, i) {
    S(n, i), S(n + "Capture", i);
  }
  function S(n, i) {
    for (h[n] = i, n = 0; n < i.length; n++)
      f.add(i[n]);
  }
  var v = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), w = Object.prototype.hasOwnProperty, E = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, R = {}, D = {};
  function N(n) {
    return w.call(D, n) ? !0 : w.call(R, n) ? !1 : E.test(n) ? D[n] = !0 : (R[n] = !0, !1);
  }
  function M(n, i, u, d) {
    if (u !== null && u.type === 0)
      return !1;
    switch (typeof i) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return d ? !1 : u !== null ? !u.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-");
      default:
        return !1;
    }
  }
  function F(n, i, u, d) {
    if (i === null || typeof i > "u" || M(n, i, u, d))
      return !0;
    if (d)
      return !1;
    if (u !== null)
      switch (u.type) {
        case 3:
          return !i;
        case 4:
          return i === !1;
        case 5:
          return isNaN(i);
        case 6:
          return isNaN(i) || 1 > i;
      }
    return !1;
  }
  function $(n, i, u, d, m, x, _) {
    this.acceptsBooleans = i === 2 || i === 3 || i === 4, this.attributeName = d, this.attributeNamespace = m, this.mustUseProperty = u, this.propertyName = n, this.type = i, this.sanitizeURL = x, this.removeEmptyString = _;
  }
  var ce = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    ce[n] = new $(n, 0, !1, n, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
    var i = n[0];
    ce[i] = new $(i, 1, !1, n[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    ce[n] = new $(n, 2, !1, n.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    ce[n] = new $(n, 2, !1, n, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    ce[n] = new $(n, 3, !1, n.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(n) {
    ce[n] = new $(n, 3, !0, n, null, !1, !1);
  }), ["capture", "download"].forEach(function(n) {
    ce[n] = new $(n, 4, !1, n, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(n) {
    ce[n] = new $(n, 6, !1, n, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(n) {
    ce[n] = new $(n, 5, !1, n.toLowerCase(), null, !1, !1);
  });
  var X = /[\-:]([a-z])/g;
  function se(n) {
    return n[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var i = n.replace(
      X,
      se
    );
    ce[i] = new $(i, 1, !1, n, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var i = n.replace(X, se);
    ce[i] = new $(i, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var i = n.replace(X, se);
    ce[i] = new $(i, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(n) {
    ce[n] = new $(n, 1, !1, n.toLowerCase(), null, !1, !1);
  }), ce.xlinkHref = new $("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(n) {
    ce[n] = new $(n, 1, !1, n.toLowerCase(), null, !0, !0);
  });
  function te(n, i, u, d) {
    var m = ce.hasOwnProperty(i) ? ce[i] : null;
    (m !== null ? m.type !== 0 : d || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (F(i, u, m, d) && (u = null), d || m === null ? N(i) && (u === null ? n.removeAttribute(i) : n.setAttribute(i, "" + u)) : m.mustUseProperty ? n[m.propertyName] = u === null ? m.type === 3 ? !1 : "" : u : (i = m.attributeName, d = m.attributeNamespace, u === null ? n.removeAttribute(i) : (m = m.type, u = m === 3 || m === 4 && u === !0 ? "" : "" + u, d ? n.setAttributeNS(d, i, u) : n.setAttribute(i, u))));
  }
  var Se = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Ce = Symbol.for("react.element"), Y = Symbol.for("react.portal"), Oe = Symbol.for("react.fragment"), ze = Symbol.for("react.strict_mode"), it = Symbol.for("react.profiler"), lt = Symbol.for("react.provider"), he = Symbol.for("react.context"), ne = Symbol.for("react.forward_ref"), we = Symbol.for("react.suspense"), de = Symbol.for("react.suspense_list"), ge = Symbol.for("react.memo"), Qe = Symbol.for("react.lazy"), Fe = Symbol.for("react.offscreen"), ae = Symbol.iterator;
  function _e(n) {
    return n === null || typeof n != "object" ? null : (n = ae && n[ae] || n["@@iterator"], typeof n == "function" ? n : null);
  }
  var T = Object.assign, ue;
  function Ae(n) {
    if (ue === void 0)
      try {
        throw Error();
      } catch (u) {
        var i = u.stack.trim().match(/\n( *(at )?)/);
        ue = i && i[1] || "";
      }
    return `
` + ue + n;
  }
  var A = !1;
  function Ke(n, i) {
    if (!n || A)
      return "";
    A = !0;
    var u = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (i)
        if (i = function() {
          throw Error();
        }, Object.defineProperty(i.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(i, []);
          } catch (ee) {
            var d = ee;
          }
          Reflect.construct(n, [], i);
        } else {
          try {
            i.call();
          } catch (ee) {
            d = ee;
          }
          n.call(i.prototype);
        }
      else {
        try {
          throw Error();
        } catch (ee) {
          d = ee;
        }
        n();
      }
    } catch (ee) {
      if (ee && d && typeof ee.stack == "string") {
        for (var m = ee.stack.split(`
`), x = d.stack.split(`
`), _ = m.length - 1, z = x.length - 1; 1 <= _ && 0 <= z && m[_] !== x[z]; )
          z--;
        for (; 1 <= _ && 0 <= z; _--, z--)
          if (m[_] !== x[z]) {
            if (_ !== 1 || z !== 1)
              do
                if (_--, z--, 0 > z || m[_] !== x[z]) {
                  var P = `
` + m[_].replace(" at new ", " at ");
                  return n.displayName && P.includes("<anonymous>") && (P = P.replace("<anonymous>", n.displayName)), P;
                }
              while (1 <= _ && 0 <= z);
            break;
          }
      }
    } finally {
      A = !1, Error.prepareStackTrace = u;
    }
    return (n = n ? n.displayName || n.name : "") ? Ae(n) : "";
  }
  function bt(n) {
    switch (n.tag) {
      case 5:
        return Ae(n.type);
      case 16:
        return Ae("Lazy");
      case 13:
        return Ae("Suspense");
      case 19:
        return Ae("SuspenseList");
      case 0:
      case 2:
      case 15:
        return n = Ke(n.type, !1), n;
      case 11:
        return n = Ke(n.type.render, !1), n;
      case 1:
        return n = Ke(n.type, !0), n;
      default:
        return "";
    }
  }
  function at(n) {
    if (n == null)
      return null;
    if (typeof n == "function")
      return n.displayName || n.name || null;
    if (typeof n == "string")
      return n;
    switch (n) {
      case Oe:
        return "Fragment";
      case Y:
        return "Portal";
      case it:
        return "Profiler";
      case ze:
        return "StrictMode";
      case we:
        return "Suspense";
      case de:
        return "SuspenseList";
    }
    if (typeof n == "object")
      switch (n.$$typeof) {
        case he:
          return (n.displayName || "Context") + ".Consumer";
        case lt:
          return (n._context.displayName || "Context") + ".Provider";
        case ne:
          var i = n.render;
          return n = n.displayName, n || (n = i.displayName || i.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
        case ge:
          return i = n.displayName || null, i !== null ? i : at(n.type) || "Memo";
        case Qe:
          i = n._payload, n = n._init;
          try {
            return at(n(i));
          } catch {
          }
      }
    return null;
  }
  function _t(n) {
    var i = n.type;
    switch (n.tag) {
      case 24:
        return "Cache";
      case 9:
        return (i.displayName || "Context") + ".Consumer";
      case 10:
        return (i._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return n = i.render, n = n.displayName || n.name || "", i.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return i;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return at(i);
      case 8:
        return i === ze ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof i == "function")
          return i.displayName || i.name || null;
        if (typeof i == "string")
          return i;
    }
    return null;
  }
  function mt(n) {
    switch (typeof n) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return n;
      case "object":
        return n;
      default:
        return "";
    }
  }
  function Qt(n) {
    var i = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function wn(n) {
    var i = Qt(n) ? "checked" : "value", u = Object.getOwnPropertyDescriptor(n.constructor.prototype, i), d = "" + n[i];
    if (!n.hasOwnProperty(i) && typeof u < "u" && typeof u.get == "function" && typeof u.set == "function") {
      var m = u.get, x = u.set;
      return Object.defineProperty(n, i, { configurable: !0, get: function() {
        return m.call(this);
      }, set: function(_) {
        d = "" + _, x.call(this, _);
      } }), Object.defineProperty(n, i, { enumerable: u.enumerable }), { getValue: function() {
        return d;
      }, setValue: function(_) {
        d = "" + _;
      }, stopTracking: function() {
        n._valueTracker = null, delete n[i];
      } };
    }
  }
  function An(n) {
    n._valueTracker || (n._valueTracker = wn(n));
  }
  function Mr(n) {
    if (!n)
      return !1;
    var i = n._valueTracker;
    if (!i)
      return !0;
    var u = i.getValue(), d = "";
    return n && (d = Qt(n) ? n.checked ? "true" : "false" : n.value), n = d, n !== u ? (i.setValue(n), !0) : !1;
  }
  function sr(n) {
    if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u")
      return null;
    try {
      return n.activeElement || n.body;
    } catch {
      return n.body;
    }
  }
  function kn(n, i) {
    var u = i.checked;
    return T({}, i, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: u ?? n._wrapperState.initialChecked });
  }
  function Jn(n, i) {
    var u = i.defaultValue == null ? "" : i.defaultValue, d = i.checked != null ? i.checked : i.defaultChecked;
    u = mt(i.value != null ? i.value : u), n._wrapperState = { initialChecked: d, initialValue: u, controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null };
  }
  function jn(n, i) {
    i = i.checked, i != null && te(n, "checked", i, !1);
  }
  function Dn(n, i) {
    jn(n, i);
    var u = mt(i.value), d = i.type;
    if (u != null)
      d === "number" ? (u === 0 && n.value === "" || n.value != u) && (n.value = "" + u) : n.value !== "" + u && (n.value = "" + u);
    else if (d === "submit" || d === "reset") {
      n.removeAttribute("value");
      return;
    }
    i.hasOwnProperty("value") ? cr(n, i.type, u) : i.hasOwnProperty("defaultValue") && cr(n, i.type, mt(i.defaultValue)), i.checked == null && i.defaultChecked != null && (n.defaultChecked = !!i.defaultChecked);
  }
  function Un(n, i, u) {
    if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
      var d = i.type;
      if (!(d !== "submit" && d !== "reset" || i.value !== void 0 && i.value !== null))
        return;
      i = "" + n._wrapperState.initialValue, u || i === n.value || (n.value = i), n.defaultValue = i;
    }
    u = n.name, u !== "" && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, u !== "" && (n.name = u);
  }
  function cr(n, i, u) {
    (i !== "number" || sr(n.ownerDocument) !== n) && (u == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + u && (n.defaultValue = "" + u));
  }
  var rr = Array.isArray;
  function $n(n, i, u, d) {
    if (n = n.options, i) {
      i = {};
      for (var m = 0; m < u.length; m++)
        i["$" + u[m]] = !0;
      for (u = 0; u < n.length; u++)
        m = i.hasOwnProperty("$" + n[u].value), n[u].selected !== m && (n[u].selected = m), m && d && (n[u].defaultSelected = !0);
    } else {
      for (u = "" + mt(u), i = null, m = 0; m < n.length; m++) {
        if (n[m].value === u) {
          n[m].selected = !0, d && (n[m].defaultSelected = !0);
          return;
        }
        i !== null || n[m].disabled || (i = n[m]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function Fr(n, i) {
    if (i.dangerouslySetInnerHTML != null)
      throw Error(s(91));
    return T({}, i, { value: void 0, defaultValue: void 0, children: "" + n._wrapperState.initialValue });
  }
  function Pr(n, i) {
    var u = i.value;
    if (u == null) {
      if (u = i.children, i = i.defaultValue, u != null) {
        if (i != null)
          throw Error(s(92));
        if (rr(u)) {
          if (1 < u.length)
            throw Error(s(93));
          u = u[0];
        }
        i = u;
      }
      i == null && (i = ""), u = i;
    }
    n._wrapperState = { initialValue: mt(u) };
  }
  function fr(n, i) {
    var u = mt(i.value), d = mt(i.defaultValue);
    u != null && (u = "" + u, u !== n.value && (n.value = u), i.defaultValue == null && n.defaultValue !== u && (n.defaultValue = u)), d != null && (n.defaultValue = "" + d);
  }
  function Hr(n) {
    var i = n.textContent;
    i === n._wrapperState.initialValue && i !== "" && i !== null && (n.value = i);
  }
  function re(n) {
    switch (n) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Ee(n, i) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? re(i) : n === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n;
  }
  var $e, yt = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, u, d, m) {
      MSApp.execUnsafeLocalFunction(function() {
        return n(i, u, d, m);
      });
    } : n;
  }(function(n, i) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = i;
    else {
      for ($e = $e || document.createElement("div"), $e.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>", i = $e.firstChild; n.firstChild; )
        n.removeChild(n.firstChild);
      for (; i.firstChild; )
        n.appendChild(i.firstChild);
    }
  });
  function Ot(n, i) {
    if (i) {
      var u = n.firstChild;
      if (u && u === n.lastChild && u.nodeType === 3) {
        u.nodeValue = i;
        return;
      }
    }
    n.textContent = i;
  }
  var gn = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, De = ["Webkit", "ms", "Moz", "O"];
  Object.keys(gn).forEach(function(n) {
    De.forEach(function(i) {
      i = i + n.charAt(0).toUpperCase() + n.substring(1), gn[i] = gn[n];
    });
  });
  function Ye(n, i, u) {
    return i == null || typeof i == "boolean" || i === "" ? "" : u || typeof i != "number" || i === 0 || gn.hasOwnProperty(n) && gn[n] ? ("" + i).trim() : i + "px";
  }
  function St(n, i) {
    n = n.style;
    for (var u in i)
      if (i.hasOwnProperty(u)) {
        var d = u.indexOf("--") === 0, m = Ye(u, i[u], d);
        u === "float" && (u = "cssFloat"), d ? n.setProperty(u, m) : n[u] = m;
      }
  }
  var Ut = T({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Et(n, i) {
    if (i) {
      if (Ut[n] && (i.children != null || i.dangerouslySetInnerHTML != null))
        throw Error(s(137, n));
      if (i.dangerouslySetInnerHTML != null) {
        if (i.children != null)
          throw Error(s(60));
        if (typeof i.dangerouslySetInnerHTML != "object" || !("__html" in i.dangerouslySetInnerHTML))
          throw Error(s(61));
      }
      if (i.style != null && typeof i.style != "object")
        throw Error(s(62));
    }
  }
  function on(n, i) {
    if (n.indexOf("-") === -1)
      return typeof i.is == "string";
    switch (n) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Yt = null;
  function Nr(n) {
    return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n;
  }
  var tn = null, dr = null, Jt = null;
  function dn(n) {
    if (n = Da(n)) {
      if (typeof tn != "function")
        throw Error(s(280));
      var i = n.stateNode;
      i && (i = qc(i), tn(n.stateNode, n.type, i));
    }
  }
  function ua(n) {
    dr ? Jt ? Jt.push(n) : Jt = [n] : dr = n;
  }
  function Ai() {
    if (dr) {
      var n = dr, i = Jt;
      if (Jt = dr = null, dn(n), i)
        for (n = 0; n < i.length; n++)
          dn(i[n]);
    }
  }
  function _l(n, i) {
    return n(i);
  }
  function mo() {
  }
  var yo = !1;
  function Dl(n, i, u) {
    if (yo)
      return n(i, u);
    yo = !0;
    try {
      return _l(n, i, u);
    } finally {
      yo = !1, (dr !== null || Jt !== null) && (mo(), Ai());
    }
  }
  function sa(n, i) {
    var u = n.stateNode;
    if (u === null)
      return null;
    var d = qc(u);
    if (d === null)
      return null;
    u = d[i];
    e:
      switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d = !d.disabled) || (n = n.type, d = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !d;
          break e;
        default:
          n = !1;
      }
    if (n)
      return null;
    if (u && typeof u != "function")
      throw Error(s(231, i, typeof u));
    return u;
  }
  var ca = !1;
  if (v)
    try {
      var ji = {};
      Object.defineProperty(ji, "passive", { get: function() {
        ca = !0;
      } }), window.addEventListener("test", ji, ji), window.removeEventListener("test", ji, ji);
    } catch {
      ca = !1;
    }
  function qa(n, i, u, d, m, x, _, z, P) {
    var ee = Array.prototype.slice.call(arguments, 3);
    try {
      i.apply(u, ee);
    } catch (ye) {
      this.onError(ye);
    }
  }
  var Zr = !1, ei = null, Ei = !1, Ga = null, U = { onError: function(n) {
    Zr = !0, ei = n;
  } };
  function me(n, i, u, d, m, x, _, z, P) {
    Zr = !1, ei = null, qa.apply(U, arguments);
  }
  function Ne(n, i, u, d, m, x, _, z, P) {
    if (me.apply(this, arguments), Zr) {
      if (Zr) {
        var ee = ei;
        Zr = !1, ei = null;
      } else
        throw Error(s(198));
      Ei || (Ei = !0, Ga = ee);
    }
  }
  function je(n) {
    var i = n, u = n;
    if (n.alternate)
      for (; i.return; )
        i = i.return;
    else {
      n = i;
      do
        i = n, i.flags & 4098 && (u = i.return), n = i.return;
      while (n);
    }
    return i.tag === 3 ? u : null;
  }
  function zt(n) {
    if (n.tag === 13) {
      var i = n.memoizedState;
      if (i === null && (n = n.alternate, n !== null && (i = n.memoizedState)), i !== null)
        return i.dehydrated;
    }
    return null;
  }
  function Pt(n) {
    if (je(n) !== n)
      throw Error(s(188));
  }
  function Dt(n) {
    var i = n.alternate;
    if (!i) {
      if (i = je(n), i === null)
        throw Error(s(188));
      return i !== n ? null : n;
    }
    for (var u = n, d = i; ; ) {
      var m = u.return;
      if (m === null)
        break;
      var x = m.alternate;
      if (x === null) {
        if (d = m.return, d !== null) {
          u = d;
          continue;
        }
        break;
      }
      if (m.child === x.child) {
        for (x = m.child; x; ) {
          if (x === u)
            return Pt(m), n;
          if (x === d)
            return Pt(m), i;
          x = x.sibling;
        }
        throw Error(s(188));
      }
      if (u.return !== d.return)
        u = m, d = x;
      else {
        for (var _ = !1, z = m.child; z; ) {
          if (z === u) {
            _ = !0, u = m, d = x;
            break;
          }
          if (z === d) {
            _ = !0, d = m, u = x;
            break;
          }
          z = z.sibling;
        }
        if (!_) {
          for (z = x.child; z; ) {
            if (z === u) {
              _ = !0, u = x, d = m;
              break;
            }
            if (z === d) {
              _ = !0, d = x, u = m;
              break;
            }
            z = z.sibling;
          }
          if (!_)
            throw Error(s(189));
        }
      }
      if (u.alternate !== d)
        throw Error(s(190));
    }
    if (u.tag !== 3)
      throw Error(s(188));
    return u.stateNode.current === u ? n : i;
  }
  function ot(n) {
    return n = Dt(n), n !== null ? Zn(n) : null;
  }
  function Zn(n) {
    if (n.tag === 5 || n.tag === 6)
      return n;
    for (n = n.child; n !== null; ) {
      var i = Zn(n);
      if (i !== null)
        return i;
      n = n.sibling;
    }
    return null;
  }
  var pn = o.unstable_scheduleCallback, hn = o.unstable_cancelCallback, Lr = o.unstable_shouldYield, Ca = o.unstable_requestPaint, vn = o.unstable_now, ti = o.unstable_getCurrentPriorityLevel, vs = o.unstable_ImmediatePriority, wa = o.unstable_UserBlockingPriority, Mt = o.unstable_NormalPriority, go = o.unstable_LowPriority, Xa = o.unstable_IdlePriority, Ol = null, ni = null;
  function ms(n) {
    if (ni && typeof ni.onCommitFiberRoot == "function")
      try {
        ni.onCommitFiberRoot(Ol, n, void 0, (n.current.flags & 128) === 128);
      } catch {
      }
  }
  var Ir = Math.clz32 ? Math.clz32 : Ss, ys = Math.log, gs = Math.LN2;
  function Ss(n) {
    return n >>>= 0, n === 0 ? 32 : 31 - (ys(n) / gs | 0) | 0;
  }
  var So = 64, ou = 4194304;
  function Ka(n) {
    switch (n & -n) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return n & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return n;
    }
  }
  function ka(n, i) {
    var u = n.pendingLanes;
    if (u === 0)
      return 0;
    var d = 0, m = n.suspendedLanes, x = n.pingedLanes, _ = u & 268435455;
    if (_ !== 0) {
      var z = _ & ~m;
      z !== 0 ? d = Ka(z) : (x &= _, x !== 0 && (d = Ka(x)));
    } else
      _ = u & ~m, _ !== 0 ? d = Ka(_) : x !== 0 && (d = Ka(x));
    if (d === 0)
      return 0;
    if (i !== 0 && i !== d && !(i & m) && (m = d & -d, x = i & -i, m >= x || m === 16 && (x & 4194240) !== 0))
      return i;
    if (d & 4 && (d |= u & 16), i = n.entangledLanes, i !== 0)
      for (n = n.entanglements, i &= d; 0 < i; )
        u = 31 - Ir(i), m = 1 << u, d |= n[u], i &= ~m;
    return d;
  }
  function Ui(n, i) {
    switch (n) {
      case 1:
      case 2:
      case 4:
        return i + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ml(n, i) {
    for (var u = n.suspendedLanes, d = n.pingedLanes, m = n.expirationTimes, x = n.pendingLanes; 0 < x; ) {
      var _ = 31 - Ir(x), z = 1 << _, P = m[_];
      P === -1 ? (!(z & u) || z & d) && (m[_] = Ui(z, i)) : P <= i && (n.expiredLanes |= z), x &= ~z;
    }
  }
  function Ta(n) {
    return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0;
  }
  function xo() {
    var n = So;
    return So <<= 1, !(So & 4194240) && (So = 64), n;
  }
  function bo(n) {
    for (var i = [], u = 0; 31 > u; u++)
      i.push(n);
    return i;
  }
  function Nl(n, i, u) {
    n.pendingLanes |= i, i !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, i = 31 - Ir(i), n[i] = u;
  }
  function xs(n, i) {
    var u = n.pendingLanes & ~i;
    n.pendingLanes = i, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= i, n.mutableReadLanes &= i, n.entangledLanes &= i, i = n.entanglements;
    var d = n.eventTimes;
    for (n = n.expirationTimes; 0 < u; ) {
      var m = 31 - Ir(u), x = 1 << m;
      i[m] = 0, d[m] = -1, n[m] = -1, u &= ~x;
    }
  }
  function bs(n, i) {
    var u = n.entangledLanes |= i;
    for (n = n.entanglements; u; ) {
      var d = 31 - Ir(u), m = 1 << d;
      m & i | n[d] & i && (n[d] |= i), u &= ~m;
    }
  }
  var Ft = 0;
  function Es(n) {
    return n &= -n, 1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var uu, Ll, Cs, Vt, su, Eo = !1, xt = [], fa = null, On = null, ri = null, Fi = /* @__PURE__ */ new Map(), zl = /* @__PURE__ */ new Map(), Sn = [], Mn = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function ws(n, i) {
    switch (n) {
      case "focusin":
      case "focusout":
        fa = null;
        break;
      case "dragenter":
      case "dragleave":
        On = null;
        break;
      case "mouseover":
      case "mouseout":
        ri = null;
        break;
      case "pointerover":
      case "pointerout":
        Fi.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        zl.delete(i.pointerId);
    }
  }
  function Sr(n, i, u, d, m, x) {
    return n === null || n.nativeEvent !== x ? (n = { blockedOn: i, domEventName: u, eventSystemFlags: d, nativeEvent: x, targetContainers: [m] }, i !== null && (i = Da(i), i !== null && Ll(i)), n) : (n.eventSystemFlags |= d, i = n.targetContainers, m !== null && i.indexOf(m) === -1 && i.push(m), n);
  }
  function ii(n, i, u, d, m) {
    switch (i) {
      case "focusin":
        return fa = Sr(fa, n, i, u, d, m), !0;
      case "dragenter":
        return On = Sr(On, n, i, u, d, m), !0;
      case "mouseover":
        return ri = Sr(ri, n, i, u, d, m), !0;
      case "pointerover":
        var x = m.pointerId;
        return Fi.set(x, Sr(Fi.get(x) || null, n, i, u, d, m)), !0;
      case "gotpointercapture":
        return x = m.pointerId, zl.set(x, Sr(zl.get(x) || null, n, i, u, d, m)), !0;
    }
    return !1;
  }
  function da(n) {
    var i = ul(n.target);
    if (i !== null) {
      var u = je(i);
      if (u !== null) {
        if (i = u.tag, i === 13) {
          if (i = zt(u), i !== null) {
            n.blockedOn = i, su(n.priority, function() {
              Cs(u);
            });
            return;
          }
        } else if (i === 3 && u.stateNode.current.memoizedState.isDehydrated) {
          n.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
          return;
        }
      }
    }
    n.blockedOn = null;
  }
  function cu(n) {
    if (n.blockedOn !== null)
      return !1;
    for (var i = n.targetContainers; 0 < i.length; ) {
      var u = pu(n.domEventName, n.eventSystemFlags, i[0], n.nativeEvent);
      if (u === null) {
        u = n.nativeEvent;
        var d = new u.constructor(u.type, u);
        Yt = d, u.target.dispatchEvent(d), Yt = null;
      } else
        return i = Da(u), i !== null && Ll(i), n.blockedOn = u, !1;
      i.shift();
    }
    return !0;
  }
  function Co(n, i, u) {
    cu(n) && u.delete(i);
  }
  function wo() {
    Eo = !1, fa !== null && cu(fa) && (fa = null), On !== null && cu(On) && (On = null), ri !== null && cu(ri) && (ri = null), Fi.forEach(Co), zl.forEach(Co);
  }
  function Al(n, i) {
    n.blockedOn === i && (n.blockedOn = null, Eo || (Eo = !0, o.unstable_scheduleCallback(o.unstable_NormalPriority, wo)));
  }
  function Pi(n) {
    function i(m) {
      return Al(m, n);
    }
    if (0 < xt.length) {
      Al(xt[0], n);
      for (var u = 1; u < xt.length; u++) {
        var d = xt[u];
        d.blockedOn === n && (d.blockedOn = null);
      }
    }
    for (fa !== null && Al(fa, n), On !== null && Al(On, n), ri !== null && Al(ri, n), Fi.forEach(i), zl.forEach(i), u = 0; u < Sn.length; u++)
      d = Sn[u], d.blockedOn === n && (d.blockedOn = null);
    for (; 0 < Sn.length && (u = Sn[0], u.blockedOn === null); )
      da(u), u.blockedOn === null && Sn.shift();
  }
  var Ja = Se.ReactCurrentBatchConfig, fu = !0;
  function Za(n, i, u, d) {
    var m = Ft, x = Ja.transition;
    Ja.transition = null;
    try {
      Ft = 1, Ra(n, i, u, d);
    } finally {
      Ft = m, Ja.transition = x;
    }
  }
  function du(n, i, u, d) {
    var m = Ft, x = Ja.transition;
    Ja.transition = null;
    try {
      Ft = 4, Ra(n, i, u, d);
    } finally {
      Ft = m, Ja.transition = x;
    }
  }
  function Ra(n, i, u, d) {
    if (fu) {
      var m = pu(n, i, u, d);
      if (m === null)
        Fd(n, i, d, el, u), ws(n, d);
      else if (ii(m, n, i, u, d))
        d.stopPropagation();
      else if (ws(n, d), i & 4 && -1 < Mn.indexOf(n)) {
        for (; m !== null; ) {
          var x = Da(m);
          if (x !== null && uu(x), x = pu(n, i, u, d), x === null && Fd(n, i, d, el, u), x === m)
            break;
          m = x;
        }
        m !== null && d.stopPropagation();
      } else
        Fd(n, i, d, null, u);
    }
  }
  var el = null;
  function pu(n, i, u, d) {
    if (el = null, n = Nr(d), n = ul(n), n !== null)
      if (i = je(n), i === null)
        n = null;
      else if (u = i.tag, u === 13) {
        if (n = zt(i), n !== null)
          return n;
        n = null;
      } else if (u === 3) {
        if (i.stateNode.current.memoizedState.isDehydrated)
          return i.tag === 3 ? i.stateNode.containerInfo : null;
        n = null;
      } else
        i !== n && (n = null);
    return el = n, null;
  }
  function ks(n) {
    switch (n) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ti()) {
          case vs:
            return 1;
          case wa:
            return 4;
          case Mt:
          case go:
            return 16;
          case Xa:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var pa = null, hu = null, k = null;
  function j() {
    if (k)
      return k;
    var n, i = hu, u = i.length, d, m = "value" in pa ? pa.value : pa.textContent, x = m.length;
    for (n = 0; n < u && i[n] === m[n]; n++)
      ;
    var _ = u - n;
    for (d = 1; d <= _ && i[u - d] === m[x - d]; d++)
      ;
    return k = m.slice(n, 1 < d ? 1 - d : void 0);
  }
  function K(n) {
    var i = n.keyCode;
    return "charCode" in n ? (n = n.charCode, n === 0 && i === 13 && (n = 13)) : n = i, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0;
  }
  function ie() {
    return !0;
  }
  function ke() {
    return !1;
  }
  function Je(n) {
    function i(u, d, m, x, _) {
      this._reactName = u, this._targetInst = m, this.type = d, this.nativeEvent = x, this.target = _, this.currentTarget = null;
      for (var z in n)
        n.hasOwnProperty(z) && (u = n[z], this[z] = u ? u(x) : x[z]);
      return this.isDefaultPrevented = (x.defaultPrevented != null ? x.defaultPrevented : x.returnValue === !1) ? ie : ke, this.isPropagationStopped = ke, this;
    }
    return T(i.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var u = this.nativeEvent;
      u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1), this.isDefaultPrevented = ie);
    }, stopPropagation: function() {
      var u = this.nativeEvent;
      u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0), this.isPropagationStopped = ie);
    }, persist: function() {
    }, isPersistent: ie }), i;
  }
  var Ie = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(n) {
    return n.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, vt = Je(Ie), Nt = T({}, Ie, { view: 0, detail: 0 }), Zt = Je(Nt), nn, rn, an, xn = T({}, Nt, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Fc, button: 0, buttons: 0, relatedTarget: function(n) {
    return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
  }, movementX: function(n) {
    return "movementX" in n ? n.movementX : (n !== an && (an && n.type === "mousemove" ? (nn = n.screenX - an.screenX, rn = n.screenY - an.screenY) : rn = nn = 0, an = n), nn);
  }, movementY: function(n) {
    return "movementY" in n ? n.movementY : rn;
  } }), $t = Je(xn), jl = T({}, xn, { dataTransfer: 0 }), vu = Je(jl), Ts = T({}, Nt, { relatedTarget: 0 }), Rs = Je(Ts), tl = T({}, Ie, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), _s = Je(tl), Ds = T({}, Ie, { clipboardData: function(n) {
    return "clipboardData" in n ? n.clipboardData : window.clipboardData;
  } }), Td = Je(Ds), rg = T({}, Ie, { data: 0 }), Bh = Je(rg), Vh = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Rd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, $h = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Yh(n) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(n) : (n = $h[n]) ? !!i[n] : !1;
  }
  function Fc() {
    return Yh;
  }
  var ig = T({}, Nt, { key: function(n) {
    if (n.key) {
      var i = Vh[n.key] || n.key;
      if (i !== "Unidentified")
        return i;
    }
    return n.type === "keypress" ? (n = K(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? Rd[n.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Fc, charCode: function(n) {
    return n.type === "keypress" ? K(n) : 0;
  }, keyCode: function(n) {
    return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
  }, which: function(n) {
    return n.type === "keypress" ? K(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
  } }), nl = Je(ig), ag = T({}, xn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Pc = Je(ag), _d = T({}, Nt, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Fc }), Dd = Je(_d), lg = T({}, Ie, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Hc = Je(lg), Wh = T({}, xn, {
    deltaX: function(n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function(n) {
      return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), ai = Je(Wh), rl = [9, 13, 27, 32], Fn = v && "CompositionEvent" in window, Ci = null;
  v && "documentMode" in document && (Ci = document.documentMode);
  var Od = v && "TextEvent" in window && !Ci, Os = v && (!Fn || Ci && 8 < Ci && 11 >= Ci), Qh = " ", mu = !1;
  function qh(n, i) {
    switch (n) {
      case "keyup":
        return rl.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Gh(n) {
    return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
  }
  var Ul = !1;
  function og(n, i) {
    switch (n) {
      case "compositionend":
        return Gh(i);
      case "keypress":
        return i.which !== 32 ? null : (mu = !0, Qh);
      case "textInput":
        return n = i.data, n === Qh && mu ? null : n;
      default:
        return null;
    }
  }
  function ug(n, i) {
    if (Ul)
      return n === "compositionend" || !Fn && qh(n, i) ? (n = j(), k = hu = pa = null, Ul = !1, n) : null;
    switch (n) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length)
            return i.char;
          if (i.which)
            return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return Os && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var sg = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Md(n) {
    var i = n && n.nodeName && n.nodeName.toLowerCase();
    return i === "input" ? !!sg[n.type] : i === "textarea";
  }
  function Xh(n, i, u, d) {
    ua(d), i = Wc(i, "onChange"), 0 < i.length && (u = new vt("onChange", "change", null, u, d), n.push({ event: u, listeners: i }));
  }
  var Ms = null, Ns = null;
  function Kh(n) {
    pv(n, 0);
  }
  function il(n) {
    var i = xu(n);
    if (Mr(i))
      return n;
  }
  function Nd(n, i) {
    if (n === "change")
      return i;
  }
  var Ld = !1;
  if (v) {
    var Ic;
    if (v) {
      var zd = "oninput" in document;
      if (!zd) {
        var Jh = document.createElement("div");
        Jh.setAttribute("oninput", "return;"), zd = typeof Jh.oninput == "function";
      }
      Ic = zd;
    } else
      Ic = !1;
    Ld = Ic && (!document.documentMode || 9 < document.documentMode);
  }
  function Zh() {
    Ms && (Ms.detachEvent("onpropertychange", ev), Ns = Ms = null);
  }
  function ev(n) {
    if (n.propertyName === "value" && il(Ns)) {
      var i = [];
      Xh(i, Ns, n, Nr(n)), Dl(Kh, i);
    }
  }
  function cg(n, i, u) {
    n === "focusin" ? (Zh(), Ms = i, Ns = u, Ms.attachEvent("onpropertychange", ev)) : n === "focusout" && Zh();
  }
  function fg(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
      return il(Ns);
  }
  function dg(n, i) {
    if (n === "click")
      return il(i);
  }
  function pg(n, i) {
    if (n === "input" || n === "change")
      return il(i);
  }
  function tv(n, i) {
    return n === i && (n !== 0 || 1 / n === 1 / i) || n !== n && i !== i;
  }
  var ha = typeof Object.is == "function" ? Object.is : tv;
  function yu(n, i) {
    if (ha(n, i))
      return !0;
    if (typeof n != "object" || n === null || typeof i != "object" || i === null)
      return !1;
    var u = Object.keys(n), d = Object.keys(i);
    if (u.length !== d.length)
      return !1;
    for (d = 0; d < u.length; d++) {
      var m = u[d];
      if (!w.call(i, m) || !ha(n[m], i[m]))
        return !1;
    }
    return !0;
  }
  function nv(n) {
    for (; n && n.firstChild; )
      n = n.firstChild;
    return n;
  }
  function rv(n, i) {
    var u = nv(n);
    n = 0;
    for (var d; u; ) {
      if (u.nodeType === 3) {
        if (d = n + u.textContent.length, n <= i && d >= i)
          return { node: u, offset: i - n };
        n = d;
      }
      e: {
        for (; u; ) {
          if (u.nextSibling) {
            u = u.nextSibling;
            break e;
          }
          u = u.parentNode;
        }
        u = void 0;
      }
      u = nv(u);
    }
  }
  function iv(n, i) {
    return n && i ? n === i ? !0 : n && n.nodeType === 3 ? !1 : i && i.nodeType === 3 ? iv(n, i.parentNode) : "contains" in n ? n.contains(i) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function av() {
    for (var n = window, i = sr(); i instanceof n.HTMLIFrameElement; ) {
      try {
        var u = typeof i.contentWindow.location.href == "string";
      } catch {
        u = !1;
      }
      if (u)
        n = i.contentWindow;
      else
        break;
      i = sr(n.document);
    }
    return i;
  }
  function Ls(n) {
    var i = n && n.nodeName && n.nodeName.toLowerCase();
    return i && (i === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || i === "textarea" || n.contentEditable === "true");
  }
  function ko(n) {
    var i = av(), u = n.focusedElem, d = n.selectionRange;
    if (i !== u && u && u.ownerDocument && iv(u.ownerDocument.documentElement, u)) {
      if (d !== null && Ls(u)) {
        if (i = d.start, n = d.end, n === void 0 && (n = i), "selectionStart" in u)
          u.selectionStart = i, u.selectionEnd = Math.min(n, u.value.length);
        else if (n = (i = u.ownerDocument || document) && i.defaultView || window, n.getSelection) {
          n = n.getSelection();
          var m = u.textContent.length, x = Math.min(d.start, m);
          d = d.end === void 0 ? x : Math.min(d.end, m), !n.extend && x > d && (m = d, d = x, x = m), m = rv(u, x);
          var _ = rv(
            u,
            d
          );
          m && _ && (n.rangeCount !== 1 || n.anchorNode !== m.node || n.anchorOffset !== m.offset || n.focusNode !== _.node || n.focusOffset !== _.offset) && (i = i.createRange(), i.setStart(m.node, m.offset), n.removeAllRanges(), x > d ? (n.addRange(i), n.extend(_.node, _.offset)) : (i.setEnd(_.node, _.offset), n.addRange(i)));
        }
      }
      for (i = [], n = u; n = n.parentNode; )
        n.nodeType === 1 && i.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
      for (typeof u.focus == "function" && u.focus(), u = 0; u < i.length; u++)
        n = i[u], n.element.scrollLeft = n.left, n.element.scrollTop = n.top;
    }
  }
  var Bc = v && "documentMode" in document && 11 >= document.documentMode, To = null, Fl = null, zs = null, Ad = !1;
  function lv(n, i, u) {
    var d = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
    Ad || To == null || To !== sr(d) || (d = To, "selectionStart" in d && Ls(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), zs && yu(zs, d) || (zs = d, d = Wc(Fl, "onSelect"), 0 < d.length && (i = new vt("onSelect", "select", null, i, u), n.push({ event: i, listeners: d }), i.target = To)));
  }
  function Vc(n, i) {
    var u = {};
    return u[n.toLowerCase()] = i.toLowerCase(), u["Webkit" + n] = "webkit" + i, u["Moz" + n] = "moz" + i, u;
  }
  var gu = { animationend: Vc("Animation", "AnimationEnd"), animationiteration: Vc("Animation", "AnimationIteration"), animationstart: Vc("Animation", "AnimationStart"), transitionend: Vc("Transition", "TransitionEnd") }, $c = {}, ov = {};
  v && (ov = document.createElement("div").style, "AnimationEvent" in window || (delete gu.animationend.animation, delete gu.animationiteration.animation, delete gu.animationstart.animation), "TransitionEvent" in window || delete gu.transitionend.transition);
  function As(n) {
    if ($c[n])
      return $c[n];
    if (!gu[n])
      return n;
    var i = gu[n], u;
    for (u in i)
      if (i.hasOwnProperty(u) && u in ov)
        return $c[n] = i[u];
    return n;
  }
  var zr = As("animationend"), jd = As("animationiteration"), uv = As("animationstart"), sv = As("transitionend"), cv = /* @__PURE__ */ new Map(), fv = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Pl(n, i) {
    cv.set(n, i), y(i, [n]);
  }
  for (var Yc = 0; Yc < fv.length; Yc++) {
    var js = fv[Yc], Us = js.toLowerCase(), hg = js[0].toUpperCase() + js.slice(1);
    Pl(Us, "on" + hg);
  }
  Pl(zr, "onAnimationEnd"), Pl(jd, "onAnimationIteration"), Pl(uv, "onAnimationStart"), Pl("dblclick", "onDoubleClick"), Pl("focusin", "onFocus"), Pl("focusout", "onBlur"), Pl(sv, "onTransitionEnd"), S("onMouseEnter", ["mouseout", "mouseover"]), S("onMouseLeave", ["mouseout", "mouseover"]), S("onPointerEnter", ["pointerout", "pointerover"]), S("onPointerLeave", ["pointerout", "pointerover"]), y("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), y("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), y("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), y("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), y("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), y("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var al = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), vg = new Set("cancel close invalid load scroll toggle".split(" ").concat(al));
  function dv(n, i, u) {
    var d = n.type || "unknown-event";
    n.currentTarget = u, Ne(d, i, void 0, n), n.currentTarget = null;
  }
  function pv(n, i) {
    i = (i & 4) !== 0;
    for (var u = 0; u < n.length; u++) {
      var d = n[u], m = d.event;
      d = d.listeners;
      e: {
        var x = void 0;
        if (i)
          for (var _ = d.length - 1; 0 <= _; _--) {
            var z = d[_], P = z.instance, ee = z.currentTarget;
            if (z = z.listener, P !== x && m.isPropagationStopped())
              break e;
            dv(m, z, ee), x = P;
          }
        else
          for (_ = 0; _ < d.length; _++) {
            if (z = d[_], P = z.instance, ee = z.currentTarget, z = z.listener, P !== x && m.isPropagationStopped())
              break e;
            dv(m, z, ee), x = P;
          }
      }
    }
    if (Ei)
      throw n = Ga, Ei = !1, Ga = null, n;
  }
  function cn(n, i) {
    var u = i[Wd];
    u === void 0 && (u = i[Wd] = /* @__PURE__ */ new Set());
    var d = n + "__bubble";
    u.has(d) || (Ud(i, n, 2, !1), u.add(d));
  }
  function Fs(n, i, u) {
    var d = 0;
    i && (d |= 4), Ud(u, n, d, i);
  }
  var ll = "_reactListening" + Math.random().toString(36).slice(2);
  function _a(n) {
    if (!n[ll]) {
      n[ll] = !0, f.forEach(function(u) {
        u !== "selectionchange" && (vg.has(u) || Fs(u, !1, n), Fs(u, !0, n));
      });
      var i = n.nodeType === 9 ? n : n.ownerDocument;
      i === null || i[ll] || (i[ll] = !0, Fs("selectionchange", !1, i));
    }
  }
  function Ud(n, i, u, d) {
    switch (ks(i)) {
      case 1:
        var m = Za;
        break;
      case 4:
        m = du;
        break;
      default:
        m = Ra;
    }
    u = m.bind(null, i, u, n), m = void 0, !ca || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (m = !0), d ? m !== void 0 ? n.addEventListener(i, u, { capture: !0, passive: m }) : n.addEventListener(i, u, !0) : m !== void 0 ? n.addEventListener(i, u, { passive: m }) : n.addEventListener(i, u, !1);
  }
  function Fd(n, i, u, d, m) {
    var x = d;
    if (!(i & 1) && !(i & 2) && d !== null)
      e:
        for (; ; ) {
          if (d === null)
            return;
          var _ = d.tag;
          if (_ === 3 || _ === 4) {
            var z = d.stateNode.containerInfo;
            if (z === m || z.nodeType === 8 && z.parentNode === m)
              break;
            if (_ === 4)
              for (_ = d.return; _ !== null; ) {
                var P = _.tag;
                if ((P === 3 || P === 4) && (P = _.stateNode.containerInfo, P === m || P.nodeType === 8 && P.parentNode === m))
                  return;
                _ = _.return;
              }
            for (; z !== null; ) {
              if (_ = ul(z), _ === null)
                return;
              if (P = _.tag, P === 5 || P === 6) {
                d = x = _;
                continue e;
              }
              z = z.parentNode;
            }
          }
          d = d.return;
        }
    Dl(function() {
      var ee = x, ye = Nr(u), xe = [];
      e: {
        var ve = cv.get(n);
        if (ve !== void 0) {
          var Pe = vt, qe = n;
          switch (n) {
            case "keypress":
              if (K(u) === 0)
                break e;
            case "keydown":
            case "keyup":
              Pe = nl;
              break;
            case "focusin":
              qe = "focus", Pe = Rs;
              break;
            case "focusout":
              qe = "blur", Pe = Rs;
              break;
            case "beforeblur":
            case "afterblur":
              Pe = Rs;
              break;
            case "click":
              if (u.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Pe = $t;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Pe = vu;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Pe = Dd;
              break;
            case zr:
            case jd:
            case uv:
              Pe = _s;
              break;
            case sv:
              Pe = Hc;
              break;
            case "scroll":
              Pe = Zt;
              break;
            case "wheel":
              Pe = ai;
              break;
            case "copy":
            case "cut":
            case "paste":
              Pe = Td;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Pe = Pc;
          }
          var Ze = (i & 4) !== 0, Xn = !Ze && n === "scroll", W = Ze ? ve !== null ? ve + "Capture" : null : ve;
          Ze = [];
          for (var I = ee, G; I !== null; ) {
            G = I;
            var Te = G.stateNode;
            if (G.tag === 5 && Te !== null && (G = Te, W !== null && (Te = sa(I, W), Te != null && Ze.push(Su(I, Te, G)))), Xn)
              break;
            I = I.return;
          }
          0 < Ze.length && (ve = new Pe(ve, qe, null, u, ye), xe.push({ event: ve, listeners: Ze }));
        }
      }
      if (!(i & 7)) {
        e: {
          if (ve = n === "mouseover" || n === "pointerover", Pe = n === "mouseout" || n === "pointerout", ve && u !== Yt && (qe = u.relatedTarget || u.fromElement) && (ul(qe) || qe[va]))
            break e;
          if ((Pe || ve) && (ve = ye.window === ye ? ye : (ve = ye.ownerDocument) ? ve.defaultView || ve.parentWindow : window, Pe ? (qe = u.relatedTarget || u.toElement, Pe = ee, qe = qe ? ul(qe) : null, qe !== null && (Xn = je(qe), qe !== Xn || qe.tag !== 5 && qe.tag !== 6) && (qe = null)) : (Pe = null, qe = ee), Pe !== qe)) {
            if (Ze = $t, Te = "onMouseLeave", W = "onMouseEnter", I = "mouse", (n === "pointerout" || n === "pointerover") && (Ze = Pc, Te = "onPointerLeave", W = "onPointerEnter", I = "pointer"), Xn = Pe == null ? ve : xu(Pe), G = qe == null ? ve : xu(qe), ve = new Ze(Te, I + "leave", Pe, u, ye), ve.target = Xn, ve.relatedTarget = G, Te = null, ul(ye) === ee && (Ze = new Ze(W, I + "enter", qe, u, ye), Ze.target = G, Ze.relatedTarget = Xn, Te = Ze), Xn = Te, Pe && qe)
              t: {
                for (Ze = Pe, W = qe, I = 0, G = Ze; G; G = Ro(G))
                  I++;
                for (G = 0, Te = W; Te; Te = Ro(Te))
                  G++;
                for (; 0 < I - G; )
                  Ze = Ro(Ze), I--;
                for (; 0 < G - I; )
                  W = Ro(W), G--;
                for (; I--; ) {
                  if (Ze === W || W !== null && Ze === W.alternate)
                    break t;
                  Ze = Ro(Ze), W = Ro(W);
                }
                Ze = null;
              }
            else
              Ze = null;
            Pe !== null && Pd(xe, ve, Pe, Ze, !1), qe !== null && Xn !== null && Pd(xe, Xn, qe, Ze, !0);
          }
        }
        e: {
          if (ve = ee ? xu(ee) : window, Pe = ve.nodeName && ve.nodeName.toLowerCase(), Pe === "select" || Pe === "input" && ve.type === "file")
            var tt = Nd;
          else if (Md(ve))
            if (Ld)
              tt = pg;
            else {
              tt = fg;
              var pt = cg;
            }
          else
            (Pe = ve.nodeName) && Pe.toLowerCase() === "input" && (ve.type === "checkbox" || ve.type === "radio") && (tt = dg);
          if (tt && (tt = tt(n, ee))) {
            Xh(xe, tt, u, ye);
            break e;
          }
          pt && pt(n, ve, ee), n === "focusout" && (pt = ve._wrapperState) && pt.controlled && ve.type === "number" && cr(ve, "number", ve.value);
        }
        switch (pt = ee ? xu(ee) : window, n) {
          case "focusin":
            (Md(pt) || pt.contentEditable === "true") && (To = pt, Fl = ee, zs = null);
            break;
          case "focusout":
            zs = Fl = To = null;
            break;
          case "mousedown":
            Ad = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Ad = !1, lv(xe, u, ye);
            break;
          case "selectionchange":
            if (Bc)
              break;
          case "keydown":
          case "keyup":
            lv(xe, u, ye);
        }
        var Ge;
        if (Fn)
          e: {
            switch (n) {
              case "compositionstart":
                var ht = "onCompositionStart";
                break e;
              case "compositionend":
                ht = "onCompositionEnd";
                break e;
              case "compositionupdate":
                ht = "onCompositionUpdate";
                break e;
            }
            ht = void 0;
          }
        else
          Ul ? qh(n, u) && (ht = "onCompositionEnd") : n === "keydown" && u.keyCode === 229 && (ht = "onCompositionStart");
        ht && (Os && u.locale !== "ko" && (Ul || ht !== "onCompositionStart" ? ht === "onCompositionEnd" && Ul && (Ge = j()) : (pa = ye, hu = "value" in pa ? pa.value : pa.textContent, Ul = !0)), pt = Wc(ee, ht), 0 < pt.length && (ht = new Bh(ht, n, null, u, ye), xe.push({ event: ht, listeners: pt }), Ge ? ht.data = Ge : (Ge = Gh(u), Ge !== null && (ht.data = Ge)))), (Ge = Od ? og(n, u) : ug(n, u)) && (ee = Wc(ee, "onBeforeInput"), 0 < ee.length && (ye = new Bh("onBeforeInput", "beforeinput", null, u, ye), xe.push({ event: ye, listeners: ee }), ye.data = Ge));
      }
      pv(xe, i);
    });
  }
  function Su(n, i, u) {
    return { instance: n, listener: i, currentTarget: u };
  }
  function Wc(n, i) {
    for (var u = i + "Capture", d = []; n !== null; ) {
      var m = n, x = m.stateNode;
      m.tag === 5 && x !== null && (m = x, x = sa(n, u), x != null && d.unshift(Su(n, x, m)), x = sa(n, i), x != null && d.push(Su(n, x, m))), n = n.return;
    }
    return d;
  }
  function Ro(n) {
    if (n === null)
      return null;
    do
      n = n.return;
    while (n && n.tag !== 5);
    return n || null;
  }
  function Pd(n, i, u, d, m) {
    for (var x = i._reactName, _ = []; u !== null && u !== d; ) {
      var z = u, P = z.alternate, ee = z.stateNode;
      if (P !== null && P === d)
        break;
      z.tag === 5 && ee !== null && (z = ee, m ? (P = sa(u, x), P != null && _.unshift(Su(u, P, z))) : m || (P = sa(u, x), P != null && _.push(Su(u, P, z)))), u = u.return;
    }
    _.length !== 0 && n.push({ event: i, listeners: _ });
  }
  var hv = /\r\n?/g, Hd = /\u0000|\uFFFD/g;
  function vv(n) {
    return (typeof n == "string" ? n : "" + n).replace(hv, `
`).replace(Hd, "");
  }
  function Ps(n, i, u) {
    if (i = vv(i), vv(n) !== i && u)
      throw Error(s(425));
  }
  function Qc() {
  }
  var Id = null, Bd = null;
  function _o(n, i) {
    return n === "textarea" || n === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var Hs = typeof setTimeout == "function" ? setTimeout : void 0, Is = typeof clearTimeout == "function" ? clearTimeout : void 0, Vd = typeof Promise == "function" ? Promise : void 0, mv = typeof queueMicrotask == "function" ? queueMicrotask : typeof Vd < "u" ? function(n) {
    return Vd.resolve(null).then(n).catch($d);
  } : Hs;
  function $d(n) {
    setTimeout(function() {
      throw n;
    });
  }
  function Yd(n, i) {
    var u = i, d = 0;
    do {
      var m = u.nextSibling;
      if (n.removeChild(u), m && m.nodeType === 8)
        if (u = m.data, u === "/$") {
          if (d === 0) {
            n.removeChild(m), Pi(i);
            return;
          }
          d--;
        } else
          u !== "$" && u !== "$?" && u !== "$!" || d++;
      u = m;
    } while (u);
    Pi(i);
  }
  function wi(n) {
    for (; n != null; n = n.nextSibling) {
      var i = n.nodeType;
      if (i === 1 || i === 3)
        break;
      if (i === 8) {
        if (i = n.data, i === "$" || i === "$!" || i === "$?")
          break;
        if (i === "/$")
          return null;
      }
    }
    return n;
  }
  function Bs(n) {
    n = n.previousSibling;
    for (var i = 0; n; ) {
      if (n.nodeType === 8) {
        var u = n.data;
        if (u === "$" || u === "$!" || u === "$?") {
          if (i === 0)
            return n;
          i--;
        } else
          u === "/$" && i++;
      }
      n = n.previousSibling;
    }
    return null;
  }
  var ol = Math.random().toString(36).slice(2), Hi = "__reactFiber$" + ol, Vs = "__reactProps$" + ol, va = "__reactContainer$" + ol, Wd = "__reactEvents$" + ol, mg = "__reactListeners$" + ol, yg = "__reactHandles$" + ol;
  function ul(n) {
    var i = n[Hi];
    if (i)
      return i;
    for (var u = n.parentNode; u; ) {
      if (i = u[va] || u[Hi]) {
        if (u = i.alternate, i.child !== null || u !== null && u.child !== null)
          for (n = Bs(n); n !== null; ) {
            if (u = n[Hi])
              return u;
            n = Bs(n);
          }
        return i;
      }
      n = u, u = n.parentNode;
    }
    return null;
  }
  function Da(n) {
    return n = n[Hi] || n[va], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n;
  }
  function xu(n) {
    if (n.tag === 5 || n.tag === 6)
      return n.stateNode;
    throw Error(s(33));
  }
  function qc(n) {
    return n[Vs] || null;
  }
  var st = [], ma = -1;
  function fn(n) {
    return { current: n };
  }
  function et(n) {
    0 > ma || (n.current = st[ma], st[ma] = null, ma--);
  }
  function qt(n, i) {
    ma++, st[ma] = n.current, n.current = i;
  }
  var Ii = {}, pr = fn(Ii), Ct = fn(!1), Br = Ii;
  function ki(n, i) {
    var u = n.type.contextTypes;
    if (!u)
      return Ii;
    var d = n.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === i)
      return d.__reactInternalMemoizedMaskedChildContext;
    var m = {}, x;
    for (x in u)
      m[x] = i[x];
    return d && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = i, n.__reactInternalMemoizedMaskedChildContext = m), m;
  }
  function er(n) {
    return n = n.childContextTypes, n != null;
  }
  function li() {
    et(Ct), et(pr);
  }
  function Oa(n, i, u) {
    if (pr.current !== Ii)
      throw Error(s(168));
    qt(pr, i), qt(Ct, u);
  }
  function Hl(n, i, u) {
    var d = n.stateNode;
    if (i = i.childContextTypes, typeof d.getChildContext != "function")
      return u;
    d = d.getChildContext();
    for (var m in d)
      if (!(m in i))
        throw Error(s(108, _t(n) || "Unknown", m));
    return T({}, u, d);
  }
  function Do(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || Ii, Br = pr.current, qt(pr, n), qt(Ct, Ct.current), !0;
  }
  function yv(n, i, u) {
    var d = n.stateNode;
    if (!d)
      throw Error(s(169));
    u ? (n = Hl(n, i, Br), d.__reactInternalMemoizedMergedChildContext = n, et(Ct), et(pr), qt(pr, n)) : et(Ct), qt(Ct, u);
  }
  var sl = null, Il = !1, xr = !1;
  function Gc(n) {
    sl === null ? sl = [n] : sl.push(n);
  }
  function gv(n) {
    Il = !0, Gc(n);
  }
  function Ma() {
    if (!xr && sl !== null) {
      xr = !0;
      var n = 0, i = Ft;
      try {
        var u = sl;
        for (Ft = 1; n < u.length; n++) {
          var d = u[n];
          do
            d = d(!0);
          while (d !== null);
        }
        sl = null, Il = !1;
      } catch (m) {
        throw sl !== null && (sl = sl.slice(n + 1)), pn(vs, Ma), m;
      } finally {
        Ft = i, xr = !1;
      }
    }
    return null;
  }
  var Bi = [], Bl = 0, Vi = null, Oo = 0, oi = [], ui = 0, ya = null, si = 1, br = "";
  function Mo(n, i) {
    Bi[Bl++] = Oo, Bi[Bl++] = Vi, Vi = n, Oo = i;
  }
  function Vl(n, i, u) {
    oi[ui++] = si, oi[ui++] = br, oi[ui++] = ya, ya = n;
    var d = si;
    n = br;
    var m = 32 - Ir(d) - 1;
    d &= ~(1 << m), u += 1;
    var x = 32 - Ir(i) + m;
    if (30 < x) {
      var _ = m - m % 5;
      x = (d & (1 << _) - 1).toString(32), d >>= _, m -= _, si = 1 << 32 - Ir(i) + m | u << m | d, br = x + n;
    } else
      si = 1 << x | u << m | d, br = n;
  }
  function Xc(n) {
    n.return !== null && (Mo(n, 1), Vl(n, 1, 0));
  }
  function Kc(n) {
    for (; n === Vi; )
      Vi = Bi[--Bl], Bi[Bl] = null, Oo = Bi[--Bl], Bi[Bl] = null;
    for (; n === ya; )
      ya = oi[--ui], oi[ui] = null, br = oi[--ui], oi[ui] = null, si = oi[--ui], oi[ui] = null;
  }
  var Ti = null, Ri = null, bn = !1, $i = null;
  function Qd(n, i) {
    var u = Ki(5, null, null, 0);
    u.elementType = "DELETED", u.stateNode = i, u.return = n, i = n.deletions, i === null ? (n.deletions = [u], n.flags |= 16) : i.push(u);
  }
  function qd(n, i) {
    switch (n.tag) {
      case 5:
        var u = n.type;
        return i = i.nodeType !== 1 || u.toLowerCase() !== i.nodeName.toLowerCase() ? null : i, i !== null ? (n.stateNode = i, Ti = n, Ri = wi(i.firstChild), !0) : !1;
      case 6:
        return i = n.pendingProps === "" || i.nodeType !== 3 ? null : i, i !== null ? (n.stateNode = i, Ti = n, Ri = null, !0) : !1;
      case 13:
        return i = i.nodeType !== 8 ? null : i, i !== null ? (u = ya !== null ? { id: si, overflow: br } : null, n.memoizedState = { dehydrated: i, treeContext: u, retryLane: 1073741824 }, u = Ki(18, null, null, 0), u.stateNode = i, u.return = n, n.child = u, Ti = n, Ri = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Gd(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
  }
  function Jc(n) {
    if (bn) {
      var i = Ri;
      if (i) {
        var u = i;
        if (!qd(n, i)) {
          if (Gd(n))
            throw Error(s(418));
          i = wi(u.nextSibling);
          var d = Ti;
          i && qd(n, i) ? Qd(d, u) : (n.flags = n.flags & -4097 | 2, bn = !1, Ti = n);
        }
      } else {
        if (Gd(n))
          throw Error(s(418));
        n.flags = n.flags & -4097 | 2, bn = !1, Ti = n;
      }
    }
  }
  function Xd(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
      n = n.return;
    Ti = n;
  }
  function Zc(n) {
    if (n !== Ti)
      return !1;
    if (!bn)
      return Xd(n), bn = !0, !1;
    var i;
    if ((i = n.tag !== 3) && !(i = n.tag !== 5) && (i = n.type, i = i !== "head" && i !== "body" && !_o(n.type, n.memoizedProps)), i && (i = Ri)) {
      if (Gd(n))
        throw Sv(), Error(s(418));
      for (; i; )
        Qd(n, i), i = wi(i.nextSibling);
    }
    if (Xd(n), n.tag === 13) {
      if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n)
        throw Error(s(317));
      e: {
        for (n = n.nextSibling, i = 0; n; ) {
          if (n.nodeType === 8) {
            var u = n.data;
            if (u === "/$") {
              if (i === 0) {
                Ri = wi(n.nextSibling);
                break e;
              }
              i--;
            } else
              u !== "$" && u !== "$!" && u !== "$?" || i++;
          }
          n = n.nextSibling;
        }
        Ri = null;
      }
    } else
      Ri = Ti ? wi(n.stateNode.nextSibling) : null;
    return !0;
  }
  function Sv() {
    for (var n = Ri; n; )
      n = wi(n.nextSibling);
  }
  function bu() {
    Ri = Ti = null, bn = !1;
  }
  function tr(n) {
    $i === null ? $i = [n] : $i.push(n);
  }
  var gg = Se.ReactCurrentBatchConfig;
  function ci(n, i) {
    if (n && n.defaultProps) {
      i = T({}, i), n = n.defaultProps;
      for (var u in n)
        i[u] === void 0 && (i[u] = n[u]);
      return i;
    }
    return i;
  }
  var Eu = fn(null), Na = null, Cu = null, $s = null;
  function Kd() {
    $s = Cu = Na = null;
  }
  function Jd(n) {
    var i = Eu.current;
    et(Eu), n._currentValue = i;
  }
  function $l(n, i, u) {
    for (; n !== null; ) {
      var d = n.alternate;
      if ((n.childLanes & i) !== i ? (n.childLanes |= i, d !== null && (d.childLanes |= i)) : d !== null && (d.childLanes & i) !== i && (d.childLanes |= i), n === u)
        break;
      n = n.return;
    }
  }
  function Yn(n, i) {
    Na = n, $s = Cu = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & i && (pi = !0), n.firstContext = null);
  }
  function Me(n) {
    var i = n._currentValue;
    if ($s !== n)
      if (n = { context: n, memoizedValue: i, next: null }, Cu === null) {
        if (Na === null)
          throw Error(s(308));
        Cu = n, Na.dependencies = { lanes: 0, firstContext: n };
      } else
        Cu = Cu.next = n;
    return i;
  }
  var Ar = null;
  function _i(n) {
    Ar === null ? Ar = [n] : Ar.push(n);
  }
  function xv(n, i, u, d) {
    var m = i.interleaved;
    return m === null ? (u.next = u, _i(i)) : (u.next = m.next, m.next = u), i.interleaved = u, cl(n, d);
  }
  function cl(n, i) {
    n.lanes |= i;
    var u = n.alternate;
    for (u !== null && (u.lanes |= i), u = n, n = n.return; n !== null; )
      n.childLanes |= i, u = n.alternate, u !== null && (u.childLanes |= i), u = n, n = n.return;
    return u.tag === 3 ? u.stateNode : null;
  }
  var Yl = !1;
  function Zd(n) {
    n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function bv(n, i) {
    n = n.updateQueue, i.updateQueue === n && (i.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects });
  }
  function mn(n, i) {
    return { eventTime: n, lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function Wl(n, i, u) {
    var d = n.updateQueue;
    if (d === null)
      return null;
    if (d = d.shared, At & 2) {
      var m = d.pending;
      return m === null ? i.next = i : (i.next = m.next, m.next = i), d.pending = i, cl(n, u);
    }
    return m = d.interleaved, m === null ? (i.next = i, _i(d)) : (i.next = m.next, m.next = i), d.interleaved = i, cl(n, u);
  }
  function ef(n, i, u) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (u & 4194240) !== 0)) {
      var d = i.lanes;
      d &= n.pendingLanes, u |= d, i.lanes = u, bs(n, u);
    }
  }
  function Ev(n, i) {
    var u = n.updateQueue, d = n.alternate;
    if (d !== null && (d = d.updateQueue, u === d)) {
      var m = null, x = null;
      if (u = u.firstBaseUpdate, u !== null) {
        do {
          var _ = { eventTime: u.eventTime, lane: u.lane, tag: u.tag, payload: u.payload, callback: u.callback, next: null };
          x === null ? m = x = _ : x = x.next = _, u = u.next;
        } while (u !== null);
        x === null ? m = x = i : x = x.next = i;
      } else
        m = x = i;
      u = { baseState: d.baseState, firstBaseUpdate: m, lastBaseUpdate: x, shared: d.shared, effects: d.effects }, n.updateQueue = u;
      return;
    }
    n = u.lastBaseUpdate, n === null ? u.firstBaseUpdate = i : n.next = i, u.lastBaseUpdate = i;
  }
  function Ys(n, i, u, d) {
    var m = n.updateQueue;
    Yl = !1;
    var x = m.firstBaseUpdate, _ = m.lastBaseUpdate, z = m.shared.pending;
    if (z !== null) {
      m.shared.pending = null;
      var P = z, ee = P.next;
      P.next = null, _ === null ? x = ee : _.next = ee, _ = P;
      var ye = n.alternate;
      ye !== null && (ye = ye.updateQueue, z = ye.lastBaseUpdate, z !== _ && (z === null ? ye.firstBaseUpdate = ee : z.next = ee, ye.lastBaseUpdate = P));
    }
    if (x !== null) {
      var xe = m.baseState;
      _ = 0, ye = ee = P = null, z = x;
      do {
        var ve = z.lane, Pe = z.eventTime;
        if ((d & ve) === ve) {
          ye !== null && (ye = ye.next = {
            eventTime: Pe,
            lane: 0,
            tag: z.tag,
            payload: z.payload,
            callback: z.callback,
            next: null
          });
          e: {
            var qe = n, Ze = z;
            switch (ve = i, Pe = u, Ze.tag) {
              case 1:
                if (qe = Ze.payload, typeof qe == "function") {
                  xe = qe.call(Pe, xe, ve);
                  break e;
                }
                xe = qe;
                break e;
              case 3:
                qe.flags = qe.flags & -65537 | 128;
              case 0:
                if (qe = Ze.payload, ve = typeof qe == "function" ? qe.call(Pe, xe, ve) : qe, ve == null)
                  break e;
                xe = T({}, xe, ve);
                break e;
              case 2:
                Yl = !0;
            }
          }
          z.callback !== null && z.lane !== 0 && (n.flags |= 64, ve = m.effects, ve === null ? m.effects = [z] : ve.push(z));
        } else
          Pe = { eventTime: Pe, lane: ve, tag: z.tag, payload: z.payload, callback: z.callback, next: null }, ye === null ? (ee = ye = Pe, P = xe) : ye = ye.next = Pe, _ |= ve;
        if (z = z.next, z === null) {
          if (z = m.shared.pending, z === null)
            break;
          ve = z, z = ve.next, ve.next = null, m.lastBaseUpdate = ve, m.shared.pending = null;
        }
      } while (!0);
      if (ye === null && (P = xe), m.baseState = P, m.firstBaseUpdate = ee, m.lastBaseUpdate = ye, i = m.shared.interleaved, i !== null) {
        m = i;
        do
          _ |= m.lane, m = m.next;
        while (m !== i);
      } else
        x === null && (m.shared.lanes = 0);
      Vo |= _, n.lanes = _, n.memoizedState = xe;
    }
  }
  function wu(n, i, u) {
    if (n = i.effects, i.effects = null, n !== null)
      for (i = 0; i < n.length; i++) {
        var d = n[i], m = d.callback;
        if (m !== null) {
          if (d.callback = null, d = u, typeof m != "function")
            throw Error(s(191, m));
          m.call(d);
        }
      }
  }
  var No = new r.Component().refs;
  function ep(n, i, u, d) {
    i = n.memoizedState, u = u(d, i), u = u == null ? i : T({}, i, u), n.memoizedState = u, n.lanes === 0 && (n.updateQueue.baseState = u);
  }
  var tf = { isMounted: function(n) {
    return (n = n._reactInternals) ? je(n) === n : !1;
  }, enqueueSetState: function(n, i, u) {
    n = n._reactInternals;
    var d = mr(), m = hl(n), x = mn(d, m);
    x.payload = i, u != null && (x.callback = u), i = Wl(n, x, m), i !== null && (Ln(i, n, m, d), ef(i, n, m));
  }, enqueueReplaceState: function(n, i, u) {
    n = n._reactInternals;
    var d = mr(), m = hl(n), x = mn(d, m);
    x.tag = 1, x.payload = i, u != null && (x.callback = u), i = Wl(n, x, m), i !== null && (Ln(i, n, m, d), ef(i, n, m));
  }, enqueueForceUpdate: function(n, i) {
    n = n._reactInternals;
    var u = mr(), d = hl(n), m = mn(u, d);
    m.tag = 2, i != null && (m.callback = i), i = Wl(n, m, d), i !== null && (Ln(i, n, d, u), ef(i, n, d));
  } };
  function Cv(n, i, u, d, m, x, _) {
    return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(d, x, _) : i.prototype && i.prototype.isPureReactComponent ? !yu(u, d) || !yu(m, x) : !0;
  }
  function wv(n, i, u) {
    var d = !1, m = Ii, x = i.contextType;
    return typeof x == "object" && x !== null ? x = Me(x) : (m = er(i) ? Br : pr.current, d = i.contextTypes, x = (d = d != null) ? ki(n, m) : Ii), i = new i(u, x), n.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, i.updater = tf, n.stateNode = i, i._reactInternals = n, d && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = m, n.__reactInternalMemoizedMaskedChildContext = x), i;
  }
  function kv(n, i, u, d) {
    n = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(u, d), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(u, d), i.state !== n && tf.enqueueReplaceState(i, i.state, null);
  }
  function tp(n, i, u, d) {
    var m = n.stateNode;
    m.props = u, m.state = n.memoizedState, m.refs = No, Zd(n);
    var x = i.contextType;
    typeof x == "object" && x !== null ? m.context = Me(x) : (x = er(i) ? Br : pr.current, m.context = ki(n, x)), m.state = n.memoizedState, x = i.getDerivedStateFromProps, typeof x == "function" && (ep(n, i, x, u), m.state = n.memoizedState), typeof i.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function" || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (i = m.state, typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), i !== m.state && tf.enqueueReplaceState(m, m.state, null), Ys(n, u, m, d), m.state = n.memoizedState), typeof m.componentDidMount == "function" && (n.flags |= 4194308);
  }
  function ku(n, i, u) {
    if (n = u.ref, n !== null && typeof n != "function" && typeof n != "object") {
      if (u._owner) {
        if (u = u._owner, u) {
          if (u.tag !== 1)
            throw Error(s(309));
          var d = u.stateNode;
        }
        if (!d)
          throw Error(s(147, n));
        var m = d, x = "" + n;
        return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === x ? i.ref : (i = function(_) {
          var z = m.refs;
          z === No && (z = m.refs = {}), _ === null ? delete z[x] : z[x] = _;
        }, i._stringRef = x, i);
      }
      if (typeof n != "string")
        throw Error(s(284));
      if (!u._owner)
        throw Error(s(290, n));
    }
    return n;
  }
  function Ws(n, i) {
    throw n = Object.prototype.toString.call(i), Error(s(31, n === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : n));
  }
  function Tv(n) {
    var i = n._init;
    return i(n._payload);
  }
  function Rv(n) {
    function i(W, I) {
      if (n) {
        var G = W.deletions;
        G === null ? (W.deletions = [I], W.flags |= 16) : G.push(I);
      }
    }
    function u(W, I) {
      if (!n)
        return null;
      for (; I !== null; )
        i(W, I), I = I.sibling;
      return null;
    }
    function d(W, I) {
      for (W = /* @__PURE__ */ new Map(); I !== null; )
        I.key !== null ? W.set(I.key, I) : W.set(I.index, I), I = I.sibling;
      return W;
    }
    function m(W, I) {
      return W = eo(W, I), W.index = 0, W.sibling = null, W;
    }
    function x(W, I, G) {
      return W.index = G, n ? (G = W.alternate, G !== null ? (G = G.index, G < I ? (W.flags |= 2, I) : G) : (W.flags |= 2, I)) : (W.flags |= 1048576, I);
    }
    function _(W) {
      return n && W.alternate === null && (W.flags |= 2), W;
    }
    function z(W, I, G, Te) {
      return I === null || I.tag !== 6 ? (I = Uf(G, W.mode, Te), I.return = W, I) : (I = m(I, G), I.return = W, I);
    }
    function P(W, I, G, Te) {
      var tt = G.type;
      return tt === Oe ? ye(W, I, G.props.children, Te, G.key) : I !== null && (I.elementType === tt || typeof tt == "object" && tt !== null && tt.$$typeof === Qe && Tv(tt) === I.type) ? (Te = m(I, G.props), Te.ref = ku(W, I, G), Te.return = W, Te) : (Te = Af(G.type, G.key, G.props, null, W.mode, Te), Te.ref = ku(W, I, G), Te.return = W, Te);
    }
    function ee(W, I, G, Te) {
      return I === null || I.tag !== 4 || I.stateNode.containerInfo !== G.containerInfo || I.stateNode.implementation !== G.implementation ? (I = fc(G, W.mode, Te), I.return = W, I) : (I = m(I, G.children || []), I.return = W, I);
    }
    function ye(W, I, G, Te, tt) {
      return I === null || I.tag !== 7 ? (I = Qo(G, W.mode, Te, tt), I.return = W, I) : (I = m(I, G), I.return = W, I);
    }
    function xe(W, I, G) {
      if (typeof I == "string" && I !== "" || typeof I == "number")
        return I = Uf("" + I, W.mode, G), I.return = W, I;
      if (typeof I == "object" && I !== null) {
        switch (I.$$typeof) {
          case Ce:
            return G = Af(I.type, I.key, I.props, null, W.mode, G), G.ref = ku(W, null, I), G.return = W, G;
          case Y:
            return I = fc(I, W.mode, G), I.return = W, I;
          case Qe:
            var Te = I._init;
            return xe(W, Te(I._payload), G);
        }
        if (rr(I) || _e(I))
          return I = Qo(I, W.mode, G, null), I.return = W, I;
        Ws(W, I);
      }
      return null;
    }
    function ve(W, I, G, Te) {
      var tt = I !== null ? I.key : null;
      if (typeof G == "string" && G !== "" || typeof G == "number")
        return tt !== null ? null : z(W, I, "" + G, Te);
      if (typeof G == "object" && G !== null) {
        switch (G.$$typeof) {
          case Ce:
            return G.key === tt ? P(W, I, G, Te) : null;
          case Y:
            return G.key === tt ? ee(W, I, G, Te) : null;
          case Qe:
            return tt = G._init, ve(
              W,
              I,
              tt(G._payload),
              Te
            );
        }
        if (rr(G) || _e(G))
          return tt !== null ? null : ye(W, I, G, Te, null);
        Ws(W, G);
      }
      return null;
    }
    function Pe(W, I, G, Te, tt) {
      if (typeof Te == "string" && Te !== "" || typeof Te == "number")
        return W = W.get(G) || null, z(I, W, "" + Te, tt);
      if (typeof Te == "object" && Te !== null) {
        switch (Te.$$typeof) {
          case Ce:
            return W = W.get(Te.key === null ? G : Te.key) || null, P(I, W, Te, tt);
          case Y:
            return W = W.get(Te.key === null ? G : Te.key) || null, ee(I, W, Te, tt);
          case Qe:
            var pt = Te._init;
            return Pe(W, I, G, pt(Te._payload), tt);
        }
        if (rr(Te) || _e(Te))
          return W = W.get(G) || null, ye(I, W, Te, tt, null);
        Ws(I, Te);
      }
      return null;
    }
    function qe(W, I, G, Te) {
      for (var tt = null, pt = null, Ge = I, ht = I = 0, or = null; Ge !== null && ht < G.length; ht++) {
        Ge.index > ht ? (or = Ge, Ge = null) : or = Ge.sibling;
        var Gt = ve(W, Ge, G[ht], Te);
        if (Gt === null) {
          Ge === null && (Ge = or);
          break;
        }
        n && Ge && Gt.alternate === null && i(W, Ge), I = x(Gt, I, ht), pt === null ? tt = Gt : pt.sibling = Gt, pt = Gt, Ge = or;
      }
      if (ht === G.length)
        return u(W, Ge), bn && Mo(W, ht), tt;
      if (Ge === null) {
        for (; ht < G.length; ht++)
          Ge = xe(W, G[ht], Te), Ge !== null && (I = x(Ge, I, ht), pt === null ? tt = Ge : pt.sibling = Ge, pt = Ge);
        return bn && Mo(W, ht), tt;
      }
      for (Ge = d(W, Ge); ht < G.length; ht++)
        or = Pe(Ge, W, ht, G[ht], Te), or !== null && (n && or.alternate !== null && Ge.delete(or.key === null ? ht : or.key), I = x(or, I, ht), pt === null ? tt = or : pt.sibling = or, pt = or);
      return n && Ge.forEach(function(vl) {
        return i(W, vl);
      }), bn && Mo(W, ht), tt;
    }
    function Ze(W, I, G, Te) {
      var tt = _e(G);
      if (typeof tt != "function")
        throw Error(s(150));
      if (G = tt.call(G), G == null)
        throw Error(s(151));
      for (var pt = tt = null, Ge = I, ht = I = 0, or = null, Gt = G.next(); Ge !== null && !Gt.done; ht++, Gt = G.next()) {
        Ge.index > ht ? (or = Ge, Ge = null) : or = Ge.sibling;
        var vl = ve(W, Ge, Gt.value, Te);
        if (vl === null) {
          Ge === null && (Ge = or);
          break;
        }
        n && Ge && vl.alternate === null && i(W, Ge), I = x(vl, I, ht), pt === null ? tt = vl : pt.sibling = vl, pt = vl, Ge = or;
      }
      if (Gt.done)
        return u(
          W,
          Ge
        ), bn && Mo(W, ht), tt;
      if (Ge === null) {
        for (; !Gt.done; ht++, Gt = G.next())
          Gt = xe(W, Gt.value, Te), Gt !== null && (I = x(Gt, I, ht), pt === null ? tt = Gt : pt.sibling = Gt, pt = Gt);
        return bn && Mo(W, ht), tt;
      }
      for (Ge = d(W, Ge); !Gt.done; ht++, Gt = G.next())
        Gt = Pe(Ge, W, ht, Gt.value, Te), Gt !== null && (n && Gt.alternate !== null && Ge.delete(Gt.key === null ? ht : Gt.key), I = x(Gt, I, ht), pt === null ? tt = Gt : pt.sibling = Gt, pt = Gt);
      return n && Ge.forEach(function(Ug) {
        return i(W, Ug);
      }), bn && Mo(W, ht), tt;
    }
    function Xn(W, I, G, Te) {
      if (typeof G == "object" && G !== null && G.type === Oe && G.key === null && (G = G.props.children), typeof G == "object" && G !== null) {
        switch (G.$$typeof) {
          case Ce:
            e: {
              for (var tt = G.key, pt = I; pt !== null; ) {
                if (pt.key === tt) {
                  if (tt = G.type, tt === Oe) {
                    if (pt.tag === 7) {
                      u(W, pt.sibling), I = m(pt, G.props.children), I.return = W, W = I;
                      break e;
                    }
                  } else if (pt.elementType === tt || typeof tt == "object" && tt !== null && tt.$$typeof === Qe && Tv(tt) === pt.type) {
                    u(W, pt.sibling), I = m(pt, G.props), I.ref = ku(W, pt, G), I.return = W, W = I;
                    break e;
                  }
                  u(W, pt);
                  break;
                } else
                  i(W, pt);
                pt = pt.sibling;
              }
              G.type === Oe ? (I = Qo(G.props.children, W.mode, Te, G.key), I.return = W, W = I) : (Te = Af(G.type, G.key, G.props, null, W.mode, Te), Te.ref = ku(W, I, G), Te.return = W, W = Te);
            }
            return _(W);
          case Y:
            e: {
              for (pt = G.key; I !== null; ) {
                if (I.key === pt)
                  if (I.tag === 4 && I.stateNode.containerInfo === G.containerInfo && I.stateNode.implementation === G.implementation) {
                    u(W, I.sibling), I = m(I, G.children || []), I.return = W, W = I;
                    break e;
                  } else {
                    u(W, I);
                    break;
                  }
                else
                  i(W, I);
                I = I.sibling;
              }
              I = fc(G, W.mode, Te), I.return = W, W = I;
            }
            return _(W);
          case Qe:
            return pt = G._init, Xn(W, I, pt(G._payload), Te);
        }
        if (rr(G))
          return qe(W, I, G, Te);
        if (_e(G))
          return Ze(W, I, G, Te);
        Ws(W, G);
      }
      return typeof G == "string" && G !== "" || typeof G == "number" ? (G = "" + G, I !== null && I.tag === 6 ? (u(W, I.sibling), I = m(I, G), I.return = W, W = I) : (u(W, I), I = Uf(G, W.mode, Te), I.return = W, W = I), _(W)) : u(W, I);
    }
    return Xn;
  }
  var Tu = Rv(!0), _v = Rv(!1), Qs = {}, La = fn(Qs), Ru = fn(Qs), qs = fn(Qs);
  function Ql(n) {
    if (n === Qs)
      throw Error(s(174));
    return n;
  }
  function np(n, i) {
    switch (qt(qs, i), qt(Ru, n), qt(La, Qs), n = i.nodeType, n) {
      case 9:
      case 11:
        i = (i = i.documentElement) ? i.namespaceURI : Ee(null, "");
        break;
      default:
        n = n === 8 ? i.parentNode : i, i = n.namespaceURI || null, n = n.tagName, i = Ee(i, n);
    }
    et(La), qt(La, i);
  }
  function _u() {
    et(La), et(Ru), et(qs);
  }
  function nf(n) {
    Ql(qs.current);
    var i = Ql(La.current), u = Ee(i, n.type);
    i !== u && (qt(Ru, n), qt(La, u));
  }
  function ct(n) {
    Ru.current === n && (et(La), et(Ru));
  }
  var nt = fn(0);
  function Wt(n) {
    for (var i = n; i !== null; ) {
      if (i.tag === 13) {
        var u = i.memoizedState;
        if (u !== null && (u = u.dehydrated, u === null || u.data === "$?" || u.data === "$!"))
          return i;
      } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
        if (i.flags & 128)
          return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === n)
        break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === n)
          return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var Pn = [];
  function Yi() {
    for (var n = 0; n < Pn.length; n++)
      Pn[n]._workInProgressVersionPrimary = null;
    Pn.length = 0;
  }
  var Gs = Se.ReactCurrentDispatcher, rp = Se.ReactCurrentBatchConfig, Lo = 0, Nn = null, Wn = null, fe = null, Qn = !1, dt = !1, za = 0, fl = 0;
  function Hn() {
    throw Error(s(321));
  }
  function Wi(n, i) {
    if (i === null)
      return !1;
    for (var u = 0; u < i.length && u < n.length; u++)
      if (!ha(n[u], i[u]))
        return !1;
    return !0;
  }
  function zo(n, i, u, d, m, x) {
    if (Lo = x, Nn = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, Gs.current = n === null || n.memoizedState === null ? Sg : xg, n = u(d, m), dt) {
      x = 0;
      do {
        if (dt = !1, za = 0, 25 <= x)
          throw Error(s(301));
        x += 1, fe = Wn = null, i.updateQueue = null, Gs.current = bg, n = u(d, m);
      } while (dt);
    }
    if (Gs.current = yf, i = Wn !== null && Wn.next !== null, Lo = 0, fe = Wn = Nn = null, Qn = !1, i)
      throw Error(s(300));
    return n;
  }
  function ql() {
    var n = za !== 0;
    return za = 0, n;
  }
  function fi() {
    var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return fe === null ? Nn.memoizedState = fe = n : fe = fe.next = n, fe;
  }
  function di() {
    if (Wn === null) {
      var n = Nn.alternate;
      n = n !== null ? n.memoizedState : null;
    } else
      n = Wn.next;
    var i = fe === null ? Nn.memoizedState : fe.next;
    if (i !== null)
      fe = i, Wn = n;
    else {
      if (n === null)
        throw Error(s(310));
      Wn = n, n = { memoizedState: Wn.memoizedState, baseState: Wn.baseState, baseQueue: Wn.baseQueue, queue: Wn.queue, next: null }, fe === null ? Nn.memoizedState = fe = n : fe = fe.next = n;
    }
    return fe;
  }
  function Ao(n, i) {
    return typeof i == "function" ? i(n) : i;
  }
  function Xs(n) {
    var i = di(), u = i.queue;
    if (u === null)
      throw Error(s(311));
    u.lastRenderedReducer = n;
    var d = Wn, m = d.baseQueue, x = u.pending;
    if (x !== null) {
      if (m !== null) {
        var _ = m.next;
        m.next = x.next, x.next = _;
      }
      d.baseQueue = m = x, u.pending = null;
    }
    if (m !== null) {
      x = m.next, d = d.baseState;
      var z = _ = null, P = null, ee = x;
      do {
        var ye = ee.lane;
        if ((Lo & ye) === ye)
          P !== null && (P = P.next = { lane: 0, action: ee.action, hasEagerState: ee.hasEagerState, eagerState: ee.eagerState, next: null }), d = ee.hasEagerState ? ee.eagerState : n(d, ee.action);
        else {
          var xe = {
            lane: ye,
            action: ee.action,
            hasEagerState: ee.hasEagerState,
            eagerState: ee.eagerState,
            next: null
          };
          P === null ? (z = P = xe, _ = d) : P = P.next = xe, Nn.lanes |= ye, Vo |= ye;
        }
        ee = ee.next;
      } while (ee !== null && ee !== x);
      P === null ? _ = d : P.next = z, ha(d, i.memoizedState) || (pi = !0), i.memoizedState = d, i.baseState = _, i.baseQueue = P, u.lastRenderedState = d;
    }
    if (n = u.interleaved, n !== null) {
      m = n;
      do
        x = m.lane, Nn.lanes |= x, Vo |= x, m = m.next;
      while (m !== n);
    } else
      m === null && (u.lanes = 0);
    return [i.memoizedState, u.dispatch];
  }
  function Ks(n) {
    var i = di(), u = i.queue;
    if (u === null)
      throw Error(s(311));
    u.lastRenderedReducer = n;
    var d = u.dispatch, m = u.pending, x = i.memoizedState;
    if (m !== null) {
      u.pending = null;
      var _ = m = m.next;
      do
        x = n(x, _.action), _ = _.next;
      while (_ !== m);
      ha(x, i.memoizedState) || (pi = !0), i.memoizedState = x, i.baseQueue === null && (i.baseState = x), u.lastRenderedState = x;
    }
    return [x, d];
  }
  function rf() {
  }
  function af(n, i) {
    var u = Nn, d = di(), m = i(), x = !ha(d.memoizedState, m);
    if (x && (d.memoizedState = m, pi = !0), d = d.queue, Js(uf.bind(null, u, d, n), [n]), d.getSnapshot !== i || x || fe !== null && fe.memoizedState.tag & 1) {
      if (u.flags |= 2048, jo(9, of.bind(null, u, d, m, i), void 0, null), Bn === null)
        throw Error(s(349));
      Lo & 30 || lf(u, i, m);
    }
    return m;
  }
  function lf(n, i, u) {
    n.flags |= 16384, n = { getSnapshot: i, value: u }, i = Nn.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, Nn.updateQueue = i, i.stores = [n]) : (u = i.stores, u === null ? i.stores = [n] : u.push(n));
  }
  function of(n, i, u, d) {
    i.value = u, i.getSnapshot = d, sf(i) && cf(n);
  }
  function uf(n, i, u) {
    return u(function() {
      sf(i) && cf(n);
    });
  }
  function sf(n) {
    var i = n.getSnapshot;
    n = n.value;
    try {
      var u = i();
      return !ha(n, u);
    } catch {
      return !0;
    }
  }
  function cf(n) {
    var i = cl(n, 1);
    i !== null && Ln(i, n, 1, -1);
  }
  function ff(n) {
    var i = fi();
    return typeof n == "function" && (n = n()), i.memoizedState = i.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ao, lastRenderedState: n }, i.queue = n, n = n.dispatch = mf.bind(null, Nn, n), [i.memoizedState, n];
  }
  function jo(n, i, u, d) {
    return n = { tag: n, create: i, destroy: u, deps: d, next: null }, i = Nn.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, Nn.updateQueue = i, i.lastEffect = n.next = n) : (u = i.lastEffect, u === null ? i.lastEffect = n.next = n : (d = u.next, u.next = n, n.next = d, i.lastEffect = n)), n;
  }
  function df() {
    return di().memoizedState;
  }
  function Du(n, i, u, d) {
    var m = fi();
    Nn.flags |= n, m.memoizedState = jo(1 | i, u, void 0, d === void 0 ? null : d);
  }
  function Uo(n, i, u, d) {
    var m = di();
    d = d === void 0 ? null : d;
    var x = void 0;
    if (Wn !== null) {
      var _ = Wn.memoizedState;
      if (x = _.destroy, d !== null && Wi(d, _.deps)) {
        m.memoizedState = jo(i, u, x, d);
        return;
      }
    }
    Nn.flags |= n, m.memoizedState = jo(1 | i, u, x, d);
  }
  function Fo(n, i) {
    return Du(8390656, 8, n, i);
  }
  function Js(n, i) {
    return Uo(2048, 8, n, i);
  }
  function pf(n, i) {
    return Uo(4, 2, n, i);
  }
  function hf(n, i) {
    return Uo(4, 4, n, i);
  }
  function vf(n, i) {
    if (typeof i == "function")
      return n = n(), i(n), function() {
        i(null);
      };
    if (i != null)
      return n = n(), i.current = n, function() {
        i.current = null;
      };
  }
  function ip(n, i, u) {
    return u = u != null ? u.concat([n]) : null, Uo(4, 4, vf.bind(null, i, n), u);
  }
  function Po() {
  }
  function ap(n, i) {
    var u = di();
    i = i === void 0 ? null : i;
    var d = u.memoizedState;
    return d !== null && i !== null && Wi(i, d[1]) ? d[0] : (u.memoizedState = [n, i], n);
  }
  function Ou(n, i) {
    var u = di();
    i = i === void 0 ? null : i;
    var d = u.memoizedState;
    return d !== null && i !== null && Wi(i, d[1]) ? d[0] : (n = n(), u.memoizedState = [n, i], n);
  }
  function Gl(n, i, u) {
    return Lo & 21 ? (ha(u, i) || (u = xo(), Nn.lanes |= u, Vo |= u, n.baseState = !0), i) : (n.baseState && (n.baseState = !1, pi = !0), n.memoizedState = u);
  }
  function Di(n, i) {
    var u = Ft;
    Ft = u !== 0 && 4 > u ? u : 4, n(!0);
    var d = rp.transition;
    rp.transition = {};
    try {
      n(!1), i();
    } finally {
      Ft = u, rp.transition = d;
    }
  }
  function Dv() {
    return di().memoizedState;
  }
  function yn(n, i, u) {
    var d = hl(n);
    if (u = { lane: d, action: u, hasEagerState: !1, eagerState: null, next: null }, Zs(n))
      Mu(i, u);
    else if (u = xv(n, i, u, d), u !== null) {
      var m = mr();
      Ln(u, n, d, m), ec(u, i, d);
    }
  }
  function mf(n, i, u) {
    var d = hl(n), m = { lane: d, action: u, hasEagerState: !1, eagerState: null, next: null };
    if (Zs(n))
      Mu(i, m);
    else {
      var x = n.alternate;
      if (n.lanes === 0 && (x === null || x.lanes === 0) && (x = i.lastRenderedReducer, x !== null))
        try {
          var _ = i.lastRenderedState, z = x(_, u);
          if (m.hasEagerState = !0, m.eagerState = z, ha(z, _)) {
            var P = i.interleaved;
            P === null ? (m.next = m, _i(i)) : (m.next = P.next, P.next = m), i.interleaved = m;
            return;
          }
        } catch {
        } finally {
        }
      u = xv(n, i, m, d), u !== null && (m = mr(), Ln(u, n, d, m), ec(u, i, d));
    }
  }
  function Zs(n) {
    var i = n.alternate;
    return n === Nn || i !== null && i === Nn;
  }
  function Mu(n, i) {
    dt = Qn = !0;
    var u = n.pending;
    u === null ? i.next = i : (i.next = u.next, u.next = i), n.pending = i;
  }
  function ec(n, i, u) {
    if (u & 4194240) {
      var d = i.lanes;
      d &= n.pendingLanes, u |= d, i.lanes = u, bs(n, u);
    }
  }
  var yf = { readContext: Me, useCallback: Hn, useContext: Hn, useEffect: Hn, useImperativeHandle: Hn, useInsertionEffect: Hn, useLayoutEffect: Hn, useMemo: Hn, useReducer: Hn, useRef: Hn, useState: Hn, useDebugValue: Hn, useDeferredValue: Hn, useTransition: Hn, useMutableSource: Hn, useSyncExternalStore: Hn, useId: Hn, unstable_isNewReconciler: !1 }, Sg = { readContext: Me, useCallback: function(n, i) {
    return fi().memoizedState = [n, i === void 0 ? null : i], n;
  }, useContext: Me, useEffect: Fo, useImperativeHandle: function(n, i, u) {
    return u = u != null ? u.concat([n]) : null, Du(
      4194308,
      4,
      vf.bind(null, i, n),
      u
    );
  }, useLayoutEffect: function(n, i) {
    return Du(4194308, 4, n, i);
  }, useInsertionEffect: function(n, i) {
    return Du(4, 2, n, i);
  }, useMemo: function(n, i) {
    var u = fi();
    return i = i === void 0 ? null : i, n = n(), u.memoizedState = [n, i], n;
  }, useReducer: function(n, i, u) {
    var d = fi();
    return i = u !== void 0 ? u(i) : i, d.memoizedState = d.baseState = i, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: i }, d.queue = n, n = n.dispatch = yn.bind(null, Nn, n), [d.memoizedState, n];
  }, useRef: function(n) {
    var i = fi();
    return n = { current: n }, i.memoizedState = n;
  }, useState: ff, useDebugValue: Po, useDeferredValue: function(n) {
    return fi().memoizedState = n;
  }, useTransition: function() {
    var n = ff(!1), i = n[0];
    return n = Di.bind(null, n[1]), fi().memoizedState = n, [i, n];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(n, i, u) {
    var d = Nn, m = fi();
    if (bn) {
      if (u === void 0)
        throw Error(s(407));
      u = u();
    } else {
      if (u = i(), Bn === null)
        throw Error(s(349));
      Lo & 30 || lf(d, i, u);
    }
    m.memoizedState = u;
    var x = { value: u, getSnapshot: i };
    return m.queue = x, Fo(uf.bind(
      null,
      d,
      x,
      n
    ), [n]), d.flags |= 2048, jo(9, of.bind(null, d, x, u, i), void 0, null), u;
  }, useId: function() {
    var n = fi(), i = Bn.identifierPrefix;
    if (bn) {
      var u = br, d = si;
      u = (d & ~(1 << 32 - Ir(d) - 1)).toString(32) + u, i = ":" + i + "R" + u, u = za++, 0 < u && (i += "H" + u.toString(32)), i += ":";
    } else
      u = fl++, i = ":" + i + "r" + u.toString(32) + ":";
    return n.memoizedState = i;
  }, unstable_isNewReconciler: !1 }, xg = {
    readContext: Me,
    useCallback: ap,
    useContext: Me,
    useEffect: Js,
    useImperativeHandle: ip,
    useInsertionEffect: pf,
    useLayoutEffect: hf,
    useMemo: Ou,
    useReducer: Xs,
    useRef: df,
    useState: function() {
      return Xs(Ao);
    },
    useDebugValue: Po,
    useDeferredValue: function(n) {
      var i = di();
      return Gl(i, Wn.memoizedState, n);
    },
    useTransition: function() {
      var n = Xs(Ao)[0], i = di().memoizedState;
      return [n, i];
    },
    useMutableSource: rf,
    useSyncExternalStore: af,
    useId: Dv,
    unstable_isNewReconciler: !1
  }, bg = { readContext: Me, useCallback: ap, useContext: Me, useEffect: Js, useImperativeHandle: ip, useInsertionEffect: pf, useLayoutEffect: hf, useMemo: Ou, useReducer: Ks, useRef: df, useState: function() {
    return Ks(Ao);
  }, useDebugValue: Po, useDeferredValue: function(n) {
    var i = di();
    return Wn === null ? i.memoizedState = n : Gl(i, Wn.memoizedState, n);
  }, useTransition: function() {
    var n = Ks(Ao)[0], i = di().memoizedState;
    return [n, i];
  }, useMutableSource: rf, useSyncExternalStore: af, useId: Dv, unstable_isNewReconciler: !1 };
  function Xl(n, i) {
    try {
      var u = "", d = i;
      do
        u += bt(d), d = d.return;
      while (d);
      var m = u;
    } catch (x) {
      m = `
Error generating stack: ` + x.message + `
` + x.stack;
    }
    return { value: n, source: i, stack: m, digest: null };
  }
  function lp(n, i, u) {
    return { value: n, source: null, stack: u ?? null, digest: i ?? null };
  }
  function tc(n, i) {
    try {
      console.error(i.value);
    } catch (u) {
      setTimeout(function() {
        throw u;
      });
    }
  }
  var Ov = typeof WeakMap == "function" ? WeakMap : Map;
  function Mv(n, i, u) {
    u = mn(-1, u), u.tag = 3, u.payload = { element: null };
    var d = i.value;
    return u.callback = function() {
      Df || (Df = !0, vp = d), tc(n, i);
    }, u;
  }
  function Nv(n, i, u) {
    u = mn(-1, u), u.tag = 3;
    var d = n.type.getDerivedStateFromError;
    if (typeof d == "function") {
      var m = i.value;
      u.payload = function() {
        return d(m);
      }, u.callback = function() {
        tc(n, i);
      };
    }
    var x = n.stateNode;
    return x !== null && typeof x.componentDidCatch == "function" && (u.callback = function() {
      tc(n, i), typeof d != "function" && (Gi === null ? Gi = /* @__PURE__ */ new Set([this]) : Gi.add(this));
      var _ = i.stack;
      this.componentDidCatch(i.value, { componentStack: _ !== null ? _ : "" });
    }), u;
  }
  function nc(n, i, u) {
    var d = n.pingCache;
    if (d === null) {
      d = n.pingCache = new Ov();
      var m = /* @__PURE__ */ new Set();
      d.set(i, m);
    } else
      m = d.get(i), m === void 0 && (m = /* @__PURE__ */ new Set(), d.set(i, m));
    m.has(u) || (m.add(u), n = Mg.bind(null, n, i, u), i.then(n, n));
  }
  function Lv(n) {
    do {
      var i;
      if ((i = n.tag === 13) && (i = n.memoizedState, i = i !== null ? i.dehydrated !== null : !0), i)
        return n;
      n = n.return;
    } while (n !== null);
    return null;
  }
  function op(n, i, u, d, m) {
    return n.mode & 1 ? (n.flags |= 65536, n.lanes = m, n) : (n === i ? n.flags |= 65536 : (n.flags |= 128, u.flags |= 131072, u.flags &= -52805, u.tag === 1 && (u.alternate === null ? u.tag = 17 : (i = mn(-1, 1), i.tag = 2, Wl(u, i, 1))), u.lanes |= 1), n);
  }
  var zv = Se.ReactCurrentOwner, pi = !1;
  function qn(n, i, u, d) {
    i.child = n === null ? _v(i, null, u, d) : Tu(i, n.child, u, d);
  }
  function Nu(n, i, u, d, m) {
    u = u.render;
    var x = i.ref;
    return Yn(i, m), d = zo(n, i, u, d, x, m), u = ql(), n !== null && !pi ? (i.updateQueue = n.updateQueue, i.flags &= -2053, n.lanes &= ~m, Gn(n, i, m)) : (bn && u && Xc(i), i.flags |= 1, qn(n, i, d, m), i.child);
  }
  function Kl(n, i, u, d, m) {
    if (n === null) {
      var x = u.type;
      return typeof x == "function" && !xp(x) && x.defaultProps === void 0 && u.compare === null && u.defaultProps === void 0 ? (i.tag = 15, i.type = x, gf(n, i, x, d, m)) : (n = Af(u.type, null, d, i, i.mode, m), n.ref = i.ref, n.return = i, i.child = n);
    }
    if (x = n.child, !(n.lanes & m)) {
      var _ = x.memoizedProps;
      if (u = u.compare, u = u !== null ? u : yu, u(_, d) && n.ref === i.ref)
        return Gn(n, i, m);
    }
    return i.flags |= 1, n = eo(x, d), n.ref = i.ref, n.return = i, i.child = n;
  }
  function gf(n, i, u, d, m) {
    if (n !== null) {
      var x = n.memoizedProps;
      if (yu(x, d) && n.ref === i.ref)
        if (pi = !1, i.pendingProps = d = x, (n.lanes & m) !== 0)
          n.flags & 131072 && (pi = !0);
        else
          return i.lanes = n.lanes, Gn(n, i, m);
    }
    return Rt(n, i, u, d, m);
  }
  function hi(n, i, u) {
    var d = i.pendingProps, m = d.children, x = n !== null ? n.memoizedState : null;
    if (d.mode === "hidden")
      if (!(i.mode & 1))
        i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, qt(Bu, vi), vi |= u;
      else {
        if (!(u & 1073741824))
          return n = x !== null ? x.baseLanes | u : u, i.lanes = i.childLanes = 1073741824, i.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, i.updateQueue = null, qt(Bu, vi), vi |= n, null;
        i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d = x !== null ? x.baseLanes : u, qt(Bu, vi), vi |= d;
      }
    else
      x !== null ? (d = x.baseLanes | u, i.memoizedState = null) : d = u, qt(Bu, vi), vi |= d;
    return qn(n, i, m, u), i.child;
  }
  function Ho(n, i) {
    var u = i.ref;
    (n === null && u !== null || n !== null && n.ref !== u) && (i.flags |= 512, i.flags |= 2097152);
  }
  function Rt(n, i, u, d, m) {
    var x = er(u) ? Br : pr.current;
    return x = ki(i, x), Yn(i, m), u = zo(n, i, u, d, x, m), d = ql(), n !== null && !pi ? (i.updateQueue = n.updateQueue, i.flags &= -2053, n.lanes &= ~m, Gn(n, i, m)) : (bn && d && Xc(i), i.flags |= 1, qn(n, i, u, m), i.child);
  }
  function rc(n, i, u, d, m) {
    if (er(u)) {
      var x = !0;
      Do(i);
    } else
      x = !1;
    if (Yn(i, m), i.stateNode === null)
      ac(n, i), wv(i, u, d), tp(i, u, d, m), d = !0;
    else if (n === null) {
      var _ = i.stateNode, z = i.memoizedProps;
      _.props = z;
      var P = _.context, ee = u.contextType;
      typeof ee == "object" && ee !== null ? ee = Me(ee) : (ee = er(u) ? Br : pr.current, ee = ki(i, ee));
      var ye = u.getDerivedStateFromProps, xe = typeof ye == "function" || typeof _.getSnapshotBeforeUpdate == "function";
      xe || typeof _.UNSAFE_componentWillReceiveProps != "function" && typeof _.componentWillReceiveProps != "function" || (z !== d || P !== ee) && kv(i, _, d, ee), Yl = !1;
      var ve = i.memoizedState;
      _.state = ve, Ys(i, d, _, m), P = i.memoizedState, z !== d || ve !== P || Ct.current || Yl ? (typeof ye == "function" && (ep(i, u, ye, d), P = i.memoizedState), (z = Yl || Cv(i, u, z, d, ve, P, ee)) ? (xe || typeof _.UNSAFE_componentWillMount != "function" && typeof _.componentWillMount != "function" || (typeof _.componentWillMount == "function" && _.componentWillMount(), typeof _.UNSAFE_componentWillMount == "function" && _.UNSAFE_componentWillMount()), typeof _.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof _.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = d, i.memoizedState = P), _.props = d, _.state = P, _.context = ee, d = z) : (typeof _.componentDidMount == "function" && (i.flags |= 4194308), d = !1);
    } else {
      _ = i.stateNode, bv(n, i), z = i.memoizedProps, ee = i.type === i.elementType ? z : ci(i.type, z), _.props = ee, xe = i.pendingProps, ve = _.context, P = u.contextType, typeof P == "object" && P !== null ? P = Me(P) : (P = er(u) ? Br : pr.current, P = ki(i, P));
      var Pe = u.getDerivedStateFromProps;
      (ye = typeof Pe == "function" || typeof _.getSnapshotBeforeUpdate == "function") || typeof _.UNSAFE_componentWillReceiveProps != "function" && typeof _.componentWillReceiveProps != "function" || (z !== xe || ve !== P) && kv(i, _, d, P), Yl = !1, ve = i.memoizedState, _.state = ve, Ys(i, d, _, m);
      var qe = i.memoizedState;
      z !== xe || ve !== qe || Ct.current || Yl ? (typeof Pe == "function" && (ep(i, u, Pe, d), qe = i.memoizedState), (ee = Yl || Cv(i, u, ee, d, ve, qe, P) || !1) ? (ye || typeof _.UNSAFE_componentWillUpdate != "function" && typeof _.componentWillUpdate != "function" || (typeof _.componentWillUpdate == "function" && _.componentWillUpdate(d, qe, P), typeof _.UNSAFE_componentWillUpdate == "function" && _.UNSAFE_componentWillUpdate(d, qe, P)), typeof _.componentDidUpdate == "function" && (i.flags |= 4), typeof _.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof _.componentDidUpdate != "function" || z === n.memoizedProps && ve === n.memoizedState || (i.flags |= 4), typeof _.getSnapshotBeforeUpdate != "function" || z === n.memoizedProps && ve === n.memoizedState || (i.flags |= 1024), i.memoizedProps = d, i.memoizedState = qe), _.props = d, _.state = qe, _.context = P, d = ee) : (typeof _.componentDidUpdate != "function" || z === n.memoizedProps && ve === n.memoizedState || (i.flags |= 4), typeof _.getSnapshotBeforeUpdate != "function" || z === n.memoizedProps && ve === n.memoizedState || (i.flags |= 1024), d = !1);
    }
    return Sf(n, i, u, d, x, m);
  }
  function Sf(n, i, u, d, m, x) {
    Ho(n, i);
    var _ = (i.flags & 128) !== 0;
    if (!d && !_)
      return m && yv(i, u, !1), Gn(n, i, x);
    d = i.stateNode, zv.current = i;
    var z = _ && typeof u.getDerivedStateFromError != "function" ? null : d.render();
    return i.flags |= 1, n !== null && _ ? (i.child = Tu(i, n.child, null, x), i.child = Tu(i, null, z, x)) : qn(n, i, z, x), i.memoizedState = d.state, m && yv(i, u, !0), i.child;
  }
  function Eg(n) {
    var i = n.stateNode;
    i.pendingContext ? Oa(n, i.pendingContext, i.pendingContext !== i.context) : i.context && Oa(n, i.context, !1), np(n, i.containerInfo);
  }
  function Av(n, i, u, d, m) {
    return bu(), tr(m), i.flags |= 256, qn(n, i, u, d), i.child;
  }
  var ic = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Io(n) {
    return { baseLanes: n, cachePool: null, transitions: null };
  }
  function jv(n, i, u) {
    var d = i.pendingProps, m = nt.current, x = !1, _ = (i.flags & 128) !== 0, z;
    if ((z = _) || (z = n !== null && n.memoizedState === null ? !1 : (m & 2) !== 0), z ? (x = !0, i.flags &= -129) : (n === null || n.memoizedState !== null) && (m |= 1), qt(nt, m & 1), n === null)
      return Jc(i), n = i.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (i.mode & 1 ? n.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824 : i.lanes = 1, null) : (_ = d.children, n = d.fallback, x ? (d = i.mode, x = i.child, _ = { mode: "hidden", children: _ }, !(d & 1) && x !== null ? (x.childLanes = 0, x.pendingProps = _) : x = jf(_, d, 0, null), n = Qo(n, d, u, null), x.return = i, n.return = i, x.sibling = n, i.child = x, i.child.memoizedState = Io(u), i.memoizedState = ic, n) : xf(i, _));
    if (m = n.memoizedState, m !== null && (z = m.dehydrated, z !== null))
      return up(n, i, _, d, z, m, u);
    if (x) {
      x = d.fallback, _ = i.mode, m = n.child, z = m.sibling;
      var P = { mode: "hidden", children: d.children };
      return !(_ & 1) && i.child !== m ? (d = i.child, d.childLanes = 0, d.pendingProps = P, i.deletions = null) : (d = eo(m, P), d.subtreeFlags = m.subtreeFlags & 14680064), z !== null ? x = eo(z, x) : (x = Qo(x, _, u, null), x.flags |= 2), x.return = i, d.return = i, d.sibling = x, i.child = d, d = x, x = i.child, _ = n.child.memoizedState, _ = _ === null ? Io(u) : { baseLanes: _.baseLanes | u, cachePool: null, transitions: _.transitions }, x.memoizedState = _, x.childLanes = n.childLanes & ~u, i.memoizedState = ic, d;
    }
    return x = n.child, n = x.sibling, d = eo(x, { mode: "visible", children: d.children }), !(i.mode & 1) && (d.lanes = u), d.return = i, d.sibling = null, n !== null && (u = i.deletions, u === null ? (i.deletions = [n], i.flags |= 16) : u.push(n)), i.child = d, i.memoizedState = null, d;
  }
  function xf(n, i) {
    return i = jf({ mode: "visible", children: i }, n.mode, 0, null), i.return = n, n.child = i;
  }
  function bf(n, i, u, d) {
    return d !== null && tr(d), Tu(i, n.child, null, u), n = xf(i, i.pendingProps.children), n.flags |= 2, i.memoizedState = null, n;
  }
  function up(n, i, u, d, m, x, _) {
    if (u)
      return i.flags & 256 ? (i.flags &= -257, d = lp(Error(s(422))), bf(n, i, _, d)) : i.memoizedState !== null ? (i.child = n.child, i.flags |= 128, null) : (x = d.fallback, m = i.mode, d = jf({ mode: "visible", children: d.children }, m, 0, null), x = Qo(x, m, _, null), x.flags |= 2, d.return = i, x.return = i, d.sibling = x, i.child = d, i.mode & 1 && Tu(i, n.child, null, _), i.child.memoizedState = Io(_), i.memoizedState = ic, x);
    if (!(i.mode & 1))
      return bf(n, i, _, null);
    if (m.data === "$!") {
      if (d = m.nextSibling && m.nextSibling.dataset, d)
        var z = d.dgst;
      return d = z, x = Error(s(419)), d = lp(x, d, void 0), bf(n, i, _, d);
    }
    if (z = (_ & n.childLanes) !== 0, pi || z) {
      if (d = Bn, d !== null) {
        switch (_ & -_) {
          case 4:
            m = 2;
            break;
          case 16:
            m = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            m = 32;
            break;
          case 536870912:
            m = 268435456;
            break;
          default:
            m = 0;
        }
        m = m & (d.suspendedLanes | _) ? 0 : m, m !== 0 && m !== x.retryLane && (x.retryLane = m, cl(n, m), Ln(d, n, m, -1));
      }
      return cc(), d = lp(Error(s(421))), bf(n, i, _, d);
    }
    return m.data === "$?" ? (i.flags |= 128, i.child = n.child, i = Sp.bind(null, n), m._reactRetry = i, null) : (n = x.treeContext, Ri = wi(m.nextSibling), Ti = i, bn = !0, $i = null, n !== null && (oi[ui++] = si, oi[ui++] = br, oi[ui++] = ya, si = n.id, br = n.overflow, ya = i), i = xf(i, d.children), i.flags |= 4096, i);
  }
  function Uv(n, i, u) {
    n.lanes |= i;
    var d = n.alternate;
    d !== null && (d.lanes |= i), $l(n.return, i, u);
  }
  function Ef(n, i, u, d, m) {
    var x = n.memoizedState;
    x === null ? n.memoizedState = { isBackwards: i, rendering: null, renderingStartTime: 0, last: d, tail: u, tailMode: m } : (x.isBackwards = i, x.rendering = null, x.renderingStartTime = 0, x.last = d, x.tail = u, x.tailMode = m);
  }
  function sp(n, i, u) {
    var d = i.pendingProps, m = d.revealOrder, x = d.tail;
    if (qn(n, i, d.children, u), d = nt.current, d & 2)
      d = d & 1 | 2, i.flags |= 128;
    else {
      if (n !== null && n.flags & 128)
        e:
          for (n = i.child; n !== null; ) {
            if (n.tag === 13)
              n.memoizedState !== null && Uv(n, u, i);
            else if (n.tag === 19)
              Uv(n, u, i);
            else if (n.child !== null) {
              n.child.return = n, n = n.child;
              continue;
            }
            if (n === i)
              break e;
            for (; n.sibling === null; ) {
              if (n.return === null || n.return === i)
                break e;
              n = n.return;
            }
            n.sibling.return = n.return, n = n.sibling;
          }
      d &= 1;
    }
    if (qt(nt, d), !(i.mode & 1))
      i.memoizedState = null;
    else
      switch (m) {
        case "forwards":
          for (u = i.child, m = null; u !== null; )
            n = u.alternate, n !== null && Wt(n) === null && (m = u), u = u.sibling;
          u = m, u === null ? (m = i.child, i.child = null) : (m = u.sibling, u.sibling = null), Ef(i, !1, m, u, x);
          break;
        case "backwards":
          for (u = null, m = i.child, i.child = null; m !== null; ) {
            if (n = m.alternate, n !== null && Wt(n) === null) {
              i.child = m;
              break;
            }
            n = m.sibling, m.sibling = u, u = m, m = n;
          }
          Ef(i, !0, u, null, x);
          break;
        case "together":
          Ef(i, !1, null, null, void 0);
          break;
        default:
          i.memoizedState = null;
      }
    return i.child;
  }
  function ac(n, i) {
    !(i.mode & 1) && n !== null && (n.alternate = null, i.alternate = null, i.flags |= 2);
  }
  function Gn(n, i, u) {
    if (n !== null && (i.dependencies = n.dependencies), Vo |= i.lanes, !(u & i.childLanes))
      return null;
    if (n !== null && i.child !== n.child)
      throw Error(s(153));
    if (i.child !== null) {
      for (n = i.child, u = eo(n, n.pendingProps), i.child = u, u.return = i; n.sibling !== null; )
        n = n.sibling, u = u.sibling = eo(n, n.pendingProps), u.return = i;
      u.sibling = null;
    }
    return i.child;
  }
  function dl(n, i, u) {
    switch (i.tag) {
      case 3:
        Eg(i), bu();
        break;
      case 5:
        nf(i);
        break;
      case 1:
        er(i.type) && Do(i);
        break;
      case 4:
        np(i, i.stateNode.containerInfo);
        break;
      case 10:
        var d = i.type._context, m = i.memoizedProps.value;
        qt(Eu, d._currentValue), d._currentValue = m;
        break;
      case 13:
        if (d = i.memoizedState, d !== null)
          return d.dehydrated !== null ? (qt(nt, nt.current & 1), i.flags |= 128, null) : u & i.child.childLanes ? jv(n, i, u) : (qt(nt, nt.current & 1), n = Gn(n, i, u), n !== null ? n.sibling : null);
        qt(nt, nt.current & 1);
        break;
      case 19:
        if (d = (u & i.childLanes) !== 0, n.flags & 128) {
          if (d)
            return sp(n, i, u);
          i.flags |= 128;
        }
        if (m = i.memoizedState, m !== null && (m.rendering = null, m.tail = null, m.lastEffect = null), qt(nt, nt.current), d)
          break;
        return null;
      case 22:
      case 23:
        return i.lanes = 0, hi(n, i, u);
    }
    return Gn(n, i, u);
  }
  var Aa, Lu, zu, Qi;
  Aa = function(n, i) {
    for (var u = i.child; u !== null; ) {
      if (u.tag === 5 || u.tag === 6)
        n.appendChild(u.stateNode);
      else if (u.tag !== 4 && u.child !== null) {
        u.child.return = u, u = u.child;
        continue;
      }
      if (u === i)
        break;
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === i)
          return;
        u = u.return;
      }
      u.sibling.return = u.return, u = u.sibling;
    }
  }, Lu = function() {
  }, zu = function(n, i, u, d) {
    var m = n.memoizedProps;
    if (m !== d) {
      n = i.stateNode, Ql(La.current);
      var x = null;
      switch (u) {
        case "input":
          m = kn(n, m), d = kn(n, d), x = [];
          break;
        case "select":
          m = T({}, m, { value: void 0 }), d = T({}, d, { value: void 0 }), x = [];
          break;
        case "textarea":
          m = Fr(n, m), d = Fr(n, d), x = [];
          break;
        default:
          typeof m.onClick != "function" && typeof d.onClick == "function" && (n.onclick = Qc);
      }
      Et(u, d);
      var _;
      u = null;
      for (ee in m)
        if (!d.hasOwnProperty(ee) && m.hasOwnProperty(ee) && m[ee] != null)
          if (ee === "style") {
            var z = m[ee];
            for (_ in z)
              z.hasOwnProperty(_) && (u || (u = {}), u[_] = "");
          } else
            ee !== "dangerouslySetInnerHTML" && ee !== "children" && ee !== "suppressContentEditableWarning" && ee !== "suppressHydrationWarning" && ee !== "autoFocus" && (h.hasOwnProperty(ee) ? x || (x = []) : (x = x || []).push(ee, null));
      for (ee in d) {
        var P = d[ee];
        if (z = m != null ? m[ee] : void 0, d.hasOwnProperty(ee) && P !== z && (P != null || z != null))
          if (ee === "style")
            if (z) {
              for (_ in z)
                !z.hasOwnProperty(_) || P && P.hasOwnProperty(_) || (u || (u = {}), u[_] = "");
              for (_ in P)
                P.hasOwnProperty(_) && z[_] !== P[_] && (u || (u = {}), u[_] = P[_]);
            } else
              u || (x || (x = []), x.push(
                ee,
                u
              )), u = P;
          else
            ee === "dangerouslySetInnerHTML" ? (P = P ? P.__html : void 0, z = z ? z.__html : void 0, P != null && z !== P && (x = x || []).push(ee, P)) : ee === "children" ? typeof P != "string" && typeof P != "number" || (x = x || []).push(ee, "" + P) : ee !== "suppressContentEditableWarning" && ee !== "suppressHydrationWarning" && (h.hasOwnProperty(ee) ? (P != null && ee === "onScroll" && cn("scroll", n), x || z === P || (x = [])) : (x = x || []).push(ee, P));
      }
      u && (x = x || []).push("style", u);
      var ee = x;
      (i.updateQueue = ee) && (i.flags |= 4);
    }
  }, Qi = function(n, i, u, d) {
    u !== d && (i.flags |= 4);
  };
  function In(n, i) {
    if (!bn)
      switch (n.tailMode) {
        case "hidden":
          i = n.tail;
          for (var u = null; i !== null; )
            i.alternate !== null && (u = i), i = i.sibling;
          u === null ? n.tail = null : u.sibling = null;
          break;
        case "collapsed":
          u = n.tail;
          for (var d = null; u !== null; )
            u.alternate !== null && (d = u), u = u.sibling;
          d === null ? i || n.tail === null ? n.tail = null : n.tail.sibling = null : d.sibling = null;
      }
  }
  function jr(n) {
    var i = n.alternate !== null && n.alternate.child === n.child, u = 0, d = 0;
    if (i)
      for (var m = n.child; m !== null; )
        u |= m.lanes | m.childLanes, d |= m.subtreeFlags & 14680064, d |= m.flags & 14680064, m.return = n, m = m.sibling;
    else
      for (m = n.child; m !== null; )
        u |= m.lanes | m.childLanes, d |= m.subtreeFlags, d |= m.flags, m.return = n, m = m.sibling;
    return n.subtreeFlags |= d, n.childLanes = u, i;
  }
  function Cg(n, i, u) {
    var d = i.pendingProps;
    switch (Kc(i), i.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return jr(i), null;
      case 1:
        return er(i.type) && li(), jr(i), null;
      case 3:
        return d = i.stateNode, _u(), et(Ct), et(pr), Yi(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (n === null || n.child === null) && (Zc(i) ? i.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(i.flags & 256) || (i.flags |= 1024, $i !== null && (mp($i), $i = null))), Lu(n, i), jr(i), null;
      case 5:
        ct(i);
        var m = Ql(qs.current);
        if (u = i.type, n !== null && i.stateNode != null)
          zu(n, i, u, d, m), n.ref !== i.ref && (i.flags |= 512, i.flags |= 2097152);
        else {
          if (!d) {
            if (i.stateNode === null)
              throw Error(s(166));
            return jr(i), null;
          }
          if (n = Ql(La.current), Zc(i)) {
            d = i.stateNode, u = i.type;
            var x = i.memoizedProps;
            switch (d[Hi] = i, d[Vs] = x, n = (i.mode & 1) !== 0, u) {
              case "dialog":
                cn("cancel", d), cn("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                cn("load", d);
                break;
              case "video":
              case "audio":
                for (m = 0; m < al.length; m++)
                  cn(al[m], d);
                break;
              case "source":
                cn("error", d);
                break;
              case "img":
              case "image":
              case "link":
                cn(
                  "error",
                  d
                ), cn("load", d);
                break;
              case "details":
                cn("toggle", d);
                break;
              case "input":
                Jn(d, x), cn("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!x.multiple }, cn("invalid", d);
                break;
              case "textarea":
                Pr(d, x), cn("invalid", d);
            }
            Et(u, x), m = null;
            for (var _ in x)
              if (x.hasOwnProperty(_)) {
                var z = x[_];
                _ === "children" ? typeof z == "string" ? d.textContent !== z && (x.suppressHydrationWarning !== !0 && Ps(d.textContent, z, n), m = ["children", z]) : typeof z == "number" && d.textContent !== "" + z && (x.suppressHydrationWarning !== !0 && Ps(
                  d.textContent,
                  z,
                  n
                ), m = ["children", "" + z]) : h.hasOwnProperty(_) && z != null && _ === "onScroll" && cn("scroll", d);
              }
            switch (u) {
              case "input":
                An(d), Un(d, x, !0);
                break;
              case "textarea":
                An(d), Hr(d);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof x.onClick == "function" && (d.onclick = Qc);
            }
            d = m, i.updateQueue = d, d !== null && (i.flags |= 4);
          } else {
            _ = m.nodeType === 9 ? m : m.ownerDocument, n === "http://www.w3.org/1999/xhtml" && (n = re(u)), n === "http://www.w3.org/1999/xhtml" ? u === "script" ? (n = _.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild)) : typeof d.is == "string" ? n = _.createElement(u, { is: d.is }) : (n = _.createElement(u), u === "select" && (_ = n, d.multiple ? _.multiple = !0 : d.size && (_.size = d.size))) : n = _.createElementNS(n, u), n[Hi] = i, n[Vs] = d, Aa(n, i, !1, !1), i.stateNode = n;
            e: {
              switch (_ = on(u, d), u) {
                case "dialog":
                  cn("cancel", n), cn("close", n), m = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  cn("load", n), m = d;
                  break;
                case "video":
                case "audio":
                  for (m = 0; m < al.length; m++)
                    cn(al[m], n);
                  m = d;
                  break;
                case "source":
                  cn("error", n), m = d;
                  break;
                case "img":
                case "image":
                case "link":
                  cn(
                    "error",
                    n
                  ), cn("load", n), m = d;
                  break;
                case "details":
                  cn("toggle", n), m = d;
                  break;
                case "input":
                  Jn(n, d), m = kn(n, d), cn("invalid", n);
                  break;
                case "option":
                  m = d;
                  break;
                case "select":
                  n._wrapperState = { wasMultiple: !!d.multiple }, m = T({}, d, { value: void 0 }), cn("invalid", n);
                  break;
                case "textarea":
                  Pr(n, d), m = Fr(n, d), cn("invalid", n);
                  break;
                default:
                  m = d;
              }
              Et(u, m), z = m;
              for (x in z)
                if (z.hasOwnProperty(x)) {
                  var P = z[x];
                  x === "style" ? St(n, P) : x === "dangerouslySetInnerHTML" ? (P = P ? P.__html : void 0, P != null && yt(n, P)) : x === "children" ? typeof P == "string" ? (u !== "textarea" || P !== "") && Ot(n, P) : typeof P == "number" && Ot(n, "" + P) : x !== "suppressContentEditableWarning" && x !== "suppressHydrationWarning" && x !== "autoFocus" && (h.hasOwnProperty(x) ? P != null && x === "onScroll" && cn("scroll", n) : P != null && te(n, x, P, _));
                }
              switch (u) {
                case "input":
                  An(n), Un(n, d, !1);
                  break;
                case "textarea":
                  An(n), Hr(n);
                  break;
                case "option":
                  d.value != null && n.setAttribute("value", "" + mt(d.value));
                  break;
                case "select":
                  n.multiple = !!d.multiple, x = d.value, x != null ? $n(n, !!d.multiple, x, !1) : d.defaultValue != null && $n(
                    n,
                    !!d.multiple,
                    d.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof m.onClick == "function" && (n.onclick = Qc);
              }
              switch (u) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break e;
                case "img":
                  d = !0;
                  break e;
                default:
                  d = !1;
              }
            }
            d && (i.flags |= 4);
          }
          i.ref !== null && (i.flags |= 512, i.flags |= 2097152);
        }
        return jr(i), null;
      case 6:
        if (n && i.stateNode != null)
          Qi(n, i, n.memoizedProps, d);
        else {
          if (typeof d != "string" && i.stateNode === null)
            throw Error(s(166));
          if (u = Ql(qs.current), Ql(La.current), Zc(i)) {
            if (d = i.stateNode, u = i.memoizedProps, d[Hi] = i, (x = d.nodeValue !== u) && (n = Ti, n !== null))
              switch (n.tag) {
                case 3:
                  Ps(d.nodeValue, u, (n.mode & 1) !== 0);
                  break;
                case 5:
                  n.memoizedProps.suppressHydrationWarning !== !0 && Ps(d.nodeValue, u, (n.mode & 1) !== 0);
              }
            x && (i.flags |= 4);
          } else
            d = (u.nodeType === 9 ? u : u.ownerDocument).createTextNode(d), d[Hi] = i, i.stateNode = d;
        }
        return jr(i), null;
      case 13:
        if (et(nt), d = i.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
          if (bn && Ri !== null && i.mode & 1 && !(i.flags & 128))
            Sv(), bu(), i.flags |= 98560, x = !1;
          else if (x = Zc(i), d !== null && d.dehydrated !== null) {
            if (n === null) {
              if (!x)
                throw Error(s(318));
              if (x = i.memoizedState, x = x !== null ? x.dehydrated : null, !x)
                throw Error(s(317));
              x[Hi] = i;
            } else
              bu(), !(i.flags & 128) && (i.memoizedState = null), i.flags |= 4;
            jr(i), x = !1;
          } else
            $i !== null && (mp($i), $i = null), x = !0;
          if (!x)
            return i.flags & 65536 ? i : null;
        }
        return i.flags & 128 ? (i.lanes = u, i) : (d = d !== null, d !== (n !== null && n.memoizedState !== null) && d && (i.child.flags |= 8192, i.mode & 1 && (n === null || nt.current & 1 ? ar === 0 && (ar = 3) : cc())), i.updateQueue !== null && (i.flags |= 4), jr(i), null);
      case 4:
        return _u(), Lu(n, i), n === null && _a(i.stateNode.containerInfo), jr(i), null;
      case 10:
        return Jd(i.type._context), jr(i), null;
      case 17:
        return er(i.type) && li(), jr(i), null;
      case 19:
        if (et(nt), x = i.memoizedState, x === null)
          return jr(i), null;
        if (d = (i.flags & 128) !== 0, _ = x.rendering, _ === null)
          if (d)
            In(x, !1);
          else {
            if (ar !== 0 || n !== null && n.flags & 128)
              for (n = i.child; n !== null; ) {
                if (_ = Wt(n), _ !== null) {
                  for (i.flags |= 128, In(x, !1), d = _.updateQueue, d !== null && (i.updateQueue = d, i.flags |= 4), i.subtreeFlags = 0, d = u, u = i.child; u !== null; )
                    x = u, n = d, x.flags &= 14680066, _ = x.alternate, _ === null ? (x.childLanes = 0, x.lanes = n, x.child = null, x.subtreeFlags = 0, x.memoizedProps = null, x.memoizedState = null, x.updateQueue = null, x.dependencies = null, x.stateNode = null) : (x.childLanes = _.childLanes, x.lanes = _.lanes, x.child = _.child, x.subtreeFlags = 0, x.deletions = null, x.memoizedProps = _.memoizedProps, x.memoizedState = _.memoizedState, x.updateQueue = _.updateQueue, x.type = _.type, n = _.dependencies, x.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), u = u.sibling;
                  return qt(nt, nt.current & 1 | 2), i.child;
                }
                n = n.sibling;
              }
            x.tail !== null && vn() > $u && (i.flags |= 128, d = !0, In(x, !1), i.lanes = 4194304);
          }
        else {
          if (!d)
            if (n = Wt(_), n !== null) {
              if (i.flags |= 128, d = !0, u = n.updateQueue, u !== null && (i.updateQueue = u, i.flags |= 4), In(x, !0), x.tail === null && x.tailMode === "hidden" && !_.alternate && !bn)
                return jr(i), null;
            } else
              2 * vn() - x.renderingStartTime > $u && u !== 1073741824 && (i.flags |= 128, d = !0, In(x, !1), i.lanes = 4194304);
          x.isBackwards ? (_.sibling = i.child, i.child = _) : (u = x.last, u !== null ? u.sibling = _ : i.child = _, x.last = _);
        }
        return x.tail !== null ? (i = x.tail, x.rendering = i, x.tail = i.sibling, x.renderingStartTime = vn(), i.sibling = null, u = nt.current, qt(nt, d ? u & 1 | 2 : u & 1), i) : (jr(i), null);
      case 22:
      case 23:
        return Lf(), d = i.memoizedState !== null, n !== null && n.memoizedState !== null !== d && (i.flags |= 8192), d && i.mode & 1 ? vi & 1073741824 && (jr(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : jr(i), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(s(156, i.tag));
  }
  function wg(n, i) {
    switch (Kc(i), i.tag) {
      case 1:
        return er(i.type) && li(), n = i.flags, n & 65536 ? (i.flags = n & -65537 | 128, i) : null;
      case 3:
        return _u(), et(Ct), et(pr), Yi(), n = i.flags, n & 65536 && !(n & 128) ? (i.flags = n & -65537 | 128, i) : null;
      case 5:
        return ct(i), null;
      case 13:
        if (et(nt), n = i.memoizedState, n !== null && n.dehydrated !== null) {
          if (i.alternate === null)
            throw Error(s(340));
          bu();
        }
        return n = i.flags, n & 65536 ? (i.flags = n & -65537 | 128, i) : null;
      case 19:
        return et(nt), null;
      case 4:
        return _u(), null;
      case 10:
        return Jd(i.type._context), null;
      case 22:
      case 23:
        return Lf(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Au = !1, Er = !1, Cf = typeof WeakSet == "function" ? WeakSet : Set, We = null;
  function ju(n, i) {
    var u = n.ref;
    if (u !== null)
      if (typeof u == "function")
        try {
          u(null);
        } catch (d) {
          Vn(n, i, d);
        }
      else
        u.current = null;
  }
  function cp(n, i, u) {
    try {
      u();
    } catch (d) {
      Vn(n, i, d);
    }
  }
  var wf = !1;
  function kg(n, i) {
    if (Id = fu, n = av(), Ls(n)) {
      if ("selectionStart" in n)
        var u = { start: n.selectionStart, end: n.selectionEnd };
      else
        e: {
          u = (u = n.ownerDocument) && u.defaultView || window;
          var d = u.getSelection && u.getSelection();
          if (d && d.rangeCount !== 0) {
            u = d.anchorNode;
            var m = d.anchorOffset, x = d.focusNode;
            d = d.focusOffset;
            try {
              u.nodeType, x.nodeType;
            } catch {
              u = null;
              break e;
            }
            var _ = 0, z = -1, P = -1, ee = 0, ye = 0, xe = n, ve = null;
            t:
              for (; ; ) {
                for (var Pe; xe !== u || m !== 0 && xe.nodeType !== 3 || (z = _ + m), xe !== x || d !== 0 && xe.nodeType !== 3 || (P = _ + d), xe.nodeType === 3 && (_ += xe.nodeValue.length), (Pe = xe.firstChild) !== null; )
                  ve = xe, xe = Pe;
                for (; ; ) {
                  if (xe === n)
                    break t;
                  if (ve === u && ++ee === m && (z = _), ve === x && ++ye === d && (P = _), (Pe = xe.nextSibling) !== null)
                    break;
                  xe = ve, ve = xe.parentNode;
                }
                xe = Pe;
              }
            u = z === -1 || P === -1 ? null : { start: z, end: P };
          } else
            u = null;
        }
      u = u || { start: 0, end: 0 };
    } else
      u = null;
    for (Bd = { focusedElem: n, selectionRange: u }, fu = !1, We = i; We !== null; )
      if (i = We, n = i.child, (i.subtreeFlags & 1028) !== 0 && n !== null)
        n.return = i, We = n;
      else
        for (; We !== null; ) {
          i = We;
          try {
            var qe = i.alternate;
            if (i.flags & 1024)
              switch (i.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (qe !== null) {
                    var Ze = qe.memoizedProps, Xn = qe.memoizedState, W = i.stateNode, I = W.getSnapshotBeforeUpdate(i.elementType === i.type ? Ze : ci(i.type, Ze), Xn);
                    W.__reactInternalSnapshotBeforeUpdate = I;
                  }
                  break;
                case 3:
                  var G = i.stateNode.containerInfo;
                  G.nodeType === 1 ? G.textContent = "" : G.nodeType === 9 && G.documentElement && G.removeChild(G.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(s(163));
              }
          } catch (Te) {
            Vn(i, i.return, Te);
          }
          if (n = i.sibling, n !== null) {
            n.return = i.return, We = n;
            break;
          }
          We = i.return;
        }
    return qe = wf, wf = !1, qe;
  }
  function Uu(n, i, u) {
    var d = i.updateQueue;
    if (d = d !== null ? d.lastEffect : null, d !== null) {
      var m = d = d.next;
      do {
        if ((m.tag & n) === n) {
          var x = m.destroy;
          m.destroy = void 0, x !== void 0 && cp(i, u, x);
        }
        m = m.next;
      } while (m !== d);
    }
  }
  function kf(n, i) {
    if (i = i.updateQueue, i = i !== null ? i.lastEffect : null, i !== null) {
      var u = i = i.next;
      do {
        if ((u.tag & n) === n) {
          var d = u.create;
          u.destroy = d();
        }
        u = u.next;
      } while (u !== i);
    }
  }
  function Tf(n) {
    var i = n.ref;
    if (i !== null) {
      var u = n.stateNode;
      switch (n.tag) {
        case 5:
          n = u;
          break;
        default:
          n = u;
      }
      typeof i == "function" ? i(n) : i.current = n;
    }
  }
  function Fv(n) {
    var i = n.alternate;
    i !== null && (n.alternate = null, Fv(i)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (i = n.stateNode, i !== null && (delete i[Hi], delete i[Vs], delete i[Wd], delete i[mg], delete i[yg])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
  }
  function fp(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4;
  }
  function Pv(n) {
    e:
      for (; ; ) {
        for (; n.sibling === null; ) {
          if (n.return === null || fp(n.return))
            return null;
          n = n.return;
        }
        for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
          if (n.flags & 2 || n.child === null || n.tag === 4)
            continue e;
          n.child.return = n, n = n.child;
        }
        if (!(n.flags & 2))
          return n.stateNode;
      }
  }
  function lc(n, i, u) {
    var d = n.tag;
    if (d === 5 || d === 6)
      n = n.stateNode, i ? u.nodeType === 8 ? u.parentNode.insertBefore(n, i) : u.insertBefore(n, i) : (u.nodeType === 8 ? (i = u.parentNode, i.insertBefore(n, u)) : (i = u, i.appendChild(n)), u = u._reactRootContainer, u != null || i.onclick !== null || (i.onclick = Qc));
    else if (d !== 4 && (n = n.child, n !== null))
      for (lc(n, i, u), n = n.sibling; n !== null; )
        lc(n, i, u), n = n.sibling;
  }
  function Fu(n, i, u) {
    var d = n.tag;
    if (d === 5 || d === 6)
      n = n.stateNode, i ? u.insertBefore(n, i) : u.appendChild(n);
    else if (d !== 4 && (n = n.child, n !== null))
      for (Fu(n, i, u), n = n.sibling; n !== null; )
        Fu(n, i, u), n = n.sibling;
  }
  var Tn = null, hr = !1;
  function Vr(n, i, u) {
    for (u = u.child; u !== null; )
      Pu(n, i, u), u = u.sibling;
  }
  function Pu(n, i, u) {
    if (ni && typeof ni.onCommitFiberUnmount == "function")
      try {
        ni.onCommitFiberUnmount(Ol, u);
      } catch {
      }
    switch (u.tag) {
      case 5:
        Er || ju(u, i);
      case 6:
        var d = Tn, m = hr;
        Tn = null, Vr(n, i, u), Tn = d, hr = m, Tn !== null && (hr ? (n = Tn, u = u.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(u) : n.removeChild(u)) : Tn.removeChild(u.stateNode));
        break;
      case 18:
        Tn !== null && (hr ? (n = Tn, u = u.stateNode, n.nodeType === 8 ? Yd(n.parentNode, u) : n.nodeType === 1 && Yd(n, u), Pi(n)) : Yd(Tn, u.stateNode));
        break;
      case 4:
        d = Tn, m = hr, Tn = u.stateNode.containerInfo, hr = !0, Vr(n, i, u), Tn = d, hr = m;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Er && (d = u.updateQueue, d !== null && (d = d.lastEffect, d !== null))) {
          m = d = d.next;
          do {
            var x = m, _ = x.destroy;
            x = x.tag, _ !== void 0 && (x & 2 || x & 4) && cp(u, i, _), m = m.next;
          } while (m !== d);
        }
        Vr(n, i, u);
        break;
      case 1:
        if (!Er && (ju(u, i), d = u.stateNode, typeof d.componentWillUnmount == "function"))
          try {
            d.props = u.memoizedProps, d.state = u.memoizedState, d.componentWillUnmount();
          } catch (z) {
            Vn(u, i, z);
          }
        Vr(n, i, u);
        break;
      case 21:
        Vr(n, i, u);
        break;
      case 22:
        u.mode & 1 ? (Er = (d = Er) || u.memoizedState !== null, Vr(n, i, u), Er = d) : Vr(n, i, u);
        break;
      default:
        Vr(n, i, u);
    }
  }
  function Hu(n) {
    var i = n.updateQueue;
    if (i !== null) {
      n.updateQueue = null;
      var u = n.stateNode;
      u === null && (u = n.stateNode = new Cf()), i.forEach(function(d) {
        var m = Ng.bind(null, n, d);
        u.has(d) || (u.add(d), d.then(m, m));
      });
    }
  }
  function vr(n, i) {
    var u = i.deletions;
    if (u !== null)
      for (var d = 0; d < u.length; d++) {
        var m = u[d];
        try {
          var x = n, _ = i, z = _;
          e:
            for (; z !== null; ) {
              switch (z.tag) {
                case 5:
                  Tn = z.stateNode, hr = !1;
                  break e;
                case 3:
                  Tn = z.stateNode.containerInfo, hr = !0;
                  break e;
                case 4:
                  Tn = z.stateNode.containerInfo, hr = !0;
                  break e;
              }
              z = z.return;
            }
          if (Tn === null)
            throw Error(s(160));
          Pu(x, _, m), Tn = null, hr = !1;
          var P = m.alternate;
          P !== null && (P.return = null), m.return = null;
        } catch (ee) {
          Vn(m, i, ee);
        }
      }
    if (i.subtreeFlags & 12854)
      for (i = i.child; i !== null; )
        Hv(i, n), i = i.sibling;
  }
  function Hv(n, i) {
    var u = n.alternate, d = n.flags;
    switch (n.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (vr(i, n), ja(n), d & 4) {
          try {
            Uu(3, n, n.return), kf(3, n);
          } catch (Ze) {
            Vn(n, n.return, Ze);
          }
          try {
            Uu(5, n, n.return);
          } catch (Ze) {
            Vn(n, n.return, Ze);
          }
        }
        break;
      case 1:
        vr(i, n), ja(n), d & 512 && u !== null && ju(u, u.return);
        break;
      case 5:
        if (vr(i, n), ja(n), d & 512 && u !== null && ju(u, u.return), n.flags & 32) {
          var m = n.stateNode;
          try {
            Ot(m, "");
          } catch (Ze) {
            Vn(n, n.return, Ze);
          }
        }
        if (d & 4 && (m = n.stateNode, m != null)) {
          var x = n.memoizedProps, _ = u !== null ? u.memoizedProps : x, z = n.type, P = n.updateQueue;
          if (n.updateQueue = null, P !== null)
            try {
              z === "input" && x.type === "radio" && x.name != null && jn(m, x), on(z, _);
              var ee = on(z, x);
              for (_ = 0; _ < P.length; _ += 2) {
                var ye = P[_], xe = P[_ + 1];
                ye === "style" ? St(m, xe) : ye === "dangerouslySetInnerHTML" ? yt(m, xe) : ye === "children" ? Ot(m, xe) : te(m, ye, xe, ee);
              }
              switch (z) {
                case "input":
                  Dn(m, x);
                  break;
                case "textarea":
                  fr(m, x);
                  break;
                case "select":
                  var ve = m._wrapperState.wasMultiple;
                  m._wrapperState.wasMultiple = !!x.multiple;
                  var Pe = x.value;
                  Pe != null ? $n(m, !!x.multiple, Pe, !1) : ve !== !!x.multiple && (x.defaultValue != null ? $n(
                    m,
                    !!x.multiple,
                    x.defaultValue,
                    !0
                  ) : $n(m, !!x.multiple, x.multiple ? [] : "", !1));
              }
              m[Vs] = x;
            } catch (Ze) {
              Vn(n, n.return, Ze);
            }
        }
        break;
      case 6:
        if (vr(i, n), ja(n), d & 4) {
          if (n.stateNode === null)
            throw Error(s(162));
          m = n.stateNode, x = n.memoizedProps;
          try {
            m.nodeValue = x;
          } catch (Ze) {
            Vn(n, n.return, Ze);
          }
        }
        break;
      case 3:
        if (vr(i, n), ja(n), d & 4 && u !== null && u.memoizedState.isDehydrated)
          try {
            Pi(i.containerInfo);
          } catch (Ze) {
            Vn(n, n.return, Ze);
          }
        break;
      case 4:
        vr(i, n), ja(n);
        break;
      case 13:
        vr(i, n), ja(n), m = n.child, m.flags & 8192 && (x = m.memoizedState !== null, m.stateNode.isHidden = x, !x || m.alternate !== null && m.alternate.memoizedState !== null || (_f = vn())), d & 4 && Hu(n);
        break;
      case 22:
        if (ye = u !== null && u.memoizedState !== null, n.mode & 1 ? (Er = (ee = Er) || ye, vr(i, n), Er = ee) : vr(i, n), ja(n), d & 8192) {
          if (ee = n.memoizedState !== null, (n.stateNode.isHidden = ee) && !ye && n.mode & 1)
            for (We = n, ye = n.child; ye !== null; ) {
              for (xe = We = ye; We !== null; ) {
                switch (ve = We, Pe = ve.child, ve.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Uu(4, ve, ve.return);
                    break;
                  case 1:
                    ju(ve, ve.return);
                    var qe = ve.stateNode;
                    if (typeof qe.componentWillUnmount == "function") {
                      d = ve, u = ve.return;
                      try {
                        i = d, qe.props = i.memoizedProps, qe.state = i.memoizedState, qe.componentWillUnmount();
                      } catch (Ze) {
                        Vn(d, u, Ze);
                      }
                    }
                    break;
                  case 5:
                    ju(ve, ve.return);
                    break;
                  case 22:
                    if (ve.memoizedState !== null) {
                      Iv(xe);
                      continue;
                    }
                }
                Pe !== null ? (Pe.return = ve, We = Pe) : Iv(xe);
              }
              ye = ye.sibling;
            }
          e:
            for (ye = null, xe = n; ; ) {
              if (xe.tag === 5) {
                if (ye === null) {
                  ye = xe;
                  try {
                    m = xe.stateNode, ee ? (x = m.style, typeof x.setProperty == "function" ? x.setProperty("display", "none", "important") : x.display = "none") : (z = xe.stateNode, P = xe.memoizedProps.style, _ = P != null && P.hasOwnProperty("display") ? P.display : null, z.style.display = Ye("display", _));
                  } catch (Ze) {
                    Vn(n, n.return, Ze);
                  }
                }
              } else if (xe.tag === 6) {
                if (ye === null)
                  try {
                    xe.stateNode.nodeValue = ee ? "" : xe.memoizedProps;
                  } catch (Ze) {
                    Vn(n, n.return, Ze);
                  }
              } else if ((xe.tag !== 22 && xe.tag !== 23 || xe.memoizedState === null || xe === n) && xe.child !== null) {
                xe.child.return = xe, xe = xe.child;
                continue;
              }
              if (xe === n)
                break e;
              for (; xe.sibling === null; ) {
                if (xe.return === null || xe.return === n)
                  break e;
                ye === xe && (ye = null), xe = xe.return;
              }
              ye === xe && (ye = null), xe.sibling.return = xe.return, xe = xe.sibling;
            }
        }
        break;
      case 19:
        vr(i, n), ja(n), d & 4 && Hu(n);
        break;
      case 21:
        break;
      default:
        vr(
          i,
          n
        ), ja(n);
    }
  }
  function ja(n) {
    var i = n.flags;
    if (i & 2) {
      try {
        e: {
          for (var u = n.return; u !== null; ) {
            if (fp(u)) {
              var d = u;
              break e;
            }
            u = u.return;
          }
          throw Error(s(160));
        }
        switch (d.tag) {
          case 5:
            var m = d.stateNode;
            d.flags & 32 && (Ot(m, ""), d.flags &= -33);
            var x = Pv(n);
            Fu(n, x, m);
            break;
          case 3:
          case 4:
            var _ = d.stateNode.containerInfo, z = Pv(n);
            lc(n, z, _);
            break;
          default:
            throw Error(s(161));
        }
      } catch (P) {
        Vn(n, n.return, P);
      }
      n.flags &= -3;
    }
    i & 4096 && (n.flags &= -4097);
  }
  function Tg(n, i, u) {
    We = n, dp(n);
  }
  function dp(n, i, u) {
    for (var d = (n.mode & 1) !== 0; We !== null; ) {
      var m = We, x = m.child;
      if (m.tag === 22 && d) {
        var _ = m.memoizedState !== null || Au;
        if (!_) {
          var z = m.alternate, P = z !== null && z.memoizedState !== null || Er;
          z = Au;
          var ee = Er;
          if (Au = _, (Er = P) && !ee)
            for (We = m; We !== null; )
              _ = We, P = _.child, _.tag === 22 && _.memoizedState !== null ? pp(m) : P !== null ? (P.return = _, We = P) : pp(m);
          for (; x !== null; )
            We = x, dp(x), x = x.sibling;
          We = m, Au = z, Er = ee;
        }
        Iu(n);
      } else
        m.subtreeFlags & 8772 && x !== null ? (x.return = m, We = x) : Iu(n);
    }
  }
  function Iu(n) {
    for (; We !== null; ) {
      var i = We;
      if (i.flags & 8772) {
        var u = i.alternate;
        try {
          if (i.flags & 8772)
            switch (i.tag) {
              case 0:
              case 11:
              case 15:
                Er || kf(5, i);
                break;
              case 1:
                var d = i.stateNode;
                if (i.flags & 4 && !Er)
                  if (u === null)
                    d.componentDidMount();
                  else {
                    var m = i.elementType === i.type ? u.memoizedProps : ci(i.type, u.memoizedProps);
                    d.componentDidUpdate(m, u.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                var x = i.updateQueue;
                x !== null && wu(i, x, d);
                break;
              case 3:
                var _ = i.updateQueue;
                if (_ !== null) {
                  if (u = null, i.child !== null)
                    switch (i.child.tag) {
                      case 5:
                        u = i.child.stateNode;
                        break;
                      case 1:
                        u = i.child.stateNode;
                    }
                  wu(i, _, u);
                }
                break;
              case 5:
                var z = i.stateNode;
                if (u === null && i.flags & 4) {
                  u = z;
                  var P = i.memoizedProps;
                  switch (i.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      P.autoFocus && u.focus();
                      break;
                    case "img":
                      P.src && (u.src = P.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (i.memoizedState === null) {
                  var ee = i.alternate;
                  if (ee !== null) {
                    var ye = ee.memoizedState;
                    if (ye !== null) {
                      var xe = ye.dehydrated;
                      xe !== null && Pi(xe);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(s(163));
            }
          Er || i.flags & 512 && Tf(i);
        } catch (ve) {
          Vn(i, i.return, ve);
        }
      }
      if (i === n) {
        We = null;
        break;
      }
      if (u = i.sibling, u !== null) {
        u.return = i.return, We = u;
        break;
      }
      We = i.return;
    }
  }
  function Iv(n) {
    for (; We !== null; ) {
      var i = We;
      if (i === n) {
        We = null;
        break;
      }
      var u = i.sibling;
      if (u !== null) {
        u.return = i.return, We = u;
        break;
      }
      We = i.return;
    }
  }
  function pp(n) {
    for (; We !== null; ) {
      var i = We;
      try {
        switch (i.tag) {
          case 0:
          case 11:
          case 15:
            var u = i.return;
            try {
              kf(4, i);
            } catch (P) {
              Vn(i, u, P);
            }
            break;
          case 1:
            var d = i.stateNode;
            if (typeof d.componentDidMount == "function") {
              var m = i.return;
              try {
                d.componentDidMount();
              } catch (P) {
                Vn(i, m, P);
              }
            }
            var x = i.return;
            try {
              Tf(i);
            } catch (P) {
              Vn(i, x, P);
            }
            break;
          case 5:
            var _ = i.return;
            try {
              Tf(i);
            } catch (P) {
              Vn(i, _, P);
            }
        }
      } catch (P) {
        Vn(i, i.return, P);
      }
      if (i === n) {
        We = null;
        break;
      }
      var z = i.sibling;
      if (z !== null) {
        z.return = i.return, We = z;
        break;
      }
      We = i.return;
    }
  }
  var Rg = Math.ceil, Bo = Se.ReactCurrentDispatcher, Rf = Se.ReactCurrentOwner, qi = Se.ReactCurrentBatchConfig, At = 0, Bn = null, En = null, ir = 0, vi = 0, Bu = fn(0), ar = 0, oc = null, Vo = 0, Vu = 0, hp = 0, Jl = null, Ur = null, _f = 0, $u = 1 / 0, pl = null, Df = !1, vp = null, Gi = null, Yu = !1, Xi = null, Of = 0, uc = 0, Mf = null, sc = -1, $o = 0;
  function mr() {
    return At & 6 ? vn() : sc !== -1 ? sc : sc = vn();
  }
  function hl(n) {
    return n.mode & 1 ? At & 2 && ir !== 0 ? ir & -ir : gg.transition !== null ? ($o === 0 && ($o = xo()), $o) : (n = Ft, n !== 0 || (n = window.event, n = n === void 0 ? 16 : ks(n.type)), n) : 1;
  }
  function Ln(n, i, u, d) {
    if (50 < uc)
      throw uc = 0, Mf = null, Error(s(185));
    Nl(n, u, d), (!(At & 2) || n !== Bn) && (n === Bn && (!(At & 2) && (Vu |= u), ar === 4 && Ua(n, ir)), lr(n, d), u === 1 && At === 0 && !(i.mode & 1) && ($u = vn() + 500, Il && Ma()));
  }
  function lr(n, i) {
    var u = n.callbackNode;
    Ml(n, i);
    var d = ka(n, n === Bn ? ir : 0);
    if (d === 0)
      u !== null && hn(u), n.callbackNode = null, n.callbackPriority = 0;
    else if (i = d & -d, n.callbackPriority !== i) {
      if (u != null && hn(u), i === 1)
        n.tag === 0 ? gv(Wu.bind(null, n)) : Gc(Wu.bind(null, n)), mv(function() {
          !(At & 6) && Ma();
        }), u = null;
      else {
        switch (Es(d)) {
          case 1:
            u = vs;
            break;
          case 4:
            u = wa;
            break;
          case 16:
            u = Mt;
            break;
          case 536870912:
            u = Xa;
            break;
          default:
            u = Mt;
        }
        u = Gv(u, Nf.bind(null, n));
      }
      n.callbackPriority = i, n.callbackNode = u;
    }
  }
  function Nf(n, i) {
    if (sc = -1, $o = 0, At & 6)
      throw Error(s(327));
    var u = n.callbackNode;
    if (Qu() && n.callbackNode !== u)
      return null;
    var d = ka(n, n === Bn ? ir : 0);
    if (d === 0)
      return null;
    if (d & 30 || d & n.expiredLanes || i)
      i = zf(n, d);
    else {
      i = d;
      var m = At;
      At |= 2;
      var x = Vv();
      (Bn !== n || ir !== i) && (pl = null, $u = vn() + 500, Wo(n, i));
      do
        try {
          Dg();
          break;
        } catch (z) {
          Bv(n, z);
        }
      while (!0);
      Kd(), Bo.current = x, At = m, En !== null ? i = 0 : (Bn = null, ir = 0, i = ar);
    }
    if (i !== 0) {
      if (i === 2 && (m = Ta(n), m !== 0 && (d = m, i = Yo(n, m))), i === 1)
        throw u = oc, Wo(n, 0), Ua(n, d), lr(n, vn()), u;
      if (i === 6)
        Ua(n, d);
      else {
        if (m = n.current.alternate, !(d & 30) && !yp(m) && (i = zf(n, d), i === 2 && (x = Ta(n), x !== 0 && (d = x, i = Yo(n, x))), i === 1))
          throw u = oc, Wo(n, 0), Ua(n, d), lr(n, vn()), u;
        switch (n.finishedWork = m, n.finishedLanes = d, i) {
          case 0:
          case 1:
            throw Error(s(345));
          case 2:
            Zl(n, Ur, pl);
            break;
          case 3:
            if (Ua(n, d), (d & 130023424) === d && (i = _f + 500 - vn(), 10 < i)) {
              if (ka(n, 0) !== 0)
                break;
              if (m = n.suspendedLanes, (m & d) !== d) {
                mr(), n.pingedLanes |= n.suspendedLanes & m;
                break;
              }
              n.timeoutHandle = Hs(Zl.bind(null, n, Ur, pl), i);
              break;
            }
            Zl(n, Ur, pl);
            break;
          case 4:
            if (Ua(n, d), (d & 4194240) === d)
              break;
            for (i = n.eventTimes, m = -1; 0 < d; ) {
              var _ = 31 - Ir(d);
              x = 1 << _, _ = i[_], _ > m && (m = _), d &= ~x;
            }
            if (d = m, d = vn() - d, d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * Rg(d / 1960)) - d, 10 < d) {
              n.timeoutHandle = Hs(Zl.bind(null, n, Ur, pl), d);
              break;
            }
            Zl(n, Ur, pl);
            break;
          case 5:
            Zl(n, Ur, pl);
            break;
          default:
            throw Error(s(329));
        }
      }
    }
    return lr(n, vn()), n.callbackNode === u ? Nf.bind(null, n) : null;
  }
  function Yo(n, i) {
    var u = Jl;
    return n.current.memoizedState.isDehydrated && (Wo(n, i).flags |= 256), n = zf(n, i), n !== 2 && (i = Ur, Ur = u, i !== null && mp(i)), n;
  }
  function mp(n) {
    Ur === null ? Ur = n : Ur.push.apply(Ur, n);
  }
  function yp(n) {
    for (var i = n; ; ) {
      if (i.flags & 16384) {
        var u = i.updateQueue;
        if (u !== null && (u = u.stores, u !== null))
          for (var d = 0; d < u.length; d++) {
            var m = u[d], x = m.getSnapshot;
            m = m.value;
            try {
              if (!ha(x(), m))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (u = i.child, i.subtreeFlags & 16384 && u !== null)
        u.return = i, i = u;
      else {
        if (i === n)
          break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === n)
            return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function Ua(n, i) {
    for (i &= ~hp, i &= ~Vu, n.suspendedLanes |= i, n.pingedLanes &= ~i, n = n.expirationTimes; 0 < i; ) {
      var u = 31 - Ir(i), d = 1 << u;
      n[u] = -1, i &= ~d;
    }
  }
  function Wu(n) {
    if (At & 6)
      throw Error(s(327));
    Qu();
    var i = ka(n, 0);
    if (!(i & 1))
      return lr(n, vn()), null;
    var u = zf(n, i);
    if (n.tag !== 0 && u === 2) {
      var d = Ta(n);
      d !== 0 && (i = d, u = Yo(n, d));
    }
    if (u === 1)
      throw u = oc, Wo(n, 0), Ua(n, i), lr(n, vn()), u;
    if (u === 6)
      throw Error(s(345));
    return n.finishedWork = n.current.alternate, n.finishedLanes = i, Zl(n, Ur, pl), lr(n, vn()), null;
  }
  function gp(n, i) {
    var u = At;
    At |= 1;
    try {
      return n(i);
    } finally {
      At = u, At === 0 && ($u = vn() + 500, Il && Ma());
    }
  }
  function Fa(n) {
    Xi !== null && Xi.tag === 0 && !(At & 6) && Qu();
    var i = At;
    At |= 1;
    var u = qi.transition, d = Ft;
    try {
      if (qi.transition = null, Ft = 1, n)
        return n();
    } finally {
      Ft = d, qi.transition = u, At = i, !(At & 6) && Ma();
    }
  }
  function Lf() {
    vi = Bu.current, et(Bu);
  }
  function Wo(n, i) {
    n.finishedWork = null, n.finishedLanes = 0;
    var u = n.timeoutHandle;
    if (u !== -1 && (n.timeoutHandle = -1, Is(u)), En !== null)
      for (u = En.return; u !== null; ) {
        var d = u;
        switch (Kc(d), d.tag) {
          case 1:
            d = d.type.childContextTypes, d != null && li();
            break;
          case 3:
            _u(), et(Ct), et(pr), Yi();
            break;
          case 5:
            ct(d);
            break;
          case 4:
            _u();
            break;
          case 13:
            et(nt);
            break;
          case 19:
            et(nt);
            break;
          case 10:
            Jd(d.type._context);
            break;
          case 22:
          case 23:
            Lf();
        }
        u = u.return;
      }
    if (Bn = n, En = n = eo(n.current, null), ir = vi = i, ar = 0, oc = null, hp = Vu = Vo = 0, Ur = Jl = null, Ar !== null) {
      for (i = 0; i < Ar.length; i++)
        if (u = Ar[i], d = u.interleaved, d !== null) {
          u.interleaved = null;
          var m = d.next, x = u.pending;
          if (x !== null) {
            var _ = x.next;
            x.next = m, d.next = _;
          }
          u.pending = d;
        }
      Ar = null;
    }
    return n;
  }
  function Bv(n, i) {
    do {
      var u = En;
      try {
        if (Kd(), Gs.current = yf, Qn) {
          for (var d = Nn.memoizedState; d !== null; ) {
            var m = d.queue;
            m !== null && (m.pending = null), d = d.next;
          }
          Qn = !1;
        }
        if (Lo = 0, fe = Wn = Nn = null, dt = !1, za = 0, Rf.current = null, u === null || u.return === null) {
          ar = 1, oc = i, En = null;
          break;
        }
        e: {
          var x = n, _ = u.return, z = u, P = i;
          if (i = ir, z.flags |= 32768, P !== null && typeof P == "object" && typeof P.then == "function") {
            var ee = P, ye = z, xe = ye.tag;
            if (!(ye.mode & 1) && (xe === 0 || xe === 11 || xe === 15)) {
              var ve = ye.alternate;
              ve ? (ye.updateQueue = ve.updateQueue, ye.memoizedState = ve.memoizedState, ye.lanes = ve.lanes) : (ye.updateQueue = null, ye.memoizedState = null);
            }
            var Pe = Lv(_);
            if (Pe !== null) {
              Pe.flags &= -257, op(Pe, _, z, x, i), Pe.mode & 1 && nc(x, ee, i), i = Pe, P = ee;
              var qe = i.updateQueue;
              if (qe === null) {
                var Ze = /* @__PURE__ */ new Set();
                Ze.add(P), i.updateQueue = Ze;
              } else
                qe.add(P);
              break e;
            } else {
              if (!(i & 1)) {
                nc(x, ee, i), cc();
                break e;
              }
              P = Error(s(426));
            }
          } else if (bn && z.mode & 1) {
            var Xn = Lv(_);
            if (Xn !== null) {
              !(Xn.flags & 65536) && (Xn.flags |= 256), op(Xn, _, z, x, i), tr(Xl(P, z));
              break e;
            }
          }
          x = P = Xl(P, z), ar !== 4 && (ar = 2), Jl === null ? Jl = [x] : Jl.push(x), x = _;
          do {
            switch (x.tag) {
              case 3:
                x.flags |= 65536, i &= -i, x.lanes |= i;
                var W = Mv(x, P, i);
                Ev(x, W);
                break e;
              case 1:
                z = P;
                var I = x.type, G = x.stateNode;
                if (!(x.flags & 128) && (typeof I.getDerivedStateFromError == "function" || G !== null && typeof G.componentDidCatch == "function" && (Gi === null || !Gi.has(G)))) {
                  x.flags |= 65536, i &= -i, x.lanes |= i;
                  var Te = Nv(x, z, i);
                  Ev(x, Te);
                  break e;
                }
            }
            x = x.return;
          } while (x !== null);
        }
        Yv(u);
      } catch (tt) {
        i = tt, En === u && u !== null && (En = u = u.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Vv() {
    var n = Bo.current;
    return Bo.current = yf, n === null ? yf : n;
  }
  function cc() {
    (ar === 0 || ar === 3 || ar === 2) && (ar = 4), Bn === null || !(Vo & 268435455) && !(Vu & 268435455) || Ua(Bn, ir);
  }
  function zf(n, i) {
    var u = At;
    At |= 2;
    var d = Vv();
    (Bn !== n || ir !== i) && (pl = null, Wo(n, i));
    do
      try {
        _g();
        break;
      } catch (m) {
        Bv(n, m);
      }
    while (!0);
    if (Kd(), At = u, Bo.current = d, En !== null)
      throw Error(s(261));
    return Bn = null, ir = 0, ar;
  }
  function _g() {
    for (; En !== null; )
      $v(En);
  }
  function Dg() {
    for (; En !== null && !Lr(); )
      $v(En);
  }
  function $v(n) {
    var i = qv(n.alternate, n, vi);
    n.memoizedProps = n.pendingProps, i === null ? Yv(n) : En = i, Rf.current = null;
  }
  function Yv(n) {
    var i = n;
    do {
      var u = i.alternate;
      if (n = i.return, i.flags & 32768) {
        if (u = wg(u, i), u !== null) {
          u.flags &= 32767, En = u;
          return;
        }
        if (n !== null)
          n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null;
        else {
          ar = 6, En = null;
          return;
        }
      } else if (u = Cg(u, i, vi), u !== null) {
        En = u;
        return;
      }
      if (i = i.sibling, i !== null) {
        En = i;
        return;
      }
      En = i = n;
    } while (i !== null);
    ar === 0 && (ar = 5);
  }
  function Zl(n, i, u) {
    var d = Ft, m = qi.transition;
    try {
      qi.transition = null, Ft = 1, Og(n, i, u, d);
    } finally {
      qi.transition = m, Ft = d;
    }
    return null;
  }
  function Og(n, i, u, d) {
    do
      Qu();
    while (Xi !== null);
    if (At & 6)
      throw Error(s(327));
    u = n.finishedWork;
    var m = n.finishedLanes;
    if (u === null)
      return null;
    if (n.finishedWork = null, n.finishedLanes = 0, u === n.current)
      throw Error(s(177));
    n.callbackNode = null, n.callbackPriority = 0;
    var x = u.lanes | u.childLanes;
    if (xs(n, x), n === Bn && (En = Bn = null, ir = 0), !(u.subtreeFlags & 2064) && !(u.flags & 2064) || Yu || (Yu = !0, Gv(Mt, function() {
      return Qu(), null;
    })), x = (u.flags & 15990) !== 0, u.subtreeFlags & 15990 || x) {
      x = qi.transition, qi.transition = null;
      var _ = Ft;
      Ft = 1;
      var z = At;
      At |= 4, Rf.current = null, kg(n, u), Hv(u, n), ko(Bd), fu = !!Id, Bd = Id = null, n.current = u, Tg(u), Ca(), At = z, Ft = _, qi.transition = x;
    } else
      n.current = u;
    if (Yu && (Yu = !1, Xi = n, Of = m), x = n.pendingLanes, x === 0 && (Gi = null), ms(u.stateNode), lr(n, vn()), i !== null)
      for (d = n.onRecoverableError, u = 0; u < i.length; u++)
        m = i[u], d(m.value, { componentStack: m.stack, digest: m.digest });
    if (Df)
      throw Df = !1, n = vp, vp = null, n;
    return Of & 1 && n.tag !== 0 && Qu(), x = n.pendingLanes, x & 1 ? n === Mf ? uc++ : (uc = 0, Mf = n) : uc = 0, Ma(), null;
  }
  function Qu() {
    if (Xi !== null) {
      var n = Es(Of), i = qi.transition, u = Ft;
      try {
        if (qi.transition = null, Ft = 16 > n ? 16 : n, Xi === null)
          var d = !1;
        else {
          if (n = Xi, Xi = null, Of = 0, At & 6)
            throw Error(s(331));
          var m = At;
          for (At |= 4, We = n.current; We !== null; ) {
            var x = We, _ = x.child;
            if (We.flags & 16) {
              var z = x.deletions;
              if (z !== null) {
                for (var P = 0; P < z.length; P++) {
                  var ee = z[P];
                  for (We = ee; We !== null; ) {
                    var ye = We;
                    switch (ye.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Uu(8, ye, x);
                    }
                    var xe = ye.child;
                    if (xe !== null)
                      xe.return = ye, We = xe;
                    else
                      for (; We !== null; ) {
                        ye = We;
                        var ve = ye.sibling, Pe = ye.return;
                        if (Fv(ye), ye === ee) {
                          We = null;
                          break;
                        }
                        if (ve !== null) {
                          ve.return = Pe, We = ve;
                          break;
                        }
                        We = Pe;
                      }
                  }
                }
                var qe = x.alternate;
                if (qe !== null) {
                  var Ze = qe.child;
                  if (Ze !== null) {
                    qe.child = null;
                    do {
                      var Xn = Ze.sibling;
                      Ze.sibling = null, Ze = Xn;
                    } while (Ze !== null);
                  }
                }
                We = x;
              }
            }
            if (x.subtreeFlags & 2064 && _ !== null)
              _.return = x, We = _;
            else
              e:
                for (; We !== null; ) {
                  if (x = We, x.flags & 2048)
                    switch (x.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Uu(9, x, x.return);
                    }
                  var W = x.sibling;
                  if (W !== null) {
                    W.return = x.return, We = W;
                    break e;
                  }
                  We = x.return;
                }
          }
          var I = n.current;
          for (We = I; We !== null; ) {
            _ = We;
            var G = _.child;
            if (_.subtreeFlags & 2064 && G !== null)
              G.return = _, We = G;
            else
              e:
                for (_ = I; We !== null; ) {
                  if (z = We, z.flags & 2048)
                    try {
                      switch (z.tag) {
                        case 0:
                        case 11:
                        case 15:
                          kf(9, z);
                      }
                    } catch (tt) {
                      Vn(z, z.return, tt);
                    }
                  if (z === _) {
                    We = null;
                    break e;
                  }
                  var Te = z.sibling;
                  if (Te !== null) {
                    Te.return = z.return, We = Te;
                    break e;
                  }
                  We = z.return;
                }
          }
          if (At = m, Ma(), ni && typeof ni.onPostCommitFiberRoot == "function")
            try {
              ni.onPostCommitFiberRoot(Ol, n);
            } catch {
            }
          d = !0;
        }
        return d;
      } finally {
        Ft = u, qi.transition = i;
      }
    }
    return !1;
  }
  function Wv(n, i, u) {
    i = Xl(u, i), i = Mv(n, i, 1), n = Wl(n, i, 1), i = mr(), n !== null && (Nl(n, 1, i), lr(n, i));
  }
  function Vn(n, i, u) {
    if (n.tag === 3)
      Wv(n, n, u);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          Wv(i, n, u);
          break;
        } else if (i.tag === 1) {
          var d = i.stateNode;
          if (typeof i.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (Gi === null || !Gi.has(d))) {
            n = Xl(u, n), n = Nv(i, n, 1), i = Wl(i, n, 1), n = mr(), i !== null && (Nl(i, 1, n), lr(i, n));
            break;
          }
        }
        i = i.return;
      }
  }
  function Mg(n, i, u) {
    var d = n.pingCache;
    d !== null && d.delete(i), i = mr(), n.pingedLanes |= n.suspendedLanes & u, Bn === n && (ir & u) === u && (ar === 4 || ar === 3 && (ir & 130023424) === ir && 500 > vn() - _f ? Wo(n, 0) : hp |= u), lr(n, i);
  }
  function Qv(n, i) {
    i === 0 && (n.mode & 1 ? (i = ou, ou <<= 1, !(ou & 130023424) && (ou = 4194304)) : i = 1);
    var u = mr();
    n = cl(n, i), n !== null && (Nl(n, i, u), lr(n, u));
  }
  function Sp(n) {
    var i = n.memoizedState, u = 0;
    i !== null && (u = i.retryLane), Qv(n, u);
  }
  function Ng(n, i) {
    var u = 0;
    switch (n.tag) {
      case 13:
        var d = n.stateNode, m = n.memoizedState;
        m !== null && (u = m.retryLane);
        break;
      case 19:
        d = n.stateNode;
        break;
      default:
        throw Error(s(314));
    }
    d !== null && d.delete(i), Qv(n, u);
  }
  var qv;
  qv = function(n, i, u) {
    if (n !== null)
      if (n.memoizedProps !== i.pendingProps || Ct.current)
        pi = !0;
      else {
        if (!(n.lanes & u) && !(i.flags & 128))
          return pi = !1, dl(n, i, u);
        pi = !!(n.flags & 131072);
      }
    else
      pi = !1, bn && i.flags & 1048576 && Vl(i, Oo, i.index);
    switch (i.lanes = 0, i.tag) {
      case 2:
        var d = i.type;
        ac(n, i), n = i.pendingProps;
        var m = ki(i, pr.current);
        Yn(i, u), m = zo(null, i, d, n, m, u);
        var x = ql();
        return i.flags |= 1, typeof m == "object" && m !== null && typeof m.render == "function" && m.$$typeof === void 0 ? (i.tag = 1, i.memoizedState = null, i.updateQueue = null, er(d) ? (x = !0, Do(i)) : x = !1, i.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, Zd(i), m.updater = tf, i.stateNode = m, m._reactInternals = i, tp(i, d, n, u), i = Sf(null, i, d, !0, x, u)) : (i.tag = 0, bn && x && Xc(i), qn(null, i, m, u), i = i.child), i;
      case 16:
        d = i.elementType;
        e: {
          switch (ac(n, i), n = i.pendingProps, m = d._init, d = m(d._payload), i.type = d, m = i.tag = Lg(d), n = ci(d, n), m) {
            case 0:
              i = Rt(null, i, d, n, u);
              break e;
            case 1:
              i = rc(null, i, d, n, u);
              break e;
            case 11:
              i = Nu(null, i, d, n, u);
              break e;
            case 14:
              i = Kl(null, i, d, ci(d.type, n), u);
              break e;
          }
          throw Error(s(
            306,
            d,
            ""
          ));
        }
        return i;
      case 0:
        return d = i.type, m = i.pendingProps, m = i.elementType === d ? m : ci(d, m), Rt(n, i, d, m, u);
      case 1:
        return d = i.type, m = i.pendingProps, m = i.elementType === d ? m : ci(d, m), rc(n, i, d, m, u);
      case 3:
        e: {
          if (Eg(i), n === null)
            throw Error(s(387));
          d = i.pendingProps, x = i.memoizedState, m = x.element, bv(n, i), Ys(i, d, null, u);
          var _ = i.memoizedState;
          if (d = _.element, x.isDehydrated)
            if (x = { element: d, isDehydrated: !1, cache: _.cache, pendingSuspenseBoundaries: _.pendingSuspenseBoundaries, transitions: _.transitions }, i.updateQueue.baseState = x, i.memoizedState = x, i.flags & 256) {
              m = Xl(Error(s(423)), i), i = Av(n, i, d, u, m);
              break e;
            } else if (d !== m) {
              m = Xl(Error(s(424)), i), i = Av(n, i, d, u, m);
              break e;
            } else
              for (Ri = wi(i.stateNode.containerInfo.firstChild), Ti = i, bn = !0, $i = null, u = _v(i, null, d, u), i.child = u; u; )
                u.flags = u.flags & -3 | 4096, u = u.sibling;
          else {
            if (bu(), d === m) {
              i = Gn(n, i, u);
              break e;
            }
            qn(n, i, d, u);
          }
          i = i.child;
        }
        return i;
      case 5:
        return nf(i), n === null && Jc(i), d = i.type, m = i.pendingProps, x = n !== null ? n.memoizedProps : null, _ = m.children, _o(d, m) ? _ = null : x !== null && _o(d, x) && (i.flags |= 32), Ho(n, i), qn(n, i, _, u), i.child;
      case 6:
        return n === null && Jc(i), null;
      case 13:
        return jv(n, i, u);
      case 4:
        return np(i, i.stateNode.containerInfo), d = i.pendingProps, n === null ? i.child = Tu(i, null, d, u) : qn(n, i, d, u), i.child;
      case 11:
        return d = i.type, m = i.pendingProps, m = i.elementType === d ? m : ci(d, m), Nu(n, i, d, m, u);
      case 7:
        return qn(n, i, i.pendingProps, u), i.child;
      case 8:
        return qn(n, i, i.pendingProps.children, u), i.child;
      case 12:
        return qn(n, i, i.pendingProps.children, u), i.child;
      case 10:
        e: {
          if (d = i.type._context, m = i.pendingProps, x = i.memoizedProps, _ = m.value, qt(Eu, d._currentValue), d._currentValue = _, x !== null)
            if (ha(x.value, _)) {
              if (x.children === m.children && !Ct.current) {
                i = Gn(n, i, u);
                break e;
              }
            } else
              for (x = i.child, x !== null && (x.return = i); x !== null; ) {
                var z = x.dependencies;
                if (z !== null) {
                  _ = x.child;
                  for (var P = z.firstContext; P !== null; ) {
                    if (P.context === d) {
                      if (x.tag === 1) {
                        P = mn(-1, u & -u), P.tag = 2;
                        var ee = x.updateQueue;
                        if (ee !== null) {
                          ee = ee.shared;
                          var ye = ee.pending;
                          ye === null ? P.next = P : (P.next = ye.next, ye.next = P), ee.pending = P;
                        }
                      }
                      x.lanes |= u, P = x.alternate, P !== null && (P.lanes |= u), $l(
                        x.return,
                        u,
                        i
                      ), z.lanes |= u;
                      break;
                    }
                    P = P.next;
                  }
                } else if (x.tag === 10)
                  _ = x.type === i.type ? null : x.child;
                else if (x.tag === 18) {
                  if (_ = x.return, _ === null)
                    throw Error(s(341));
                  _.lanes |= u, z = _.alternate, z !== null && (z.lanes |= u), $l(_, u, i), _ = x.sibling;
                } else
                  _ = x.child;
                if (_ !== null)
                  _.return = x;
                else
                  for (_ = x; _ !== null; ) {
                    if (_ === i) {
                      _ = null;
                      break;
                    }
                    if (x = _.sibling, x !== null) {
                      x.return = _.return, _ = x;
                      break;
                    }
                    _ = _.return;
                  }
                x = _;
              }
          qn(n, i, m.children, u), i = i.child;
        }
        return i;
      case 9:
        return m = i.type, d = i.pendingProps.children, Yn(i, u), m = Me(m), d = d(m), i.flags |= 1, qn(n, i, d, u), i.child;
      case 14:
        return d = i.type, m = ci(d, i.pendingProps), m = ci(d.type, m), Kl(n, i, d, m, u);
      case 15:
        return gf(n, i, i.type, i.pendingProps, u);
      case 17:
        return d = i.type, m = i.pendingProps, m = i.elementType === d ? m : ci(d, m), ac(n, i), i.tag = 1, er(d) ? (n = !0, Do(i)) : n = !1, Yn(i, u), wv(i, d, m), tp(i, d, m, u), Sf(null, i, d, !0, n, u);
      case 19:
        return sp(n, i, u);
      case 22:
        return hi(n, i, u);
    }
    throw Error(s(156, i.tag));
  };
  function Gv(n, i) {
    return pn(n, i);
  }
  function Xv(n, i, u, d) {
    this.tag = n, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Ki(n, i, u, d) {
    return new Xv(n, i, u, d);
  }
  function xp(n) {
    return n = n.prototype, !(!n || !n.isReactComponent);
  }
  function Lg(n) {
    if (typeof n == "function")
      return xp(n) ? 1 : 0;
    if (n != null) {
      if (n = n.$$typeof, n === ne)
        return 11;
      if (n === ge)
        return 14;
    }
    return 2;
  }
  function eo(n, i) {
    var u = n.alternate;
    return u === null ? (u = Ki(n.tag, i, n.key, n.mode), u.elementType = n.elementType, u.type = n.type, u.stateNode = n.stateNode, u.alternate = n, n.alternate = u) : (u.pendingProps = i, u.type = n.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = n.flags & 14680064, u.childLanes = n.childLanes, u.lanes = n.lanes, u.child = n.child, u.memoizedProps = n.memoizedProps, u.memoizedState = n.memoizedState, u.updateQueue = n.updateQueue, i = n.dependencies, u.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, u.sibling = n.sibling, u.index = n.index, u.ref = n.ref, u;
  }
  function Af(n, i, u, d, m, x) {
    var _ = 2;
    if (d = n, typeof n == "function")
      xp(n) && (_ = 1);
    else if (typeof n == "string")
      _ = 5;
    else
      e:
        switch (n) {
          case Oe:
            return Qo(u.children, m, x, i);
          case ze:
            _ = 8, m |= 8;
            break;
          case it:
            return n = Ki(12, u, i, m | 2), n.elementType = it, n.lanes = x, n;
          case we:
            return n = Ki(13, u, i, m), n.elementType = we, n.lanes = x, n;
          case de:
            return n = Ki(19, u, i, m), n.elementType = de, n.lanes = x, n;
          case Fe:
            return jf(u, m, x, i);
          default:
            if (typeof n == "object" && n !== null)
              switch (n.$$typeof) {
                case lt:
                  _ = 10;
                  break e;
                case he:
                  _ = 9;
                  break e;
                case ne:
                  _ = 11;
                  break e;
                case ge:
                  _ = 14;
                  break e;
                case Qe:
                  _ = 16, d = null;
                  break e;
              }
            throw Error(s(130, n == null ? n : typeof n, ""));
        }
    return i = Ki(_, u, i, m), i.elementType = n, i.type = d, i.lanes = x, i;
  }
  function Qo(n, i, u, d) {
    return n = Ki(7, n, d, i), n.lanes = u, n;
  }
  function jf(n, i, u, d) {
    return n = Ki(22, n, d, i), n.elementType = Fe, n.lanes = u, n.stateNode = { isHidden: !1 }, n;
  }
  function Uf(n, i, u) {
    return n = Ki(6, n, null, i), n.lanes = u, n;
  }
  function fc(n, i, u) {
    return i = Ki(4, n.children !== null ? n.children : [], n.key, i), i.lanes = u, i.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, i;
  }
  function dc(n, i, u, d, m) {
    this.tag = i, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = bo(0), this.expirationTimes = bo(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = bo(0), this.identifierPrefix = d, this.onRecoverableError = m, this.mutableSourceEagerHydrationData = null;
  }
  function bp(n, i, u, d, m, x, _, z, P) {
    return n = new dc(n, i, u, z, P), i === 1 ? (i = 1, x === !0 && (i |= 8)) : i = 0, x = Ki(3, null, null, i), n.current = x, x.stateNode = n, x.memoizedState = { element: d, isDehydrated: u, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Zd(x), n;
  }
  function Kv(n, i, u) {
    var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: Y, key: d == null ? null : "" + d, children: n, containerInfo: i, implementation: u };
  }
  function Ep(n) {
    if (!n)
      return Ii;
    n = n._reactInternals;
    e: {
      if (je(n) !== n || n.tag !== 1)
        throw Error(s(170));
      var i = n;
      do {
        switch (i.tag) {
          case 3:
            i = i.stateNode.context;
            break e;
          case 1:
            if (er(i.type)) {
              i = i.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        i = i.return;
      } while (i !== null);
      throw Error(s(171));
    }
    if (n.tag === 1) {
      var u = n.type;
      if (er(u))
        return Hl(n, u, i);
    }
    return i;
  }
  function Cp(n, i, u, d, m, x, _, z, P) {
    return n = bp(u, d, !0, n, m, x, _, z, P), n.context = Ep(null), u = n.current, d = mr(), m = hl(u), x = mn(d, m), x.callback = i ?? null, Wl(u, x, m), n.current.lanes = m, Nl(n, m, d), lr(n, d), n;
  }
  function Ff(n, i, u, d) {
    var m = i.current, x = mr(), _ = hl(m);
    return u = Ep(u), i.context === null ? i.context = u : i.pendingContext = u, i = mn(x, _), i.payload = { element: n }, d = d === void 0 ? null : d, d !== null && (i.callback = d), n = Wl(m, i, _), n !== null && (Ln(n, m, _, x), ef(n, m, _)), _;
  }
  function pc(n) {
    if (n = n.current, !n.child)
      return null;
    switch (n.child.tag) {
      case 5:
        return n.child.stateNode;
      default:
        return n.child.stateNode;
    }
  }
  function Jv(n, i) {
    if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
      var u = n.retryLane;
      n.retryLane = u !== 0 && u < i ? u : i;
    }
  }
  function wp(n, i) {
    Jv(n, i), (n = n.alternate) && Jv(n, i);
  }
  function zg() {
    return null;
  }
  var kp = typeof reportError == "function" ? reportError : function(n) {
    console.error(n);
  };
  function Pf(n) {
    this._internalRoot = n;
  }
  hc.prototype.render = Pf.prototype.render = function(n) {
    var i = this._internalRoot;
    if (i === null)
      throw Error(s(409));
    Ff(n, i, null, null);
  }, hc.prototype.unmount = Pf.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
      this._internalRoot = null;
      var i = n.containerInfo;
      Fa(function() {
        Ff(null, n, null, null);
      }), i[va] = null;
    }
  };
  function hc(n) {
    this._internalRoot = n;
  }
  hc.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
      var i = Vt();
      n = { blockedOn: null, target: n, priority: i };
      for (var u = 0; u < Sn.length && i !== 0 && i < Sn[u].priority; u++)
        ;
      Sn.splice(u, 0, n), u === 0 && da(n);
    }
  };
  function to(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
  }
  function Hf(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "));
  }
  function Zv() {
  }
  function Ag(n, i, u, d, m) {
    if (m) {
      if (typeof d == "function") {
        var x = d;
        d = function() {
          var ee = pc(_);
          x.call(ee);
        };
      }
      var _ = Cp(i, d, n, 0, null, !1, !1, "", Zv);
      return n._reactRootContainer = _, n[va] = _.current, _a(n.nodeType === 8 ? n.parentNode : n), Fa(), _;
    }
    for (; m = n.lastChild; )
      n.removeChild(m);
    if (typeof d == "function") {
      var z = d;
      d = function() {
        var ee = pc(P);
        z.call(ee);
      };
    }
    var P = bp(n, 0, !1, null, null, !1, !1, "", Zv);
    return n._reactRootContainer = P, n[va] = P.current, _a(n.nodeType === 8 ? n.parentNode : n), Fa(function() {
      Ff(i, P, u, d);
    }), P;
  }
  function If(n, i, u, d, m) {
    var x = u._reactRootContainer;
    if (x) {
      var _ = x;
      if (typeof m == "function") {
        var z = m;
        m = function() {
          var P = pc(_);
          z.call(P);
        };
      }
      Ff(i, _, n, m);
    } else
      _ = Ag(u, i, n, m, d);
    return pc(_);
  }
  uu = function(n) {
    switch (n.tag) {
      case 3:
        var i = n.stateNode;
        if (i.current.memoizedState.isDehydrated) {
          var u = Ka(i.pendingLanes);
          u !== 0 && (bs(i, u | 1), lr(i, vn()), !(At & 6) && ($u = vn() + 500, Ma()));
        }
        break;
      case 13:
        Fa(function() {
          var d = cl(n, 1);
          if (d !== null) {
            var m = mr();
            Ln(d, n, 1, m);
          }
        }), wp(n, 1);
    }
  }, Ll = function(n) {
    if (n.tag === 13) {
      var i = cl(n, 134217728);
      if (i !== null) {
        var u = mr();
        Ln(i, n, 134217728, u);
      }
      wp(n, 134217728);
    }
  }, Cs = function(n) {
    if (n.tag === 13) {
      var i = hl(n), u = cl(n, i);
      if (u !== null) {
        var d = mr();
        Ln(u, n, i, d);
      }
      wp(n, i);
    }
  }, Vt = function() {
    return Ft;
  }, su = function(n, i) {
    var u = Ft;
    try {
      return Ft = n, i();
    } finally {
      Ft = u;
    }
  }, tn = function(n, i, u) {
    switch (i) {
      case "input":
        if (Dn(n, u), i = u.name, u.type === "radio" && i != null) {
          for (u = n; u.parentNode; )
            u = u.parentNode;
          for (u = u.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'), i = 0; i < u.length; i++) {
            var d = u[i];
            if (d !== n && d.form === n.form) {
              var m = qc(d);
              if (!m)
                throw Error(s(90));
              Mr(d), Dn(d, m);
            }
          }
        }
        break;
      case "textarea":
        fr(n, u);
        break;
      case "select":
        i = u.value, i != null && $n(n, !!u.multiple, i, !1);
    }
  }, _l = gp, mo = Fa;
  var jg = { usingClientEntryPoint: !1, Events: [Da, xu, qc, ua, Ai, gp] }, vc = { findFiberByHostInstance: ul, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, em = { bundleType: vc.bundleType, version: vc.version, rendererPackageName: vc.rendererPackageName, rendererConfig: vc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Se.ReactCurrentDispatcher, findHostInstanceByFiber: function(n) {
    return n = ot(n), n === null ? null : n.stateNode;
  }, findFiberByHostInstance: vc.findFiberByHostInstance || zg, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Bf = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Bf.isDisabled && Bf.supportsFiber)
      try {
        Ol = Bf.inject(em), ni = Bf;
      } catch {
      }
  }
  return ra.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = jg, ra.createPortal = function(n, i) {
    var u = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!to(i))
      throw Error(s(200));
    return Kv(n, i, null, u);
  }, ra.createRoot = function(n, i) {
    if (!to(n))
      throw Error(s(299));
    var u = !1, d = "", m = kp;
    return i != null && (i.unstable_strictMode === !0 && (u = !0), i.identifierPrefix !== void 0 && (d = i.identifierPrefix), i.onRecoverableError !== void 0 && (m = i.onRecoverableError)), i = bp(n, 1, !1, null, null, u, !1, d, m), n[va] = i.current, _a(n.nodeType === 8 ? n.parentNode : n), new Pf(i);
  }, ra.findDOMNode = function(n) {
    if (n == null)
      return null;
    if (n.nodeType === 1)
      return n;
    var i = n._reactInternals;
    if (i === void 0)
      throw typeof n.render == "function" ? Error(s(188)) : (n = Object.keys(n).join(","), Error(s(268, n)));
    return n = ot(i), n = n === null ? null : n.stateNode, n;
  }, ra.flushSync = function(n) {
    return Fa(n);
  }, ra.hydrate = function(n, i, u) {
    if (!Hf(i))
      throw Error(s(200));
    return If(null, n, i, !0, u);
  }, ra.hydrateRoot = function(n, i, u) {
    if (!to(n))
      throw Error(s(405));
    var d = u != null && u.hydratedSources || null, m = !1, x = "", _ = kp;
    if (u != null && (u.unstable_strictMode === !0 && (m = !0), u.identifierPrefix !== void 0 && (x = u.identifierPrefix), u.onRecoverableError !== void 0 && (_ = u.onRecoverableError)), i = Cp(i, null, n, 1, u ?? null, m, !1, x, _), n[va] = i.current, _a(n), d)
      for (n = 0; n < d.length; n++)
        u = d[n], m = u._getVersion, m = m(u._source), i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [u, m] : i.mutableSourceEagerHydrationData.push(
          u,
          m
        );
    return new hc(i);
  }, ra.render = function(n, i, u) {
    if (!Hf(i))
      throw Error(s(200));
    return If(null, n, i, !1, u);
  }, ra.unmountComponentAtNode = function(n) {
    if (!Hf(n))
      throw Error(s(40));
    return n._reactRootContainer ? (Fa(function() {
      If(null, null, n, !1, function() {
        n._reactRootContainer = null, n[va] = null;
      });
    }), !0) : !1;
  }, ra.unstable_batchedUpdates = gp, ra.unstable_renderSubtreeIntoContainer = function(n, i, u, d) {
    if (!Hf(u))
      throw Error(s(200));
    if (n == null || n._reactInternals === void 0)
      throw Error(s(38));
    return If(n, i, u, !1, d);
  }, ra.version = "18.2.0-next-9e3b772b8-20220608", ra;
}
var ia = {}, gw;
function NN() {
  if (gw)
    return ia;
  gw = 1;
  var r = {};
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return r.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var o = ut, s = Mk(), f = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, h = !1;
    function y(e) {
      h = e;
    }
    function S(e) {
      if (!h) {
        for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), l = 1; l < t; l++)
          a[l - 1] = arguments[l];
        w("warn", e, a);
      }
    }
    function v(e) {
      if (!h) {
        for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), l = 1; l < t; l++)
          a[l - 1] = arguments[l];
        w("error", e, a);
      }
    }
    function w(e, t, a) {
      {
        var l = f.ReactDebugCurrentFrame, c = l.getStackAddendum();
        c !== "" && (t += "%s", a = a.concat([c]));
        var p = a.map(function(g) {
          return String(g);
        });
        p.unshift("Warning: " + t), Function.prototype.apply.call(console[e], console, p);
      }
    }
    var E = 0, R = 1, D = 2, N = 3, M = 4, F = 5, $ = 6, ce = 7, X = 8, se = 9, te = 10, Se = 11, Ce = 12, Y = 13, Oe = 14, ze = 15, it = 16, lt = 17, he = 18, ne = 19, we = 21, de = 22, ge = 23, Qe = 24, Fe = 25, ae = !0, _e = !1, T = !1, ue = !1, Ae = !1, A = !0, Ke = !1, bt = !1, at = !0, _t = !0, mt = !0, Qt = /* @__PURE__ */ new Set(), wn = {}, An = {};
    function Mr(e, t) {
      sr(e, t), sr(e + "Capture", t);
    }
    function sr(e, t) {
      wn[e] && v("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), wn[e] = t;
      {
        var a = e.toLowerCase();
        An[a] = e, e === "onDoubleClick" && (An.ondblclick = e);
      }
      for (var l = 0; l < t.length; l++)
        Qt.add(t[l]);
    }
    var kn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Jn = Object.prototype.hasOwnProperty;
    function jn(e) {
      {
        var t = typeof Symbol == "function" && Symbol.toStringTag, a = t && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return a;
      }
    }
    function Dn(e) {
      try {
        return Un(e), !1;
      } catch {
        return !0;
      }
    }
    function Un(e) {
      return "" + e;
    }
    function cr(e, t) {
      if (Dn(e))
        return v("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", t, jn(e)), Un(e);
    }
    function rr(e) {
      if (Dn(e))
        return v("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", jn(e)), Un(e);
    }
    function $n(e, t) {
      if (Dn(e))
        return v("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", t, jn(e)), Un(e);
    }
    function Fr(e, t) {
      if (Dn(e))
        return v("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", t, jn(e)), Un(e);
    }
    function Pr(e) {
      if (Dn(e))
        return v("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", jn(e)), Un(e);
    }
    function fr(e) {
      if (Dn(e))
        return v("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", jn(e)), Un(e);
    }
    var Hr = 0, re = 1, Ee = 2, $e = 3, yt = 4, Ot = 5, gn = 6, De = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ye = De + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", St = new RegExp("^[" + De + "][" + Ye + "]*$"), Ut = {}, Et = {};
    function on(e) {
      return Jn.call(Et, e) ? !0 : Jn.call(Ut, e) ? !1 : St.test(e) ? (Et[e] = !0, !0) : (Ut[e] = !0, v("Invalid attribute name: `%s`", e), !1);
    }
    function Yt(e, t, a) {
      return t !== null ? t.type === Hr : a ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function Nr(e, t, a, l) {
      if (a !== null && a.type === Hr)
        return !1;
      switch (typeof t) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (l)
            return !1;
          if (a !== null)
            return !a.acceptsBooleans;
          var c = e.toLowerCase().slice(0, 5);
          return c !== "data-" && c !== "aria-";
        }
        default:
          return !1;
      }
    }
    function tn(e, t, a, l) {
      if (t === null || typeof t > "u" || Nr(e, t, a, l))
        return !0;
      if (l)
        return !1;
      if (a !== null)
        switch (a.type) {
          case $e:
            return !t;
          case yt:
            return t === !1;
          case Ot:
            return isNaN(t);
          case gn:
            return isNaN(t) || t < 1;
        }
      return !1;
    }
    function dr(e) {
      return dn.hasOwnProperty(e) ? dn[e] : null;
    }
    function Jt(e, t, a, l, c, p, g) {
      this.acceptsBooleans = t === Ee || t === $e || t === yt, this.attributeName = l, this.attributeNamespace = c, this.mustUseProperty = a, this.propertyName = e, this.type = t, this.sanitizeURL = p, this.removeEmptyString = g;
    }
    var dn = {}, ua = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ua.forEach(function(e) {
      dn[e] = new Jt(
        e,
        Hr,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var t = e[0], a = e[1];
      dn[t] = new Jt(
        t,
        re,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      dn[e] = new Jt(
        e,
        Ee,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      dn[e] = new Jt(
        e,
        Ee,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      dn[e] = new Jt(
        e,
        $e,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      dn[e] = new Jt(
        e,
        $e,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      dn[e] = new Jt(
        e,
        yt,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      dn[e] = new Jt(
        e,
        gn,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      dn[e] = new Jt(
        e,
        Ot,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ai = /[\-\:]([a-z])/g, _l = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(Ai, _l);
      dn[t] = new Jt(
        t,
        re,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(Ai, _l);
      dn[t] = new Jt(
        t,
        re,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(Ai, _l);
      dn[t] = new Jt(
        t,
        re,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      dn[e] = new Jt(
        e,
        re,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var mo = "xlinkHref";
    dn[mo] = new Jt(
      "xlinkHref",
      re,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      dn[e] = new Jt(
        e,
        re,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var yo = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Dl = !1;
    function sa(e) {
      !Dl && yo.test(e) && (Dl = !0, v("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function ca(e, t, a, l) {
      if (l.mustUseProperty) {
        var c = l.propertyName;
        return e[c];
      } else {
        cr(a, t), l.sanitizeURL && sa("" + a);
        var p = l.attributeName, g = null;
        if (l.type === yt) {
          if (e.hasAttribute(p)) {
            var b = e.getAttribute(p);
            return b === "" ? !0 : tn(t, a, l, !1) ? b : b === "" + a ? a : b;
          }
        } else if (e.hasAttribute(p)) {
          if (tn(t, a, l, !1))
            return e.getAttribute(p);
          if (l.type === $e)
            return a;
          g = e.getAttribute(p);
        }
        return tn(t, a, l, !1) ? g === null ? a : g : g === "" + a ? a : g;
      }
    }
    function ji(e, t, a, l) {
      {
        if (!on(t))
          return;
        if (!e.hasAttribute(t))
          return a === void 0 ? void 0 : null;
        var c = e.getAttribute(t);
        return cr(a, t), c === "" + a ? a : c;
      }
    }
    function qa(e, t, a, l) {
      var c = dr(t);
      if (!Yt(t, c, l)) {
        if (tn(t, a, c, l) && (a = null), l || c === null) {
          if (on(t)) {
            var p = t;
            a === null ? e.removeAttribute(p) : (cr(a, t), e.setAttribute(p, "" + a));
          }
          return;
        }
        var g = c.mustUseProperty;
        if (g) {
          var b = c.propertyName;
          if (a === null) {
            var C = c.type;
            e[b] = C === $e ? !1 : "";
          } else
            e[b] = a;
          return;
        }
        var O = c.attributeName, L = c.attributeNamespace;
        if (a === null)
          e.removeAttribute(O);
        else {
          var B = c.type, H;
          B === $e || B === yt && a === !0 ? H = "" : (cr(a, O), H = "" + a, c.sanitizeURL && sa(H.toString())), L ? e.setAttributeNS(L, O, H) : e.setAttribute(O, H);
        }
      }
    }
    var Zr = Symbol.for("react.element"), ei = Symbol.for("react.portal"), Ei = Symbol.for("react.fragment"), Ga = Symbol.for("react.strict_mode"), U = Symbol.for("react.profiler"), me = Symbol.for("react.provider"), Ne = Symbol.for("react.context"), je = Symbol.for("react.forward_ref"), zt = Symbol.for("react.suspense"), Pt = Symbol.for("react.suspense_list"), Dt = Symbol.for("react.memo"), ot = Symbol.for("react.lazy"), Zn = Symbol.for("react.scope"), pn = Symbol.for("react.debug_trace_mode"), hn = Symbol.for("react.offscreen"), Lr = Symbol.for("react.legacy_hidden"), Ca = Symbol.for("react.cache"), vn = Symbol.for("react.tracing_marker"), ti = Symbol.iterator, vs = "@@iterator";
    function wa(e) {
      if (e === null || typeof e != "object")
        return null;
      var t = ti && e[ti] || e[vs];
      return typeof t == "function" ? t : null;
    }
    var Mt = Object.assign, go = 0, Xa, Ol, ni, ms, Ir, ys, gs;
    function Ss() {
    }
    Ss.__reactDisabledLog = !0;
    function So() {
      {
        if (go === 0) {
          Xa = console.log, Ol = console.info, ni = console.warn, ms = console.error, Ir = console.group, ys = console.groupCollapsed, gs = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: Ss,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        go++;
      }
    }
    function ou() {
      {
        if (go--, go === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Mt({}, e, {
              value: Xa
            }),
            info: Mt({}, e, {
              value: Ol
            }),
            warn: Mt({}, e, {
              value: ni
            }),
            error: Mt({}, e, {
              value: ms
            }),
            group: Mt({}, e, {
              value: Ir
            }),
            groupCollapsed: Mt({}, e, {
              value: ys
            }),
            groupEnd: Mt({}, e, {
              value: gs
            })
          });
        }
        go < 0 && v("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ka = f.ReactCurrentDispatcher, ka;
    function Ui(e, t, a) {
      {
        if (ka === void 0)
          try {
            throw Error();
          } catch (c) {
            var l = c.stack.trim().match(/\n( *(at )?)/);
            ka = l && l[1] || "";
          }
        return `
` + ka + e;
      }
    }
    var Ml = !1, Ta;
    {
      var xo = typeof WeakMap == "function" ? WeakMap : Map;
      Ta = new xo();
    }
    function bo(e, t) {
      if (!e || Ml)
        return "";
      {
        var a = Ta.get(e);
        if (a !== void 0)
          return a;
      }
      var l;
      Ml = !0;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var p;
      p = Ka.current, Ka.current = null, So();
      try {
        if (t) {
          var g = function() {
            throw Error();
          };
          if (Object.defineProperty(g.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(g, []);
            } catch (Z) {
              l = Z;
            }
            Reflect.construct(e, [], g);
          } else {
            try {
              g.call();
            } catch (Z) {
              l = Z;
            }
            e.call(g.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Z) {
            l = Z;
          }
          e();
        }
      } catch (Z) {
        if (Z && l && typeof Z.stack == "string") {
          for (var b = Z.stack.split(`
`), C = l.stack.split(`
`), O = b.length - 1, L = C.length - 1; O >= 1 && L >= 0 && b[O] !== C[L]; )
            L--;
          for (; O >= 1 && L >= 0; O--, L--)
            if (b[O] !== C[L]) {
              if (O !== 1 || L !== 1)
                do
                  if (O--, L--, L < 0 || b[O] !== C[L]) {
                    var B = `
` + b[O].replace(" at new ", " at ");
                    return e.displayName && B.includes("<anonymous>") && (B = B.replace("<anonymous>", e.displayName)), typeof e == "function" && Ta.set(e, B), B;
                  }
                while (O >= 1 && L >= 0);
              break;
            }
        }
      } finally {
        Ml = !1, Ka.current = p, ou(), Error.prepareStackTrace = c;
      }
      var H = e ? e.displayName || e.name : "", J = H ? Ui(H) : "";
      return typeof e == "function" && Ta.set(e, J), J;
    }
    function Nl(e, t, a) {
      return bo(e, !0);
    }
    function xs(e, t, a) {
      return bo(e, !1);
    }
    function bs(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function Ft(e, t, a) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return bo(e, bs(e));
      if (typeof e == "string")
        return Ui(e);
      switch (e) {
        case zt:
          return Ui("Suspense");
        case Pt:
          return Ui("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case je:
            return xs(e.render);
          case Dt:
            return Ft(e.type, t, a);
          case ot: {
            var l = e, c = l._payload, p = l._init;
            try {
              return Ft(p(c), t, a);
            } catch {
            }
          }
        }
      return "";
    }
    function Es(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case F:
          return Ui(e.type);
        case it:
          return Ui("Lazy");
        case Y:
          return Ui("Suspense");
        case ne:
          return Ui("SuspenseList");
        case E:
        case D:
        case ze:
          return xs(e.type);
        case Se:
          return xs(e.type.render);
        case R:
          return Nl(e.type);
        default:
          return "";
      }
    }
    function uu(e) {
      try {
        var t = "", a = e;
        do
          t += Es(a), a = a.return;
        while (a);
        return t;
      } catch (l) {
        return `
Error generating stack: ` + l.message + `
` + l.stack;
      }
    }
    function Ll(e, t, a) {
      var l = e.displayName;
      if (l)
        return l;
      var c = t.displayName || t.name || "";
      return c !== "" ? a + "(" + c + ")" : a;
    }
    function Cs(e) {
      return e.displayName || "Context";
    }
    function Vt(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && v("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case Ei:
          return "Fragment";
        case ei:
          return "Portal";
        case U:
          return "Profiler";
        case Ga:
          return "StrictMode";
        case zt:
          return "Suspense";
        case Pt:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case Ne:
            var t = e;
            return Cs(t) + ".Consumer";
          case me:
            var a = e;
            return Cs(a._context) + ".Provider";
          case je:
            return Ll(e, e.render, "ForwardRef");
          case Dt:
            var l = e.displayName || null;
            return l !== null ? l : Vt(e.type) || "Memo";
          case ot: {
            var c = e, p = c._payload, g = c._init;
            try {
              return Vt(g(p));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function su(e, t, a) {
      var l = t.displayName || t.name || "";
      return e.displayName || (l !== "" ? a + "(" + l + ")" : a);
    }
    function Eo(e) {
      return e.displayName || "Context";
    }
    function xt(e) {
      var t = e.tag, a = e.type;
      switch (t) {
        case Qe:
          return "Cache";
        case se:
          var l = a;
          return Eo(l) + ".Consumer";
        case te:
          var c = a;
          return Eo(c._context) + ".Provider";
        case he:
          return "DehydratedFragment";
        case Se:
          return su(a, a.render, "ForwardRef");
        case ce:
          return "Fragment";
        case F:
          return a;
        case M:
          return "Portal";
        case N:
          return "Root";
        case $:
          return "Text";
        case it:
          return Vt(a);
        case X:
          return a === Ga ? "StrictMode" : "Mode";
        case de:
          return "Offscreen";
        case Ce:
          return "Profiler";
        case we:
          return "Scope";
        case Y:
          return "Suspense";
        case ne:
          return "SuspenseList";
        case Fe:
          return "TracingMarker";
        case R:
        case E:
        case lt:
        case D:
        case Oe:
        case ze:
          if (typeof a == "function")
            return a.displayName || a.name || null;
          if (typeof a == "string")
            return a;
          break;
      }
      return null;
    }
    var fa = f.ReactDebugCurrentFrame, On = null, ri = !1;
    function Fi() {
      {
        if (On === null)
          return null;
        var e = On._debugOwner;
        if (e !== null && typeof e < "u")
          return xt(e);
      }
      return null;
    }
    function zl() {
      return On === null ? "" : uu(On);
    }
    function Sn() {
      fa.getCurrentStack = null, On = null, ri = !1;
    }
    function Mn(e) {
      fa.getCurrentStack = e === null ? null : zl, On = e, ri = !1;
    }
    function ws() {
      return On;
    }
    function Sr(e) {
      ri = e;
    }
    function ii(e) {
      return "" + e;
    }
    function da(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return fr(e), e;
        default:
          return "";
      }
    }
    var cu = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Co(e, t) {
      cu[t.type] || t.onChange || t.onInput || t.readOnly || t.disabled || t.value == null || v("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), t.onChange || t.readOnly || t.disabled || t.checked == null || v("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function wo(e) {
      var t = e.type, a = e.nodeName;
      return a && a.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
    }
    function Al(e) {
      return e._valueTracker;
    }
    function Pi(e) {
      e._valueTracker = null;
    }
    function Ja(e) {
      var t = "";
      return e && (wo(e) ? t = e.checked ? "true" : "false" : t = e.value), t;
    }
    function fu(e) {
      var t = wo(e) ? "checked" : "value", a = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);
      fr(e[t]);
      var l = "" + e[t];
      if (!(e.hasOwnProperty(t) || typeof a > "u" || typeof a.get != "function" || typeof a.set != "function")) {
        var c = a.get, p = a.set;
        Object.defineProperty(e, t, {
          configurable: !0,
          get: function() {
            return c.call(this);
          },
          set: function(b) {
            fr(b), l = "" + b, p.call(this, b);
          }
        }), Object.defineProperty(e, t, {
          enumerable: a.enumerable
        });
        var g = {
          getValue: function() {
            return l;
          },
          setValue: function(b) {
            fr(b), l = "" + b;
          },
          stopTracking: function() {
            Pi(e), delete e[t];
          }
        };
        return g;
      }
    }
    function Za(e) {
      Al(e) || (e._valueTracker = fu(e));
    }
    function du(e) {
      if (!e)
        return !1;
      var t = Al(e);
      if (!t)
        return !0;
      var a = t.getValue(), l = Ja(e);
      return l !== a ? (t.setValue(l), !0) : !1;
    }
    function Ra(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var el = !1, pu = !1, ks = !1, pa = !1;
    function hu(e) {
      var t = e.type === "checkbox" || e.type === "radio";
      return t ? e.checked != null : e.value != null;
    }
    function k(e, t) {
      var a = e, l = t.checked, c = Mt({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: l ?? a._wrapperState.initialChecked
      });
      return c;
    }
    function j(e, t) {
      Co("input", t), t.checked !== void 0 && t.defaultChecked !== void 0 && !pu && (v("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fi() || "A component", t.type), pu = !0), t.value !== void 0 && t.defaultValue !== void 0 && !el && (v("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fi() || "A component", t.type), el = !0);
      var a = e, l = t.defaultValue == null ? "" : t.defaultValue;
      a._wrapperState = {
        initialChecked: t.checked != null ? t.checked : t.defaultChecked,
        initialValue: da(t.value != null ? t.value : l),
        controlled: hu(t)
      };
    }
    function K(e, t) {
      var a = e, l = t.checked;
      l != null && qa(a, "checked", l, !1);
    }
    function ie(e, t) {
      var a = e;
      {
        var l = hu(t);
        !a._wrapperState.controlled && l && !pa && (v("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), pa = !0), a._wrapperState.controlled && !l && !ks && (v("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), ks = !0);
      }
      K(e, t);
      var c = da(t.value), p = t.type;
      if (c != null)
        p === "number" ? (c === 0 && a.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        a.value != c) && (a.value = ii(c)) : a.value !== ii(c) && (a.value = ii(c));
      else if (p === "submit" || p === "reset") {
        a.removeAttribute("value");
        return;
      }
      t.hasOwnProperty("value") ? vt(a, t.type, c) : t.hasOwnProperty("defaultValue") && vt(a, t.type, da(t.defaultValue)), t.checked == null && t.defaultChecked != null && (a.defaultChecked = !!t.defaultChecked);
    }
    function ke(e, t, a) {
      var l = e;
      if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var c = t.type, p = c === "submit" || c === "reset";
        if (p && (t.value === void 0 || t.value === null))
          return;
        var g = ii(l._wrapperState.initialValue);
        a || g !== l.value && (l.value = g), l.defaultValue = g;
      }
      var b = l.name;
      b !== "" && (l.name = ""), l.defaultChecked = !l.defaultChecked, l.defaultChecked = !!l._wrapperState.initialChecked, b !== "" && (l.name = b);
    }
    function Je(e, t) {
      var a = e;
      ie(a, t), Ie(a, t);
    }
    function Ie(e, t) {
      var a = t.name;
      if (t.type === "radio" && a != null) {
        for (var l = e; l.parentNode; )
          l = l.parentNode;
        cr(a, "name");
        for (var c = l.querySelectorAll("input[name=" + JSON.stringify("" + a) + '][type="radio"]'), p = 0; p < c.length; p++) {
          var g = c[p];
          if (!(g === e || g.form !== e.form)) {
            var b = ym(g);
            if (!b)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            du(g), ie(g, b);
          }
        }
      }
    }
    function vt(e, t, a) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (t !== "number" || Ra(e.ownerDocument) !== e) && (a == null ? e.defaultValue = ii(e._wrapperState.initialValue) : e.defaultValue !== ii(a) && (e.defaultValue = ii(a)));
    }
    var Nt = !1, Zt = !1, nn = !1;
    function rn(e, t) {
      t.value == null && (typeof t.children == "object" && t.children !== null ? o.Children.forEach(t.children, function(a) {
        a != null && (typeof a == "string" || typeof a == "number" || Zt || (Zt = !0, v("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : t.dangerouslySetInnerHTML != null && (nn || (nn = !0, v("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), t.selected != null && !Nt && (v("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Nt = !0);
    }
    function an(e, t) {
      t.value != null && e.setAttribute("value", ii(da(t.value)));
    }
    var xn = Array.isArray;
    function $t(e) {
      return xn(e);
    }
    var jl;
    jl = !1;
    function vu() {
      var e = Fi();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var Ts = ["value", "defaultValue"];
    function Rs(e) {
      {
        Co("select", e);
        for (var t = 0; t < Ts.length; t++) {
          var a = Ts[t];
          if (e[a] != null) {
            var l = $t(e[a]);
            e.multiple && !l ? v("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", a, vu()) : !e.multiple && l && v("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", a, vu());
          }
        }
      }
    }
    function tl(e, t, a, l) {
      var c = e.options;
      if (t) {
        for (var p = a, g = {}, b = 0; b < p.length; b++)
          g["$" + p[b]] = !0;
        for (var C = 0; C < c.length; C++) {
          var O = g.hasOwnProperty("$" + c[C].value);
          c[C].selected !== O && (c[C].selected = O), O && l && (c[C].defaultSelected = !0);
        }
      } else {
        for (var L = ii(da(a)), B = null, H = 0; H < c.length; H++) {
          if (c[H].value === L) {
            c[H].selected = !0, l && (c[H].defaultSelected = !0);
            return;
          }
          B === null && !c[H].disabled && (B = c[H]);
        }
        B !== null && (B.selected = !0);
      }
    }
    function _s(e, t) {
      return Mt({}, t, {
        value: void 0
      });
    }
    function Ds(e, t) {
      var a = e;
      Rs(t), a._wrapperState = {
        wasMultiple: !!t.multiple
      }, t.value !== void 0 && t.defaultValue !== void 0 && !jl && (v("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), jl = !0);
    }
    function Td(e, t) {
      var a = e;
      a.multiple = !!t.multiple;
      var l = t.value;
      l != null ? tl(a, !!t.multiple, l, !1) : t.defaultValue != null && tl(a, !!t.multiple, t.defaultValue, !0);
    }
    function rg(e, t) {
      var a = e, l = a._wrapperState.wasMultiple;
      a._wrapperState.wasMultiple = !!t.multiple;
      var c = t.value;
      c != null ? tl(a, !!t.multiple, c, !1) : l !== !!t.multiple && (t.defaultValue != null ? tl(a, !!t.multiple, t.defaultValue, !0) : tl(a, !!t.multiple, t.multiple ? [] : "", !1));
    }
    function Bh(e, t) {
      var a = e, l = t.value;
      l != null && tl(a, !!t.multiple, l, !1);
    }
    var Vh = !1;
    function Rd(e, t) {
      var a = e;
      if (t.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var l = Mt({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: ii(a._wrapperState.initialValue)
      });
      return l;
    }
    function $h(e, t) {
      var a = e;
      Co("textarea", t), t.value !== void 0 && t.defaultValue !== void 0 && !Vh && (v("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fi() || "A component"), Vh = !0);
      var l = t.value;
      if (l == null) {
        var c = t.children, p = t.defaultValue;
        if (c != null) {
          v("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (p != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if ($t(c)) {
              if (c.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              c = c[0];
            }
            p = c;
          }
        }
        p == null && (p = ""), l = p;
      }
      a._wrapperState = {
        initialValue: da(l)
      };
    }
    function Yh(e, t) {
      var a = e, l = da(t.value), c = da(t.defaultValue);
      if (l != null) {
        var p = ii(l);
        p !== a.value && (a.value = p), t.defaultValue == null && a.defaultValue !== p && (a.defaultValue = p);
      }
      c != null && (a.defaultValue = ii(c));
    }
    function Fc(e, t) {
      var a = e, l = a.textContent;
      l === a._wrapperState.initialValue && l !== "" && l !== null && (a.value = l);
    }
    function ig(e, t) {
      Yh(e, t);
    }
    var nl = "http://www.w3.org/1999/xhtml", ag = "http://www.w3.org/1998/Math/MathML", Pc = "http://www.w3.org/2000/svg";
    function _d(e) {
      switch (e) {
        case "svg":
          return Pc;
        case "math":
          return ag;
        default:
          return nl;
      }
    }
    function Dd(e, t) {
      return e == null || e === nl ? _d(t) : e === Pc && t === "foreignObject" ? nl : e;
    }
    var lg = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, a, l, c) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(t, a, l, c);
        });
      } : e;
    }, Hc, Wh = lg(function(e, t) {
      if (e.namespaceURI === Pc && !("innerHTML" in e)) {
        Hc = Hc || document.createElement("div"), Hc.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>";
        for (var a = Hc.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; a.firstChild; )
          e.appendChild(a.firstChild);
        return;
      }
      e.innerHTML = t;
    }), ai = 1, rl = 3, Fn = 8, Ci = 9, Od = 11, Os = function(e, t) {
      if (t) {
        var a = e.firstChild;
        if (a && a === e.lastChild && a.nodeType === rl) {
          a.nodeValue = t;
          return;
        }
      }
      e.textContent = t;
    }, Qh = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, mu = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function qh(e, t) {
      return e + t.charAt(0).toUpperCase() + t.substring(1);
    }
    var Gh = ["Webkit", "ms", "Moz", "O"];
    Object.keys(mu).forEach(function(e) {
      Gh.forEach(function(t) {
        mu[qh(t, e)] = mu[e];
      });
    });
    function Ul(e, t, a) {
      var l = t == null || typeof t == "boolean" || t === "";
      return l ? "" : !a && typeof t == "number" && t !== 0 && !(mu.hasOwnProperty(e) && mu[e]) ? t + "px" : (Fr(t, e), ("" + t).trim());
    }
    var og = /([A-Z])/g, ug = /^ms-/;
    function sg(e) {
      return e.replace(og, "-$1").toLowerCase().replace(ug, "-ms-");
    }
    var Md = function() {
    };
    {
      var Xh = /^(?:webkit|moz|o)[A-Z]/, Ms = /^-ms-/, Ns = /-(.)/g, Kh = /;\s*$/, il = {}, Nd = {}, Ld = !1, Ic = !1, zd = function(e) {
        return e.replace(Ns, function(t, a) {
          return a.toUpperCase();
        });
      }, Jh = function(e) {
        il.hasOwnProperty(e) && il[e] || (il[e] = !0, v(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          zd(e.replace(Ms, "ms-"))
        ));
      }, Zh = function(e) {
        il.hasOwnProperty(e) && il[e] || (il[e] = !0, v("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, ev = function(e, t) {
        Nd.hasOwnProperty(t) && Nd[t] || (Nd[t] = !0, v(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, t.replace(Kh, "")));
      }, cg = function(e, t) {
        Ld || (Ld = !0, v("`NaN` is an invalid value for the `%s` css style property.", e));
      }, fg = function(e, t) {
        Ic || (Ic = !0, v("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      Md = function(e, t) {
        e.indexOf("-") > -1 ? Jh(e) : Xh.test(e) ? Zh(e) : Kh.test(t) && ev(e, t), typeof t == "number" && (isNaN(t) ? cg(e, t) : isFinite(t) || fg(e, t));
      };
    }
    var dg = Md;
    function pg(e) {
      {
        var t = "", a = "";
        for (var l in e)
          if (e.hasOwnProperty(l)) {
            var c = e[l];
            if (c != null) {
              var p = l.indexOf("--") === 0;
              t += a + (p ? l : sg(l)) + ":", t += Ul(l, c, p), a = ";";
            }
          }
        return t || null;
      }
    }
    function tv(e, t) {
      var a = e.style;
      for (var l in t)
        if (t.hasOwnProperty(l)) {
          var c = l.indexOf("--") === 0;
          c || dg(l, t[l]);
          var p = Ul(l, t[l], c);
          l === "float" && (l = "cssFloat"), c ? a.setProperty(l, p) : a[l] = p;
        }
    }
    function ha(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function yu(e) {
      var t = {};
      for (var a in e)
        for (var l = Qh[a] || [a], c = 0; c < l.length; c++)
          t[l[c]] = a;
      return t;
    }
    function nv(e, t) {
      {
        if (!t)
          return;
        var a = yu(e), l = yu(t), c = {};
        for (var p in a) {
          var g = a[p], b = l[p];
          if (b && g !== b) {
            var C = g + "," + b;
            if (c[C])
              continue;
            c[C] = !0, v("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", ha(e[g]) ? "Removing" : "Updating", g, b);
          }
        }
      }
    }
    var rv = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, iv = Mt({
      menuitem: !0
    }, rv), av = "__html";
    function Ls(e, t) {
      if (t) {
        if (iv[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (t.dangerouslySetInnerHTML != null) {
          if (t.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof t.dangerouslySetInnerHTML != "object" || !(av in t.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!t.suppressContentEditableWarning && t.contentEditable && t.children != null && v("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), t.style != null && typeof t.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function ko(e, t) {
      if (e.indexOf("-") === -1)
        return typeof t.is == "string";
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Bc = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, To = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Fl = {}, zs = new RegExp("^(aria)-[" + Ye + "]*$"), Ad = new RegExp("^(aria)[A-Z][" + Ye + "]*$");
    function lv(e, t) {
      {
        if (Jn.call(Fl, t) && Fl[t])
          return !0;
        if (Ad.test(t)) {
          var a = "aria-" + t.slice(4).toLowerCase(), l = To.hasOwnProperty(a) ? a : null;
          if (l == null)
            return v("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", t), Fl[t] = !0, !0;
          if (t !== l)
            return v("Invalid ARIA attribute `%s`. Did you mean `%s`?", t, l), Fl[t] = !0, !0;
        }
        if (zs.test(t)) {
          var c = t.toLowerCase(), p = To.hasOwnProperty(c) ? c : null;
          if (p == null)
            return Fl[t] = !0, !1;
          if (t !== p)
            return v("Unknown ARIA attribute `%s`. Did you mean `%s`?", t, p), Fl[t] = !0, !0;
        }
      }
      return !0;
    }
    function Vc(e, t) {
      {
        var a = [];
        for (var l in t) {
          var c = lv(e, l);
          c || a.push(l);
        }
        var p = a.map(function(g) {
          return "`" + g + "`";
        }).join(", ");
        a.length === 1 ? v("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", p, e) : a.length > 1 && v("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", p, e);
      }
    }
    function gu(e, t) {
      ko(e, t) || Vc(e, t);
    }
    var $c = !1;
    function ov(e, t) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        t != null && t.value === null && !$c && ($c = !0, e === "select" && t.multiple ? v("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : v("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var As = function() {
    };
    {
      var zr = {}, jd = /^on./, uv = /^on[^A-Z]/, sv = new RegExp("^(aria)-[" + Ye + "]*$"), cv = new RegExp("^(aria)[A-Z][" + Ye + "]*$");
      As = function(e, t, a, l) {
        if (Jn.call(zr, t) && zr[t])
          return !0;
        var c = t.toLowerCase();
        if (c === "onfocusin" || c === "onfocusout")
          return v("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), zr[t] = !0, !0;
        if (l != null) {
          var p = l.registrationNameDependencies, g = l.possibleRegistrationNames;
          if (p.hasOwnProperty(t))
            return !0;
          var b = g.hasOwnProperty(c) ? g[c] : null;
          if (b != null)
            return v("Invalid event handler property `%s`. Did you mean `%s`?", t, b), zr[t] = !0, !0;
          if (jd.test(t))
            return v("Unknown event handler property `%s`. It will be ignored.", t), zr[t] = !0, !0;
        } else if (jd.test(t))
          return uv.test(t) && v("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", t), zr[t] = !0, !0;
        if (sv.test(t) || cv.test(t))
          return !0;
        if (c === "innerhtml")
          return v("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), zr[t] = !0, !0;
        if (c === "aria")
          return v("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), zr[t] = !0, !0;
        if (c === "is" && a !== null && a !== void 0 && typeof a != "string")
          return v("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof a), zr[t] = !0, !0;
        if (typeof a == "number" && isNaN(a))
          return v("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", t), zr[t] = !0, !0;
        var C = dr(t), O = C !== null && C.type === Hr;
        if (Bc.hasOwnProperty(c)) {
          var L = Bc[c];
          if (L !== t)
            return v("Invalid DOM property `%s`. Did you mean `%s`?", t, L), zr[t] = !0, !0;
        } else if (!O && t !== c)
          return v("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", t, c), zr[t] = !0, !0;
        return typeof a == "boolean" && Nr(t, a, C, !1) ? (a ? v('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', a, t, t, a, t) : v('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', a, t, t, a, t, t, t), zr[t] = !0, !0) : O ? !0 : Nr(t, a, C, !1) ? (zr[t] = !0, !1) : ((a === "false" || a === "true") && C !== null && C.type === $e && (v("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", a, t, a === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', t, a), zr[t] = !0), !0);
      };
    }
    var fv = function(e, t, a) {
      {
        var l = [];
        for (var c in t) {
          var p = As(e, c, t[c], a);
          p || l.push(c);
        }
        var g = l.map(function(b) {
          return "`" + b + "`";
        }).join(", ");
        l.length === 1 ? v("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", g, e) : l.length > 1 && v("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", g, e);
      }
    };
    function Pl(e, t, a) {
      ko(e, t) || fv(e, t, a);
    }
    var Yc = 1, js = 2, Us = 4, hg = Yc | js | Us, al = null;
    function vg(e) {
      al !== null && v("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), al = e;
    }
    function dv() {
      al === null && v("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), al = null;
    }
    function pv(e) {
      return e === al;
    }
    function cn(e) {
      var t = e.target || e.srcElement || window;
      return t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === rl ? t.parentNode : t;
    }
    var Fs = null, ll = null, _a = null;
    function Ud(e) {
      var t = Xu(e);
      if (t) {
        if (typeof Fs != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var a = t.stateNode;
        if (a) {
          var l = ym(a);
          Fs(t.stateNode, t.type, l);
        }
      }
    }
    function Fd(e) {
      Fs = e;
    }
    function Su(e) {
      ll ? _a ? _a.push(e) : _a = [e] : ll = e;
    }
    function Wc() {
      return ll !== null || _a !== null;
    }
    function Ro() {
      if (ll) {
        var e = ll, t = _a;
        if (ll = null, _a = null, Ud(e), t)
          for (var a = 0; a < t.length; a++)
            Ud(t[a]);
      }
    }
    var Pd = function(e, t) {
      return e(t);
    }, hv = function() {
    }, Hd = !1;
    function vv() {
      var e = Wc();
      e && (hv(), Ro());
    }
    function Ps(e, t, a) {
      if (Hd)
        return e(t, a);
      Hd = !0;
      try {
        return Pd(e, t, a);
      } finally {
        Hd = !1, vv();
      }
    }
    function Qc(e, t, a) {
      Pd = e, hv = a;
    }
    function Id(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function Bd(e, t, a) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(a.disabled && Id(t));
        default:
          return !1;
      }
    }
    function _o(e, t) {
      var a = e.stateNode;
      if (a === null)
        return null;
      var l = ym(a);
      if (l === null)
        return null;
      var c = l[t];
      if (Bd(t, e.type, l))
        return null;
      if (c && typeof c != "function")
        throw new Error("Expected `" + t + "` listener to be a function, instead got a value of `" + typeof c + "` type.");
      return c;
    }
    var Hs = !1;
    if (kn)
      try {
        var Is = {};
        Object.defineProperty(Is, "passive", {
          get: function() {
            Hs = !0;
          }
        }), window.addEventListener("test", Is, Is), window.removeEventListener("test", Is, Is);
      } catch {
        Hs = !1;
      }
    function Vd(e, t, a, l, c, p, g, b, C) {
      var O = Array.prototype.slice.call(arguments, 3);
      try {
        t.apply(a, O);
      } catch (L) {
        this.onError(L);
      }
    }
    var mv = Vd;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var $d = document.createElement("react");
      mv = function(t, a, l, c, p, g, b, C, O) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var L = document.createEvent("Event"), B = !1, H = !0, J = window.event, Z = Object.getOwnPropertyDescriptor(window, "event");
        function le() {
          $d.removeEventListener(oe, ft, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = J);
        }
        var Be = Array.prototype.slice.call(arguments, 3);
        function ft() {
          B = !0, le(), a.apply(l, Be), H = !1;
        }
        var rt, It = !1, jt = !1;
        function Q(q) {
          if (rt = q.error, It = !0, rt === null && q.colno === 0 && q.lineno === 0 && (jt = !0), q.defaultPrevented && rt != null && typeof rt == "object")
            try {
              rt._suppressLogging = !0;
            } catch {
            }
        }
        var oe = "react-" + (t || "invokeguardedcallback");
        if (window.addEventListener("error", Q), $d.addEventListener(oe, ft, !1), L.initEvent(oe, !1, !1), $d.dispatchEvent(L), Z && Object.defineProperty(window, "event", Z), B && H && (It ? jt && (rt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : rt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(rt)), window.removeEventListener("error", Q), !B)
          return le(), Vd.apply(this, arguments);
      };
    }
    var Yd = mv, wi = !1, Bs = null, ol = !1, Hi = null, Vs = {
      onError: function(e) {
        wi = !0, Bs = e;
      }
    };
    function va(e, t, a, l, c, p, g, b, C) {
      wi = !1, Bs = null, Yd.apply(Vs, arguments);
    }
    function Wd(e, t, a, l, c, p, g, b, C) {
      if (va.apply(this, arguments), wi) {
        var O = ul();
        ol || (ol = !0, Hi = O);
      }
    }
    function mg() {
      if (ol) {
        var e = Hi;
        throw ol = !1, Hi = null, e;
      }
    }
    function yg() {
      return wi;
    }
    function ul() {
      if (wi) {
        var e = Bs;
        return wi = !1, Bs = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Da(e) {
      return e._reactInternals;
    }
    function xu(e) {
      return e._reactInternals !== void 0;
    }
    function qc(e, t) {
      e._reactInternals = t;
    }
    var st = (
      /*                      */
      0
    ), ma = (
      /*                */
      1
    ), fn = (
      /*                    */
      2
    ), et = (
      /*                       */
      4
    ), qt = (
      /*                */
      16
    ), Ii = (
      /*                 */
      32
    ), pr = (
      /*                     */
      64
    ), Ct = (
      /*                   */
      128
    ), Br = (
      /*            */
      256
    ), ki = (
      /*                          */
      512
    ), er = (
      /*                     */
      1024
    ), li = (
      /*                      */
      2048
    ), Oa = (
      /*                    */
      4096
    ), Hl = (
      /*                   */
      8192
    ), Do = (
      /*             */
      16384
    ), yv = li | et | pr | ki | er | Do, sl = (
      /*               */
      32767
    ), Il = (
      /*                   */
      32768
    ), xr = (
      /*                */
      65536
    ), Gc = (
      /* */
      131072
    ), gv = (
      /*                       */
      1048576
    ), Ma = (
      /*                    */
      2097152
    ), Bi = (
      /*                 */
      4194304
    ), Bl = (
      /*                */
      8388608
    ), Vi = (
      /*               */
      16777216
    ), Oo = (
      /*              */
      33554432
    ), oi = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      et | er | 0
    ), ui = fn | et | qt | Ii | ki | Oa | Hl, ya = et | pr | ki | Hl, si = li | qt, br = Bi | Bl | Ma, Mo = f.ReactCurrentOwner;
    function Vl(e) {
      var t = e, a = e;
      if (e.alternate)
        for (; t.return; )
          t = t.return;
      else {
        var l = t;
        do
          t = l, (t.flags & (fn | Oa)) !== st && (a = t.return), l = t.return;
        while (l);
      }
      return t.tag === N ? a : null;
    }
    function Xc(e) {
      if (e.tag === Y) {
        var t = e.memoizedState;
        if (t === null) {
          var a = e.alternate;
          a !== null && (t = a.memoizedState);
        }
        if (t !== null)
          return t.dehydrated;
      }
      return null;
    }
    function Kc(e) {
      return e.tag === N ? e.stateNode.containerInfo : null;
    }
    function Ti(e) {
      return Vl(e) === e;
    }
    function Ri(e) {
      {
        var t = Mo.current;
        if (t !== null && t.tag === R) {
          var a = t, l = a.stateNode;
          l._warnedAboutRefsInRender || v("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", xt(a) || "A component"), l._warnedAboutRefsInRender = !0;
        }
      }
      var c = Da(e);
      return c ? Vl(c) === c : !1;
    }
    function bn(e) {
      if (Vl(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function $i(e) {
      var t = e.alternate;
      if (!t) {
        var a = Vl(e);
        if (a === null)
          throw new Error("Unable to find node on an unmounted component.");
        return a !== e ? null : e;
      }
      for (var l = e, c = t; ; ) {
        var p = l.return;
        if (p === null)
          break;
        var g = p.alternate;
        if (g === null) {
          var b = p.return;
          if (b !== null) {
            l = c = b;
            continue;
          }
          break;
        }
        if (p.child === g.child) {
          for (var C = p.child; C; ) {
            if (C === l)
              return bn(p), e;
            if (C === c)
              return bn(p), t;
            C = C.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (l.return !== c.return)
          l = p, c = g;
        else {
          for (var O = !1, L = p.child; L; ) {
            if (L === l) {
              O = !0, l = p, c = g;
              break;
            }
            if (L === c) {
              O = !0, c = p, l = g;
              break;
            }
            L = L.sibling;
          }
          if (!O) {
            for (L = g.child; L; ) {
              if (L === l) {
                O = !0, l = g, c = p;
                break;
              }
              if (L === c) {
                O = !0, c = g, l = p;
                break;
              }
              L = L.sibling;
            }
            if (!O)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (l.alternate !== c)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (l.tag !== N)
        throw new Error("Unable to find node on an unmounted component.");
      return l.stateNode.current === l ? e : t;
    }
    function Qd(e) {
      var t = $i(e);
      return t !== null ? qd(t) : null;
    }
    function qd(e) {
      if (e.tag === F || e.tag === $)
        return e;
      for (var t = e.child; t !== null; ) {
        var a = qd(t);
        if (a !== null)
          return a;
        t = t.sibling;
      }
      return null;
    }
    function Gd(e) {
      var t = $i(e);
      return t !== null ? Jc(t) : null;
    }
    function Jc(e) {
      if (e.tag === F || e.tag === $)
        return e;
      for (var t = e.child; t !== null; ) {
        if (t.tag !== M) {
          var a = Jc(t);
          if (a !== null)
            return a;
        }
        t = t.sibling;
      }
      return null;
    }
    var Xd = s.unstable_scheduleCallback, Zc = s.unstable_cancelCallback, Sv = s.unstable_shouldYield, bu = s.unstable_requestPaint, tr = s.unstable_now, gg = s.unstable_getCurrentPriorityLevel, ci = s.unstable_ImmediatePriority, Eu = s.unstable_UserBlockingPriority, Na = s.unstable_NormalPriority, Cu = s.unstable_LowPriority, $s = s.unstable_IdlePriority, Kd = s.unstable_yieldValue, Jd = s.unstable_setDisableYieldValue, $l = null, Yn = null, Me = null, Ar = !1, _i = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function xv(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t.isDisabled)
        return !0;
      if (!t.supportsFiber)
        return v("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        at && (e = Mt({}, e, {
          getLaneLabelMap: ef,
          injectProfilingHooks: Wl
        })), $l = t.inject(e), Yn = t;
      } catch (a) {
        v("React instrumentation encountered an error: %s.", a);
      }
      return !!t.checkDCE;
    }
    function cl(e, t) {
      if (Yn && typeof Yn.onScheduleFiberRoot == "function")
        try {
          Yn.onScheduleFiberRoot($l, e, t);
        } catch (a) {
          Ar || (Ar = !0, v("React instrumentation encountered an error: %s", a));
        }
    }
    function Yl(e, t) {
      if (Yn && typeof Yn.onCommitFiberRoot == "function")
        try {
          var a = (e.current.flags & Ct) === Ct;
          if (_t) {
            var l;
            switch (t) {
              case Gn:
                l = ci;
                break;
              case dl:
                l = Eu;
                break;
              case Aa:
                l = Na;
                break;
              case Lu:
                l = $s;
                break;
              default:
                l = Na;
                break;
            }
            Yn.onCommitFiberRoot($l, e, l, a);
          }
        } catch (c) {
          Ar || (Ar = !0, v("React instrumentation encountered an error: %s", c));
        }
    }
    function Zd(e) {
      if (Yn && typeof Yn.onPostCommitFiberRoot == "function")
        try {
          Yn.onPostCommitFiberRoot($l, e);
        } catch (t) {
          Ar || (Ar = !0, v("React instrumentation encountered an error: %s", t));
        }
    }
    function bv(e) {
      if (Yn && typeof Yn.onCommitFiberUnmount == "function")
        try {
          Yn.onCommitFiberUnmount($l, e);
        } catch (t) {
          Ar || (Ar = !0, v("React instrumentation encountered an error: %s", t));
        }
    }
    function mn(e) {
      if (typeof Kd == "function" && (Jd(e), y(e)), Yn && typeof Yn.setStrictMode == "function")
        try {
          Yn.setStrictMode($l, e);
        } catch (t) {
          Ar || (Ar = !0, v("React instrumentation encountered an error: %s", t));
        }
    }
    function Wl(e) {
      Me = e;
    }
    function ef() {
      {
        for (var e = /* @__PURE__ */ new Map(), t = 1, a = 0; a < Wn; a++) {
          var l = Dv(t);
          e.set(t, l), t *= 2;
        }
        return e;
      }
    }
    function Ev(e) {
      Me !== null && typeof Me.markCommitStarted == "function" && Me.markCommitStarted(e);
    }
    function Ys() {
      Me !== null && typeof Me.markCommitStopped == "function" && Me.markCommitStopped();
    }
    function wu(e) {
      Me !== null && typeof Me.markComponentRenderStarted == "function" && Me.markComponentRenderStarted(e);
    }
    function No() {
      Me !== null && typeof Me.markComponentRenderStopped == "function" && Me.markComponentRenderStopped();
    }
    function ep(e) {
      Me !== null && typeof Me.markComponentPassiveEffectMountStarted == "function" && Me.markComponentPassiveEffectMountStarted(e);
    }
    function tf() {
      Me !== null && typeof Me.markComponentPassiveEffectMountStopped == "function" && Me.markComponentPassiveEffectMountStopped();
    }
    function Cv(e) {
      Me !== null && typeof Me.markComponentPassiveEffectUnmountStarted == "function" && Me.markComponentPassiveEffectUnmountStarted(e);
    }
    function wv() {
      Me !== null && typeof Me.markComponentPassiveEffectUnmountStopped == "function" && Me.markComponentPassiveEffectUnmountStopped();
    }
    function kv(e) {
      Me !== null && typeof Me.markComponentLayoutEffectMountStarted == "function" && Me.markComponentLayoutEffectMountStarted(e);
    }
    function tp() {
      Me !== null && typeof Me.markComponentLayoutEffectMountStopped == "function" && Me.markComponentLayoutEffectMountStopped();
    }
    function ku(e) {
      Me !== null && typeof Me.markComponentLayoutEffectUnmountStarted == "function" && Me.markComponentLayoutEffectUnmountStarted(e);
    }
    function Ws() {
      Me !== null && typeof Me.markComponentLayoutEffectUnmountStopped == "function" && Me.markComponentLayoutEffectUnmountStopped();
    }
    function Tv(e, t, a) {
      Me !== null && typeof Me.markComponentErrored == "function" && Me.markComponentErrored(e, t, a);
    }
    function Rv(e, t, a) {
      Me !== null && typeof Me.markComponentSuspended == "function" && Me.markComponentSuspended(e, t, a);
    }
    function Tu(e) {
      Me !== null && typeof Me.markLayoutEffectsStarted == "function" && Me.markLayoutEffectsStarted(e);
    }
    function _v() {
      Me !== null && typeof Me.markLayoutEffectsStopped == "function" && Me.markLayoutEffectsStopped();
    }
    function Qs(e) {
      Me !== null && typeof Me.markPassiveEffectsStarted == "function" && Me.markPassiveEffectsStarted(e);
    }
    function La() {
      Me !== null && typeof Me.markPassiveEffectsStopped == "function" && Me.markPassiveEffectsStopped();
    }
    function Ru(e) {
      Me !== null && typeof Me.markRenderStarted == "function" && Me.markRenderStarted(e);
    }
    function qs() {
      Me !== null && typeof Me.markRenderYielded == "function" && Me.markRenderYielded();
    }
    function Ql() {
      Me !== null && typeof Me.markRenderStopped == "function" && Me.markRenderStopped();
    }
    function np(e) {
      Me !== null && typeof Me.markRenderScheduled == "function" && Me.markRenderScheduled(e);
    }
    function _u(e, t) {
      Me !== null && typeof Me.markForceUpdateScheduled == "function" && Me.markForceUpdateScheduled(e, t);
    }
    function nf(e, t) {
      Me !== null && typeof Me.markStateUpdateScheduled == "function" && Me.markStateUpdateScheduled(e, t);
    }
    var ct = (
      /*                         */
      0
    ), nt = (
      /*                 */
      1
    ), Wt = (
      /*                    */
      2
    ), Pn = (
      /*               */
      8
    ), Yi = (
      /*              */
      16
    ), Gs = Math.clz32 ? Math.clz32 : Nn, rp = Math.log, Lo = Math.LN2;
    function Nn(e) {
      var t = e >>> 0;
      return t === 0 ? 32 : 31 - (rp(t) / Lo | 0) | 0;
    }
    var Wn = 31, fe = (
      /*                        */
      0
    ), Qn = (
      /*                          */
      0
    ), dt = (
      /*                        */
      1
    ), za = (
      /*    */
      2
    ), fl = (
      /*             */
      4
    ), Hn = (
      /*            */
      8
    ), Wi = (
      /*                     */
      16
    ), zo = (
      /*                */
      32
    ), ql = (
      /*                       */
      4194240
    ), fi = (
      /*                        */
      64
    ), di = (
      /*                        */
      128
    ), Ao = (
      /*                        */
      256
    ), Xs = (
      /*                        */
      512
    ), Ks = (
      /*                        */
      1024
    ), rf = (
      /*                        */
      2048
    ), af = (
      /*                        */
      4096
    ), lf = (
      /*                        */
      8192
    ), of = (
      /*                        */
      16384
    ), uf = (
      /*                       */
      32768
    ), sf = (
      /*                       */
      65536
    ), cf = (
      /*                       */
      131072
    ), ff = (
      /*                       */
      262144
    ), jo = (
      /*                       */
      524288
    ), df = (
      /*                       */
      1048576
    ), Du = (
      /*                       */
      2097152
    ), Uo = (
      /*                            */
      130023424
    ), Fo = (
      /*                             */
      4194304
    ), Js = (
      /*                             */
      8388608
    ), pf = (
      /*                             */
      16777216
    ), hf = (
      /*                             */
      33554432
    ), vf = (
      /*                             */
      67108864
    ), ip = Fo, Po = (
      /*          */
      134217728
    ), ap = (
      /*                          */
      268435455
    ), Ou = (
      /*               */
      268435456
    ), Gl = (
      /*                        */
      536870912
    ), Di = (
      /*                   */
      1073741824
    );
    function Dv(e) {
      {
        if (e & dt)
          return "Sync";
        if (e & za)
          return "InputContinuousHydration";
        if (e & fl)
          return "InputContinuous";
        if (e & Hn)
          return "DefaultHydration";
        if (e & Wi)
          return "Default";
        if (e & zo)
          return "TransitionHydration";
        if (e & ql)
          return "Transition";
        if (e & Uo)
          return "Retry";
        if (e & Po)
          return "SelectiveHydration";
        if (e & Ou)
          return "IdleHydration";
        if (e & Gl)
          return "Idle";
        if (e & Di)
          return "Offscreen";
      }
    }
    var yn = -1, mf = fi, Zs = Fo;
    function Mu(e) {
      switch (qn(e)) {
        case dt:
          return dt;
        case za:
          return za;
        case fl:
          return fl;
        case Hn:
          return Hn;
        case Wi:
          return Wi;
        case zo:
          return zo;
        case fi:
        case di:
        case Ao:
        case Xs:
        case Ks:
        case rf:
        case af:
        case lf:
        case of:
        case uf:
        case sf:
        case cf:
        case ff:
        case jo:
        case df:
        case Du:
          return e & ql;
        case Fo:
        case Js:
        case pf:
        case hf:
        case vf:
          return e & Uo;
        case Po:
          return Po;
        case Ou:
          return Ou;
        case Gl:
          return Gl;
        case Di:
          return Di;
        default:
          return v("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function ec(e, t) {
      var a = e.pendingLanes;
      if (a === fe)
        return fe;
      var l = fe, c = e.suspendedLanes, p = e.pingedLanes, g = a & ap;
      if (g !== fe) {
        var b = g & ~c;
        if (b !== fe)
          l = Mu(b);
        else {
          var C = g & p;
          C !== fe && (l = Mu(C));
        }
      } else {
        var O = a & ~c;
        O !== fe ? l = Mu(O) : p !== fe && (l = Mu(p));
      }
      if (l === fe)
        return fe;
      if (t !== fe && t !== l && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (t & c) === fe) {
        var L = qn(l), B = qn(t);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          L >= B || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          L === Wi && (B & ql) !== fe
        )
          return t;
      }
      (l & fl) !== fe && (l |= a & Wi);
      var H = e.entangledLanes;
      if (H !== fe)
        for (var J = e.entanglements, Z = l & H; Z > 0; ) {
          var le = Kl(Z), Be = 1 << le;
          l |= J[le], Z &= ~Be;
        }
      return l;
    }
    function yf(e, t) {
      for (var a = e.eventTimes, l = yn; t > 0; ) {
        var c = Kl(t), p = 1 << c, g = a[c];
        g > l && (l = g), t &= ~p;
      }
      return l;
    }
    function Sg(e, t) {
      switch (e) {
        case dt:
        case za:
        case fl:
          return t + 250;
        case Hn:
        case Wi:
        case zo:
        case fi:
        case di:
        case Ao:
        case Xs:
        case Ks:
        case rf:
        case af:
        case lf:
        case of:
        case uf:
        case sf:
        case cf:
        case ff:
        case jo:
        case df:
        case Du:
          return t + 5e3;
        case Fo:
        case Js:
        case pf:
        case hf:
        case vf:
          return yn;
        case Po:
        case Ou:
        case Gl:
        case Di:
          return yn;
        default:
          return v("Should have found matching lanes. This is a bug in React."), yn;
      }
    }
    function xg(e, t) {
      for (var a = e.pendingLanes, l = e.suspendedLanes, c = e.pingedLanes, p = e.expirationTimes, g = a; g > 0; ) {
        var b = Kl(g), C = 1 << b, O = p[b];
        O === yn ? ((C & l) === fe || (C & c) !== fe) && (p[b] = Sg(C, t)) : O <= t && (e.expiredLanes |= C), g &= ~C;
      }
    }
    function bg(e) {
      return Mu(e.pendingLanes);
    }
    function Xl(e) {
      var t = e.pendingLanes & ~Di;
      return t !== fe ? t : t & Di ? Di : fe;
    }
    function lp(e) {
      return (e & dt) !== fe;
    }
    function tc(e) {
      return (e & ap) !== fe;
    }
    function Ov(e) {
      return (e & Uo) === e;
    }
    function Mv(e) {
      var t = dt | fl | Wi;
      return (e & t) === fe;
    }
    function Nv(e) {
      return (e & ql) === e;
    }
    function nc(e, t) {
      var a = za | fl | Hn | Wi;
      return (t & a) !== fe;
    }
    function Lv(e, t) {
      return (t & e.expiredLanes) !== fe;
    }
    function op(e) {
      return (e & ql) !== fe;
    }
    function zv() {
      var e = mf;
      return mf <<= 1, (mf & ql) === fe && (mf = fi), e;
    }
    function pi() {
      var e = Zs;
      return Zs <<= 1, (Zs & Uo) === fe && (Zs = Fo), e;
    }
    function qn(e) {
      return e & -e;
    }
    function Nu(e) {
      return qn(e);
    }
    function Kl(e) {
      return 31 - Gs(e);
    }
    function gf(e) {
      return Kl(e);
    }
    function hi(e, t) {
      return (e & t) !== fe;
    }
    function Ho(e, t) {
      return (e & t) === t;
    }
    function Rt(e, t) {
      return e | t;
    }
    function rc(e, t) {
      return e & ~t;
    }
    function Sf(e, t) {
      return e & t;
    }
    function Eg(e) {
      return e;
    }
    function Av(e, t) {
      return e !== Qn && e < t ? e : t;
    }
    function ic(e) {
      for (var t = [], a = 0; a < Wn; a++)
        t.push(e);
      return t;
    }
    function Io(e, t, a) {
      e.pendingLanes |= t, t !== Gl && (e.suspendedLanes = fe, e.pingedLanes = fe);
      var l = e.eventTimes, c = gf(t);
      l[c] = a;
    }
    function jv(e, t) {
      e.suspendedLanes |= t, e.pingedLanes &= ~t;
      for (var a = e.expirationTimes, l = t; l > 0; ) {
        var c = Kl(l), p = 1 << c;
        a[c] = yn, l &= ~p;
      }
    }
    function xf(e, t, a) {
      e.pingedLanes |= e.suspendedLanes & t;
    }
    function bf(e, t) {
      var a = e.pendingLanes & ~t;
      e.pendingLanes = t, e.suspendedLanes = fe, e.pingedLanes = fe, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t;
      for (var l = e.entanglements, c = e.eventTimes, p = e.expirationTimes, g = a; g > 0; ) {
        var b = Kl(g), C = 1 << b;
        l[b] = fe, c[b] = yn, p[b] = yn, g &= ~C;
      }
    }
    function up(e, t) {
      for (var a = e.entangledLanes |= t, l = e.entanglements, c = a; c; ) {
        var p = Kl(c), g = 1 << p;
        // Is this one of the newly entangled lanes?
        g & t | // Is this lane transitively entangled with the newly entangled lanes?
        l[p] & t && (l[p] |= t), c &= ~g;
      }
    }
    function Uv(e, t) {
      var a = qn(t), l;
      switch (a) {
        case fl:
          l = za;
          break;
        case Wi:
          l = Hn;
          break;
        case fi:
        case di:
        case Ao:
        case Xs:
        case Ks:
        case rf:
        case af:
        case lf:
        case of:
        case uf:
        case sf:
        case cf:
        case ff:
        case jo:
        case df:
        case Du:
        case Fo:
        case Js:
        case pf:
        case hf:
        case vf:
          l = zo;
          break;
        case Gl:
          l = Ou;
          break;
        default:
          l = Qn;
          break;
      }
      return (l & (e.suspendedLanes | t)) !== Qn ? Qn : l;
    }
    function Ef(e, t, a) {
      if (_i)
        for (var l = e.pendingUpdatersLaneMap; a > 0; ) {
          var c = gf(a), p = 1 << c, g = l[c];
          g.add(t), a &= ~p;
        }
    }
    function sp(e, t) {
      if (_i)
        for (var a = e.pendingUpdatersLaneMap, l = e.memoizedUpdaters; t > 0; ) {
          var c = gf(t), p = 1 << c, g = a[c];
          g.size > 0 && (g.forEach(function(b) {
            var C = b.alternate;
            (C === null || !l.has(C)) && l.add(b);
          }), g.clear()), t &= ~p;
        }
    }
    function ac(e, t) {
      return null;
    }
    var Gn = dt, dl = fl, Aa = Wi, Lu = Gl, zu = Qn;
    function Qi() {
      return zu;
    }
    function In(e) {
      zu = e;
    }
    function jr(e, t) {
      var a = zu;
      try {
        return zu = e, t();
      } finally {
        zu = a;
      }
    }
    function Cg(e, t) {
      return e !== 0 && e < t ? e : t;
    }
    function wg(e, t) {
      return e === 0 || e > t ? e : t;
    }
    function Au(e, t) {
      return e !== 0 && e < t;
    }
    function Er(e) {
      var t = qn(e);
      return Au(Gn, t) ? Au(dl, t) ? tc(t) ? Aa : Lu : dl : Gn;
    }
    function Cf(e) {
      var t = e.current.memoizedState;
      return t.isDehydrated;
    }
    var We;
    function ju(e) {
      We = e;
    }
    function cp(e) {
      We(e);
    }
    var wf;
    function kg(e) {
      wf = e;
    }
    var Uu;
    function kf(e) {
      Uu = e;
    }
    var Tf;
    function Fv(e) {
      Tf = e;
    }
    var fp;
    function Pv(e) {
      fp = e;
    }
    var lc = !1, Fu = [], Tn = null, hr = null, Vr = null, Pu = /* @__PURE__ */ new Map(), Hu = /* @__PURE__ */ new Map(), vr = [], Hv = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function ja(e) {
      return Hv.indexOf(e) > -1;
    }
    function Tg(e, t, a, l, c) {
      return {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: a,
        nativeEvent: c,
        targetContainers: [l]
      };
    }
    function dp(e, t) {
      switch (e) {
        case "focusin":
        case "focusout":
          Tn = null;
          break;
        case "dragenter":
        case "dragleave":
          hr = null;
          break;
        case "mouseover":
        case "mouseout":
          Vr = null;
          break;
        case "pointerover":
        case "pointerout": {
          var a = t.pointerId;
          Pu.delete(a);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var l = t.pointerId;
          Hu.delete(l);
          break;
        }
      }
    }
    function Iu(e, t, a, l, c, p) {
      if (e === null || e.nativeEvent !== p) {
        var g = Tg(t, a, l, c, p);
        if (t !== null) {
          var b = Xu(t);
          b !== null && wf(b);
        }
        return g;
      }
      e.eventSystemFlags |= l;
      var C = e.targetContainers;
      return c !== null && C.indexOf(c) === -1 && C.push(c), e;
    }
    function Iv(e, t, a, l, c) {
      switch (t) {
        case "focusin": {
          var p = c;
          return Tn = Iu(Tn, e, t, a, l, p), !0;
        }
        case "dragenter": {
          var g = c;
          return hr = Iu(hr, e, t, a, l, g), !0;
        }
        case "mouseover": {
          var b = c;
          return Vr = Iu(Vr, e, t, a, l, b), !0;
        }
        case "pointerover": {
          var C = c, O = C.pointerId;
          return Pu.set(O, Iu(Pu.get(O) || null, e, t, a, l, C)), !0;
        }
        case "gotpointercapture": {
          var L = c, B = L.pointerId;
          return Hu.set(B, Iu(Hu.get(B) || null, e, t, a, l, L)), !0;
        }
      }
      return !1;
    }
    function pp(e) {
      var t = gc(e.target);
      if (t !== null) {
        var a = Vl(t);
        if (a !== null) {
          var l = a.tag;
          if (l === Y) {
            var c = Xc(a);
            if (c !== null) {
              e.blockedOn = c, fp(e.priority, function() {
                Uu(a);
              });
              return;
            }
          } else if (l === N) {
            var p = a.stateNode;
            if (Cf(p)) {
              e.blockedOn = Kc(a);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function Rg(e) {
      for (var t = Tf(), a = {
        blockedOn: null,
        target: e,
        priority: t
      }, l = 0; l < vr.length && Au(t, vr[l].priority); l++)
        ;
      vr.splice(l, 0, a), l === 0 && pp(a);
    }
    function Bo(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var t = e.targetContainers; t.length > 0; ) {
        var a = t[0], l = Ur(e.domEventName, e.eventSystemFlags, a, e.nativeEvent);
        if (l === null) {
          var c = e.nativeEvent, p = new c.constructor(c.type, c);
          vg(p), c.target.dispatchEvent(p), dv();
        } else {
          var g = Xu(l);
          return g !== null && wf(g), e.blockedOn = l, !1;
        }
        t.shift();
      }
      return !0;
    }
    function Rf(e, t, a) {
      Bo(e) && a.delete(t);
    }
    function qi() {
      lc = !1, Tn !== null && Bo(Tn) && (Tn = null), hr !== null && Bo(hr) && (hr = null), Vr !== null && Bo(Vr) && (Vr = null), Pu.forEach(Rf), Hu.forEach(Rf);
    }
    function At(e, t) {
      e.blockedOn === t && (e.blockedOn = null, lc || (lc = !0, s.unstable_scheduleCallback(s.unstable_NormalPriority, qi)));
    }
    function Bn(e) {
      if (Fu.length > 0) {
        At(Fu[0], e);
        for (var t = 1; t < Fu.length; t++) {
          var a = Fu[t];
          a.blockedOn === e && (a.blockedOn = null);
        }
      }
      Tn !== null && At(Tn, e), hr !== null && At(hr, e), Vr !== null && At(Vr, e);
      var l = function(b) {
        return At(b, e);
      };
      Pu.forEach(l), Hu.forEach(l);
      for (var c = 0; c < vr.length; c++) {
        var p = vr[c];
        p.blockedOn === e && (p.blockedOn = null);
      }
      for (; vr.length > 0; ) {
        var g = vr[0];
        if (g.blockedOn !== null)
          break;
        pp(g), g.blockedOn === null && vr.shift();
      }
    }
    var En = f.ReactCurrentBatchConfig, ir = !0;
    function vi(e) {
      ir = !!e;
    }
    function Bu() {
      return ir;
    }
    function ar(e, t, a) {
      var l = _f(t), c;
      switch (l) {
        case Gn:
          c = oc;
          break;
        case dl:
          c = Vo;
          break;
        case Aa:
        default:
          c = Vu;
          break;
      }
      return c.bind(null, t, a, e);
    }
    function oc(e, t, a, l) {
      var c = Qi(), p = En.transition;
      En.transition = null;
      try {
        In(Gn), Vu(e, t, a, l);
      } finally {
        In(c), En.transition = p;
      }
    }
    function Vo(e, t, a, l) {
      var c = Qi(), p = En.transition;
      En.transition = null;
      try {
        In(dl), Vu(e, t, a, l);
      } finally {
        In(c), En.transition = p;
      }
    }
    function Vu(e, t, a, l) {
      ir && hp(e, t, a, l);
    }
    function hp(e, t, a, l) {
      var c = Ur(e, t, a, l);
      if (c === null) {
        $g(e, t, l, Jl, a), dp(e, l);
        return;
      }
      if (Iv(c, e, t, a, l)) {
        l.stopPropagation();
        return;
      }
      if (dp(e, l), t & Us && ja(e)) {
        for (; c !== null; ) {
          var p = Xu(c);
          p !== null && cp(p);
          var g = Ur(e, t, a, l);
          if (g === null && $g(e, t, l, Jl, a), g === c)
            break;
          c = g;
        }
        c !== null && l.stopPropagation();
        return;
      }
      $g(e, t, l, null, a);
    }
    var Jl = null;
    function Ur(e, t, a, l) {
      Jl = null;
      var c = cn(l), p = gc(c);
      if (p !== null) {
        var g = Vl(p);
        if (g === null)
          p = null;
        else {
          var b = g.tag;
          if (b === Y) {
            var C = Xc(g);
            if (C !== null)
              return C;
            p = null;
          } else if (b === N) {
            var O = g.stateNode;
            if (Cf(O))
              return Kc(g);
            p = null;
          } else
            g !== p && (p = null);
        }
      }
      return Jl = p, null;
    }
    function _f(e) {
      switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Gn;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return dl;
        case "message": {
          var t = gg();
          switch (t) {
            case ci:
              return Gn;
            case Eu:
              return dl;
            case Na:
            case Cu:
              return Aa;
            case $s:
              return Lu;
            default:
              return Aa;
          }
        }
        default:
          return Aa;
      }
    }
    function $u(e, t, a) {
      return e.addEventListener(t, a, !1), a;
    }
    function pl(e, t, a) {
      return e.addEventListener(t, a, !0), a;
    }
    function Df(e, t, a, l) {
      return e.addEventListener(t, a, {
        capture: !0,
        passive: l
      }), a;
    }
    function vp(e, t, a, l) {
      return e.addEventListener(t, a, {
        passive: l
      }), a;
    }
    var Gi = null, Yu = null, Xi = null;
    function Of(e) {
      return Gi = e, Yu = sc(), !0;
    }
    function uc() {
      Gi = null, Yu = null, Xi = null;
    }
    function Mf() {
      if (Xi)
        return Xi;
      var e, t = Yu, a = t.length, l, c = sc(), p = c.length;
      for (e = 0; e < a && t[e] === c[e]; e++)
        ;
      var g = a - e;
      for (l = 1; l <= g && t[a - l] === c[p - l]; l++)
        ;
      var b = l > 1 ? 1 - l : void 0;
      return Xi = c.slice(e, b), Xi;
    }
    function sc() {
      return "value" in Gi ? Gi.value : Gi.textContent;
    }
    function $o(e) {
      var t, a = e.keyCode;
      return "charCode" in e ? (t = e.charCode, t === 0 && a === 13 && (t = 13)) : t = a, t === 10 && (t = 13), t >= 32 || t === 13 ? t : 0;
    }
    function mr() {
      return !0;
    }
    function hl() {
      return !1;
    }
    function Ln(e) {
      function t(a, l, c, p, g) {
        this._reactName = a, this._targetInst = c, this.type = l, this.nativeEvent = p, this.target = g, this.currentTarget = null;
        for (var b in e)
          if (e.hasOwnProperty(b)) {
            var C = e[b];
            C ? this[b] = C(p) : this[b] = p[b];
          }
        var O = p.defaultPrevented != null ? p.defaultPrevented : p.returnValue === !1;
        return O ? this.isDefaultPrevented = mr : this.isDefaultPrevented = hl, this.isPropagationStopped = hl, this;
      }
      return Mt(t.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var a = this.nativeEvent;
          a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1), this.isDefaultPrevented = mr);
        },
        stopPropagation: function() {
          var a = this.nativeEvent;
          a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0), this.isPropagationStopped = mr);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: mr
      }), t;
    }
    var lr = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Nf = Ln(lr), Yo = Mt({}, lr, {
      view: 0,
      detail: 0
    }), mp = Ln(Yo), yp, Ua, Wu;
    function gp(e) {
      e !== Wu && (Wu && e.type === "mousemove" ? (yp = e.screenX - Wu.screenX, Ua = e.screenY - Wu.screenY) : (yp = 0, Ua = 0), Wu = e);
    }
    var Fa = Mt({}, Yo, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Sp,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (gp(e), yp);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : Ua;
      }
    }), Lf = Ln(Fa), Wo = Mt({}, Fa, {
      dataTransfer: 0
    }), Bv = Ln(Wo), Vv = Mt({}, Yo, {
      relatedTarget: 0
    }), cc = Ln(Vv), zf = Mt({}, lr, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), _g = Ln(zf), Dg = Mt({}, lr, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), $v = Ln(Dg), Yv = Mt({}, lr, {
      data: 0
    }), Zl = Ln(Yv), Og = Zl, Qu = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Wv = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Vn(e) {
      if (e.key) {
        var t = Qu[e.key] || e.key;
        if (t !== "Unidentified")
          return t;
      }
      if (e.type === "keypress") {
        var a = $o(e);
        return a === 13 ? "Enter" : String.fromCharCode(a);
      }
      return e.type === "keydown" || e.type === "keyup" ? Wv[e.keyCode] || "Unidentified" : "";
    }
    var Mg = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Qv(e) {
      var t = this, a = t.nativeEvent;
      if (a.getModifierState)
        return a.getModifierState(e);
      var l = Mg[e];
      return l ? !!a[l] : !1;
    }
    function Sp(e) {
      return Qv;
    }
    var Ng = Mt({}, Yo, {
      key: Vn,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Sp,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? $o(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? $o(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), qv = Ln(Ng), Gv = Mt({}, Fa, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Xv = Ln(Gv), Ki = Mt({}, Yo, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Sp
    }), xp = Ln(Ki), Lg = Mt({}, lr, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), eo = Ln(Lg), Af = Mt({}, Fa, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Qo = Ln(Af), jf = [9, 13, 27, 32], Uf = 229, fc = kn && "CompositionEvent" in window, dc = null;
    kn && "documentMode" in document && (dc = document.documentMode);
    var bp = kn && "TextEvent" in window && !dc, Kv = kn && (!fc || dc && dc > 8 && dc <= 11), Ep = 32, Cp = String.fromCharCode(Ep);
    function Ff() {
      Mr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Mr("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Mr("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Mr("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var pc = !1;
    function Jv(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function wp(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function zg(e, t) {
      return e === "keydown" && t.keyCode === Uf;
    }
    function kp(e, t) {
      switch (e) {
        case "keyup":
          return jf.indexOf(t.keyCode) !== -1;
        case "keydown":
          return t.keyCode !== Uf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Pf(e) {
      var t = e.detail;
      return typeof t == "object" && "data" in t ? t.data : null;
    }
    function hc(e) {
      return e.locale === "ko";
    }
    var to = !1;
    function Hf(e, t, a, l, c) {
      var p, g;
      if (fc ? p = wp(t) : to ? kp(t, l) && (p = "onCompositionEnd") : zg(t, l) && (p = "onCompositionStart"), !p)
        return null;
      Kv && !hc(l) && (!to && p === "onCompositionStart" ? to = Of(c) : p === "onCompositionEnd" && to && (g = Mf()));
      var b = im(a, p);
      if (b.length > 0) {
        var C = new Zl(p, t, null, l, c);
        if (e.push({
          event: C,
          listeners: b
        }), g)
          C.data = g;
        else {
          var O = Pf(l);
          O !== null && (C.data = O);
        }
      }
    }
    function Zv(e, t) {
      switch (e) {
        case "compositionend":
          return Pf(t);
        case "keypress":
          var a = t.which;
          return a !== Ep ? null : (pc = !0, Cp);
        case "textInput":
          var l = t.data;
          return l === Cp && pc ? null : l;
        default:
          return null;
      }
    }
    function Ag(e, t) {
      if (to) {
        if (e === "compositionend" || !fc && kp(e, t)) {
          var a = Mf();
          return uc(), to = !1, a;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!Jv(t)) {
            if (t.char && t.char.length > 1)
              return t.char;
            if (t.which)
              return String.fromCharCode(t.which);
          }
          return null;
        case "compositionend":
          return Kv && !hc(t) ? null : t.data;
        default:
          return null;
      }
    }
    function If(e, t, a, l, c) {
      var p;
      if (bp ? p = Zv(t, l) : p = Ag(t, l), !p)
        return null;
      var g = im(a, "onBeforeInput");
      if (g.length > 0) {
        var b = new Og("onBeforeInput", "beforeinput", null, l, c);
        e.push({
          event: b,
          listeners: g
        }), b.data = p;
      }
    }
    function jg(e, t, a, l, c, p, g) {
      Hf(e, t, a, l, c), If(e, t, a, l, c);
    }
    var vc = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function em(e) {
      var t = e && e.nodeName && e.nodeName.toLowerCase();
      return t === "input" ? !!vc[e.type] : t === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function Bf(e) {
      if (!kn)
        return !1;
      var t = "on" + e, a = t in document;
      if (!a) {
        var l = document.createElement("div");
        l.setAttribute(t, "return;"), a = typeof l[t] == "function";
      }
      return a;
    }
    function n() {
      Mr("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function i(e, t, a, l) {
      Su(l);
      var c = im(t, "onChange");
      if (c.length > 0) {
        var p = new Nf("onChange", "change", null, a, l);
        e.push({
          event: p,
          listeners: c
        });
      }
    }
    var u = null, d = null;
    function m(e) {
      var t = e.nodeName && e.nodeName.toLowerCase();
      return t === "select" || t === "input" && e.type === "file";
    }
    function x(e) {
      var t = [];
      i(t, d, e, cn(e)), Ps(_, t);
    }
    function _(e) {
      Ix(e, 0);
    }
    function z(e) {
      var t = qf(e);
      if (du(t))
        return e;
    }
    function P(e, t) {
      if (e === "change")
        return t;
    }
    var ee = !1;
    kn && (ee = Bf("input") && (!document.documentMode || document.documentMode > 9));
    function ye(e, t) {
      u = e, d = t, u.attachEvent("onpropertychange", ve);
    }
    function xe() {
      u && (u.detachEvent("onpropertychange", ve), u = null, d = null);
    }
    function ve(e) {
      e.propertyName === "value" && z(d) && x(e);
    }
    function Pe(e, t, a) {
      e === "focusin" ? (xe(), ye(t, a)) : e === "focusout" && xe();
    }
    function qe(e, t) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return z(d);
    }
    function Ze(e) {
      var t = e.nodeName;
      return t && t.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function Xn(e, t) {
      if (e === "click")
        return z(t);
    }
    function W(e, t) {
      if (e === "input" || e === "change")
        return z(t);
    }
    function I(e) {
      var t = e._wrapperState;
      !t || !t.controlled || e.type !== "number" || vt(e, "number", e.value);
    }
    function G(e, t, a, l, c, p, g) {
      var b = a ? qf(a) : window, C, O;
      if (m(b) ? C = P : em(b) ? ee ? C = W : (C = qe, O = Pe) : Ze(b) && (C = Xn), C) {
        var L = C(t, a);
        if (L) {
          i(e, L, l, c);
          return;
        }
      }
      O && O(t, b, a), t === "focusout" && I(b);
    }
    function Te() {
      sr("onMouseEnter", ["mouseout", "mouseover"]), sr("onMouseLeave", ["mouseout", "mouseover"]), sr("onPointerEnter", ["pointerout", "pointerover"]), sr("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function tt(e, t, a, l, c, p, g) {
      var b = t === "mouseover" || t === "pointerover", C = t === "mouseout" || t === "pointerout";
      if (b && !pv(l)) {
        var O = l.relatedTarget || l.fromElement;
        if (O && (gc(O) || Pp(O)))
          return;
      }
      if (!(!C && !b)) {
        var L;
        if (c.window === c)
          L = c;
        else {
          var B = c.ownerDocument;
          B ? L = B.defaultView || B.parentWindow : L = window;
        }
        var H, J;
        if (C) {
          var Z = l.relatedTarget || l.toElement;
          if (H = a, J = Z ? gc(Z) : null, J !== null) {
            var le = Vl(J);
            (J !== le || J.tag !== F && J.tag !== $) && (J = null);
          }
        } else
          H = null, J = a;
        if (H !== J) {
          var Be = Lf, ft = "onMouseLeave", rt = "onMouseEnter", It = "mouse";
          (t === "pointerout" || t === "pointerover") && (Be = Xv, ft = "onPointerLeave", rt = "onPointerEnter", It = "pointer");
          var jt = H == null ? L : qf(H), Q = J == null ? L : qf(J), oe = new Be(ft, It + "leave", H, l, c);
          oe.target = jt, oe.relatedTarget = Q;
          var q = null, be = gc(c);
          if (be === a) {
            var Ve = new Be(rt, It + "enter", J, l, c);
            Ve.target = Q, Ve.relatedTarget = jt, q = Ve;
          }
          tR(e, oe, q, H, J);
        }
      }
    }
    function pt(e, t) {
      return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
    }
    var Ge = typeof Object.is == "function" ? Object.is : pt;
    function ht(e, t) {
      if (Ge(e, t))
        return !0;
      if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
      var a = Object.keys(e), l = Object.keys(t);
      if (a.length !== l.length)
        return !1;
      for (var c = 0; c < a.length; c++) {
        var p = a[c];
        if (!Jn.call(t, p) || !Ge(e[p], t[p]))
          return !1;
      }
      return !0;
    }
    function or(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function Gt(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function vl(e, t) {
      for (var a = or(e), l = 0, c = 0; a; ) {
        if (a.nodeType === rl) {
          if (c = l + a.textContent.length, l <= t && c >= t)
            return {
              node: a,
              offset: t - l
            };
          l = c;
        }
        a = or(Gt(a));
      }
    }
    function Ug(e) {
      var t = e.ownerDocument, a = t && t.defaultView || window, l = a.getSelection && a.getSelection();
      if (!l || l.rangeCount === 0)
        return null;
      var c = l.anchorNode, p = l.anchorOffset, g = l.focusNode, b = l.focusOffset;
      try {
        c.nodeType, g.nodeType;
      } catch {
        return null;
      }
      return AT(e, c, p, g, b);
    }
    function AT(e, t, a, l, c) {
      var p = 0, g = -1, b = -1, C = 0, O = 0, L = e, B = null;
      e:
        for (; ; ) {
          for (var H = null; L === t && (a === 0 || L.nodeType === rl) && (g = p + a), L === l && (c === 0 || L.nodeType === rl) && (b = p + c), L.nodeType === rl && (p += L.nodeValue.length), (H = L.firstChild) !== null; )
            B = L, L = H;
          for (; ; ) {
            if (L === e)
              break e;
            if (B === t && ++C === a && (g = p), B === l && ++O === c && (b = p), (H = L.nextSibling) !== null)
              break;
            L = B, B = L.parentNode;
          }
          L = H;
        }
      return g === -1 || b === -1 ? null : {
        start: g,
        end: b
      };
    }
    function jT(e, t) {
      var a = e.ownerDocument || document, l = a && a.defaultView || window;
      if (l.getSelection) {
        var c = l.getSelection(), p = e.textContent.length, g = Math.min(t.start, p), b = t.end === void 0 ? g : Math.min(t.end, p);
        if (!c.extend && g > b) {
          var C = b;
          b = g, g = C;
        }
        var O = vl(e, g), L = vl(e, b);
        if (O && L) {
          if (c.rangeCount === 1 && c.anchorNode === O.node && c.anchorOffset === O.offset && c.focusNode === L.node && c.focusOffset === L.offset)
            return;
          var B = a.createRange();
          B.setStart(O.node, O.offset), c.removeAllRanges(), g > b ? (c.addRange(B), c.extend(L.node, L.offset)) : (B.setEnd(L.node, L.offset), c.addRange(B));
        }
      }
    }
    function Dx(e) {
      return e && e.nodeType === rl;
    }
    function Ox(e, t) {
      return !e || !t ? !1 : e === t ? !0 : Dx(e) ? !1 : Dx(t) ? Ox(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1;
    }
    function UT(e) {
      return e && e.ownerDocument && Ox(e.ownerDocument.documentElement, e);
    }
    function FT(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function Mx() {
      for (var e = window, t = Ra(); t instanceof e.HTMLIFrameElement; ) {
        if (FT(t))
          e = t.contentWindow;
        else
          return t;
        t = Ra(e.document);
      }
      return t;
    }
    function Fg(e) {
      var t = e && e.nodeName && e.nodeName.toLowerCase();
      return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
    }
    function PT() {
      var e = Mx();
      return {
        focusedElem: e,
        selectionRange: Fg(e) ? IT(e) : null
      };
    }
    function HT(e) {
      var t = Mx(), a = e.focusedElem, l = e.selectionRange;
      if (t !== a && UT(a)) {
        l !== null && Fg(a) && BT(a, l);
        for (var c = [], p = a; p = p.parentNode; )
          p.nodeType === ai && c.push({
            element: p,
            left: p.scrollLeft,
            top: p.scrollTop
          });
        typeof a.focus == "function" && a.focus();
        for (var g = 0; g < c.length; g++) {
          var b = c[g];
          b.element.scrollLeft = b.left, b.element.scrollTop = b.top;
        }
      }
    }
    function IT(e) {
      var t;
      return "selectionStart" in e ? t = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : t = Ug(e), t || {
        start: 0,
        end: 0
      };
    }
    function BT(e, t) {
      var a = t.start, l = t.end;
      l === void 0 && (l = a), "selectionStart" in e ? (e.selectionStart = a, e.selectionEnd = Math.min(l, e.value.length)) : jT(e, t);
    }
    var VT = kn && "documentMode" in document && document.documentMode <= 11;
    function $T() {
      Mr("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Vf = null, Pg = null, Tp = null, Hg = !1;
    function YT(e) {
      if ("selectionStart" in e && Fg(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var t = e.ownerDocument && e.ownerDocument.defaultView || window, a = t.getSelection();
      return {
        anchorNode: a.anchorNode,
        anchorOffset: a.anchorOffset,
        focusNode: a.focusNode,
        focusOffset: a.focusOffset
      };
    }
    function WT(e) {
      return e.window === e ? e.document : e.nodeType === Ci ? e : e.ownerDocument;
    }
    function Nx(e, t, a) {
      var l = WT(a);
      if (!(Hg || Vf == null || Vf !== Ra(l))) {
        var c = YT(Vf);
        if (!Tp || !ht(Tp, c)) {
          Tp = c;
          var p = im(Pg, "onSelect");
          if (p.length > 0) {
            var g = new Nf("onSelect", "select", null, t, a);
            e.push({
              event: g,
              listeners: p
            }), g.target = Vf;
          }
        }
      }
    }
    function QT(e, t, a, l, c, p, g) {
      var b = a ? qf(a) : window;
      switch (t) {
        case "focusin":
          (em(b) || b.contentEditable === "true") && (Vf = b, Pg = a, Tp = null);
          break;
        case "focusout":
          Vf = null, Pg = null, Tp = null;
          break;
        case "mousedown":
          Hg = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Hg = !1, Nx(e, l, c);
          break;
        case "selectionchange":
          if (VT)
            break;
        case "keydown":
        case "keyup":
          Nx(e, l, c);
      }
    }
    function tm(e, t) {
      var a = {};
      return a[e.toLowerCase()] = t.toLowerCase(), a["Webkit" + e] = "webkit" + t, a["Moz" + e] = "moz" + t, a;
    }
    var $f = {
      animationend: tm("Animation", "AnimationEnd"),
      animationiteration: tm("Animation", "AnimationIteration"),
      animationstart: tm("Animation", "AnimationStart"),
      transitionend: tm("Transition", "TransitionEnd")
    }, Ig = {}, Lx = {};
    kn && (Lx = document.createElement("div").style, "AnimationEvent" in window || (delete $f.animationend.animation, delete $f.animationiteration.animation, delete $f.animationstart.animation), "TransitionEvent" in window || delete $f.transitionend.transition);
    function nm(e) {
      if (Ig[e])
        return Ig[e];
      if (!$f[e])
        return e;
      var t = $f[e];
      for (var a in t)
        if (t.hasOwnProperty(a) && a in Lx)
          return Ig[e] = t[a];
      return e;
    }
    var zx = nm("animationend"), Ax = nm("animationiteration"), jx = nm("animationstart"), Ux = nm("transitionend"), Fx = /* @__PURE__ */ new Map(), Px = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function qu(e, t) {
      Fx.set(e, t), Mr(t, [e]);
    }
    function qT() {
      for (var e = 0; e < Px.length; e++) {
        var t = Px[e], a = t.toLowerCase(), l = t[0].toUpperCase() + t.slice(1);
        qu(a, "on" + l);
      }
      qu(zx, "onAnimationEnd"), qu(Ax, "onAnimationIteration"), qu(jx, "onAnimationStart"), qu("dblclick", "onDoubleClick"), qu("focusin", "onFocus"), qu("focusout", "onBlur"), qu(Ux, "onTransitionEnd");
    }
    function GT(e, t, a, l, c, p, g) {
      var b = Fx.get(t);
      if (b !== void 0) {
        var C = Nf, O = t;
        switch (t) {
          case "keypress":
            if ($o(l) === 0)
              return;
          case "keydown":
          case "keyup":
            C = qv;
            break;
          case "focusin":
            O = "focus", C = cc;
            break;
          case "focusout":
            O = "blur", C = cc;
            break;
          case "beforeblur":
          case "afterblur":
            C = cc;
            break;
          case "click":
            if (l.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            C = Lf;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            C = Bv;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            C = xp;
            break;
          case zx:
          case Ax:
          case jx:
            C = _g;
            break;
          case Ux:
            C = eo;
            break;
          case "scroll":
            C = mp;
            break;
          case "wheel":
            C = Qo;
            break;
          case "copy":
          case "cut":
          case "paste":
            C = $v;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            C = Xv;
            break;
        }
        var L = (p & Us) !== 0;
        {
          var B = !L && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          t === "scroll", H = ZT(a, b, l.type, L, B);
          if (H.length > 0) {
            var J = new C(b, O, null, l, c);
            e.push({
              event: J,
              listeners: H
            });
          }
        }
      }
    }
    qT(), Te(), n(), $T(), Ff();
    function XT(e, t, a, l, c, p, g) {
      GT(e, t, a, l, c, p);
      var b = (p & hg) === 0;
      b && (tt(e, t, a, l, c), G(e, t, a, l, c), QT(e, t, a, l, c), jg(e, t, a, l, c));
    }
    var Rp = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Bg = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Rp));
    function Hx(e, t, a) {
      var l = e.type || "unknown-event";
      e.currentTarget = a, Wd(l, t, void 0, e), e.currentTarget = null;
    }
    function KT(e, t, a) {
      var l;
      if (a)
        for (var c = t.length - 1; c >= 0; c--) {
          var p = t[c], g = p.instance, b = p.currentTarget, C = p.listener;
          if (g !== l && e.isPropagationStopped())
            return;
          Hx(e, C, b), l = g;
        }
      else
        for (var O = 0; O < t.length; O++) {
          var L = t[O], B = L.instance, H = L.currentTarget, J = L.listener;
          if (B !== l && e.isPropagationStopped())
            return;
          Hx(e, J, H), l = B;
        }
    }
    function Ix(e, t) {
      for (var a = (t & Us) !== 0, l = 0; l < e.length; l++) {
        var c = e[l], p = c.event, g = c.listeners;
        KT(p, g, a);
      }
      mg();
    }
    function JT(e, t, a, l, c) {
      var p = cn(a), g = [];
      XT(g, e, l, a, p, t), Ix(g, t);
    }
    function zn(e, t) {
      Bg.has(e) || v('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var a = !1, l = __(t), c = nR(e, a);
      l.has(c) || (Bx(t, e, js, a), l.add(c));
    }
    function Vg(e, t, a) {
      Bg.has(e) && !t && v('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var l = 0;
      t && (l |= Us), Bx(a, e, l, t);
    }
    var rm = "_reactListening" + Math.random().toString(36).slice(2);
    function _p(e) {
      if (!e[rm]) {
        e[rm] = !0, Qt.forEach(function(a) {
          a !== "selectionchange" && (Bg.has(a) || Vg(a, !1, e), Vg(a, !0, e));
        });
        var t = e.nodeType === Ci ? e : e.ownerDocument;
        t !== null && (t[rm] || (t[rm] = !0, Vg("selectionchange", !1, t)));
      }
    }
    function Bx(e, t, a, l, c) {
      var p = ar(e, t, a), g = void 0;
      Hs && (t === "touchstart" || t === "touchmove" || t === "wheel") && (g = !0), e = e, l ? g !== void 0 ? Df(e, t, p, g) : pl(e, t, p) : g !== void 0 ? vp(e, t, p, g) : $u(e, t, p);
    }
    function Vx(e, t) {
      return e === t || e.nodeType === Fn && e.parentNode === t;
    }
    function $g(e, t, a, l, c) {
      var p = l;
      if (!(t & Yc) && !(t & js)) {
        var g = c;
        if (l !== null) {
          var b = l;
          e:
            for (; ; ) {
              if (b === null)
                return;
              var C = b.tag;
              if (C === N || C === M) {
                var O = b.stateNode.containerInfo;
                if (Vx(O, g))
                  break;
                if (C === M)
                  for (var L = b.return; L !== null; ) {
                    var B = L.tag;
                    if (B === N || B === M) {
                      var H = L.stateNode.containerInfo;
                      if (Vx(H, g))
                        return;
                    }
                    L = L.return;
                  }
                for (; O !== null; ) {
                  var J = gc(O);
                  if (J === null)
                    return;
                  var Z = J.tag;
                  if (Z === F || Z === $) {
                    b = p = J;
                    continue e;
                  }
                  O = O.parentNode;
                }
              }
              b = b.return;
            }
        }
      }
      Ps(function() {
        return JT(e, t, a, p);
      });
    }
    function Dp(e, t, a) {
      return {
        instance: e,
        listener: t,
        currentTarget: a
      };
    }
    function ZT(e, t, a, l, c, p) {
      for (var g = t !== null ? t + "Capture" : null, b = l ? g : t, C = [], O = e, L = null; O !== null; ) {
        var B = O, H = B.stateNode, J = B.tag;
        if (J === F && H !== null && (L = H, b !== null)) {
          var Z = _o(O, b);
          Z != null && C.push(Dp(O, Z, L));
        }
        if (c)
          break;
        O = O.return;
      }
      return C;
    }
    function im(e, t) {
      for (var a = t + "Capture", l = [], c = e; c !== null; ) {
        var p = c, g = p.stateNode, b = p.tag;
        if (b === F && g !== null) {
          var C = g, O = _o(c, a);
          O != null && l.unshift(Dp(c, O, C));
          var L = _o(c, t);
          L != null && l.push(Dp(c, L, C));
        }
        c = c.return;
      }
      return l;
    }
    function Yf(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== F);
      return e || null;
    }
    function eR(e, t) {
      for (var a = e, l = t, c = 0, p = a; p; p = Yf(p))
        c++;
      for (var g = 0, b = l; b; b = Yf(b))
        g++;
      for (; c - g > 0; )
        a = Yf(a), c--;
      for (; g - c > 0; )
        l = Yf(l), g--;
      for (var C = c; C--; ) {
        if (a === l || l !== null && a === l.alternate)
          return a;
        a = Yf(a), l = Yf(l);
      }
      return null;
    }
    function $x(e, t, a, l, c) {
      for (var p = t._reactName, g = [], b = a; b !== null && b !== l; ) {
        var C = b, O = C.alternate, L = C.stateNode, B = C.tag;
        if (O !== null && O === l)
          break;
        if (B === F && L !== null) {
          var H = L;
          if (c) {
            var J = _o(b, p);
            J != null && g.unshift(Dp(b, J, H));
          } else if (!c) {
            var Z = _o(b, p);
            Z != null && g.push(Dp(b, Z, H));
          }
        }
        b = b.return;
      }
      g.length !== 0 && e.push({
        event: t,
        listeners: g
      });
    }
    function tR(e, t, a, l, c) {
      var p = l && c ? eR(l, c) : null;
      l !== null && $x(e, t, l, p, !1), c !== null && a !== null && $x(e, a, c, p, !0);
    }
    function nR(e, t) {
      return e + "__" + (t ? "capture" : "bubble");
    }
    var Ji = !1, Op = "dangerouslySetInnerHTML", am = "suppressContentEditableWarning", Gu = "suppressHydrationWarning", Yx = "autoFocus", mc = "children", yc = "style", lm = "__html", Yg, om, Mp, Wx, um, Qx, qx;
    Yg = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, om = function(e, t) {
      gu(e, t), ov(e, t), Pl(e, t, {
        registrationNameDependencies: wn,
        possibleRegistrationNames: An
      });
    }, Qx = kn && !document.documentMode, Mp = function(e, t, a) {
      if (!Ji) {
        var l = sm(a), c = sm(t);
        c !== l && (Ji = !0, v("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(c), JSON.stringify(l)));
      }
    }, Wx = function(e) {
      if (!Ji) {
        Ji = !0;
        var t = [];
        e.forEach(function(a) {
          t.push(a);
        }), v("Extra attributes from the server: %s", t);
      }
    }, um = function(e, t) {
      t === !1 ? v("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : v("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof t);
    }, qx = function(e, t) {
      var a = e.namespaceURI === nl ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return a.innerHTML = t, a.innerHTML;
    };
    var rR = /\r\n?/g, iR = /\u0000|\uFFFD/g;
    function sm(e) {
      Pr(e);
      var t = typeof e == "string" ? e : "" + e;
      return t.replace(rR, `
`).replace(iR, "");
    }
    function cm(e, t, a, l) {
      var c = sm(t), p = sm(e);
      if (p !== c && (l && (Ji || (Ji = !0, v('Text content did not match. Server: "%s" Client: "%s"', p, c))), a && ae))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function Gx(e) {
      return e.nodeType === Ci ? e : e.ownerDocument;
    }
    function aR() {
    }
    function fm(e) {
      e.onclick = aR;
    }
    function lR(e, t, a, l, c) {
      for (var p in l)
        if (l.hasOwnProperty(p)) {
          var g = l[p];
          if (p === yc)
            g && Object.freeze(g), tv(t, g);
          else if (p === Op) {
            var b = g ? g[lm] : void 0;
            b != null && Wh(t, b);
          } else if (p === mc)
            if (typeof g == "string") {
              var C = e !== "textarea" || g !== "";
              C && Os(t, g);
            } else
              typeof g == "number" && Os(t, "" + g);
          else
            p === am || p === Gu || p === Yx || (wn.hasOwnProperty(p) ? g != null && (typeof g != "function" && um(p, g), p === "onScroll" && zn("scroll", t)) : g != null && qa(t, p, g, c));
        }
    }
    function oR(e, t, a, l) {
      for (var c = 0; c < t.length; c += 2) {
        var p = t[c], g = t[c + 1];
        p === yc ? tv(e, g) : p === Op ? Wh(e, g) : p === mc ? Os(e, g) : qa(e, p, g, l);
      }
    }
    function uR(e, t, a, l) {
      var c, p = Gx(a), g, b = l;
      if (b === nl && (b = _d(e)), b === nl) {
        if (c = ko(e, t), !c && e !== e.toLowerCase() && v("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var C = p.createElement("div");
          C.innerHTML = "<script><\/script>";
          var O = C.firstChild;
          g = C.removeChild(O);
        } else if (typeof t.is == "string")
          g = p.createElement(e, {
            is: t.is
          });
        else if (g = p.createElement(e), e === "select") {
          var L = g;
          t.multiple ? L.multiple = !0 : t.size && (L.size = t.size);
        }
      } else
        g = p.createElementNS(b, e);
      return b === nl && !c && Object.prototype.toString.call(g) === "[object HTMLUnknownElement]" && !Jn.call(Yg, e) && (Yg[e] = !0, v("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), g;
    }
    function sR(e, t) {
      return Gx(t).createTextNode(e);
    }
    function cR(e, t, a, l) {
      var c = ko(t, a);
      om(t, a);
      var p;
      switch (t) {
        case "dialog":
          zn("cancel", e), zn("close", e), p = a;
          break;
        case "iframe":
        case "object":
        case "embed":
          zn("load", e), p = a;
          break;
        case "video":
        case "audio":
          for (var g = 0; g < Rp.length; g++)
            zn(Rp[g], e);
          p = a;
          break;
        case "source":
          zn("error", e), p = a;
          break;
        case "img":
        case "image":
        case "link":
          zn("error", e), zn("load", e), p = a;
          break;
        case "details":
          zn("toggle", e), p = a;
          break;
        case "input":
          j(e, a), p = k(e, a), zn("invalid", e);
          break;
        case "option":
          rn(e, a), p = a;
          break;
        case "select":
          Ds(e, a), p = _s(e, a), zn("invalid", e);
          break;
        case "textarea":
          $h(e, a), p = Rd(e, a), zn("invalid", e);
          break;
        default:
          p = a;
      }
      switch (Ls(t, p), lR(t, e, l, p, c), t) {
        case "input":
          Za(e), ke(e, a, !1);
          break;
        case "textarea":
          Za(e), Fc(e);
          break;
        case "option":
          an(e, a);
          break;
        case "select":
          Td(e, a);
          break;
        default:
          typeof p.onClick == "function" && fm(e);
          break;
      }
    }
    function fR(e, t, a, l, c) {
      om(t, l);
      var p = null, g, b;
      switch (t) {
        case "input":
          g = k(e, a), b = k(e, l), p = [];
          break;
        case "select":
          g = _s(e, a), b = _s(e, l), p = [];
          break;
        case "textarea":
          g = Rd(e, a), b = Rd(e, l), p = [];
          break;
        default:
          g = a, b = l, typeof g.onClick != "function" && typeof b.onClick == "function" && fm(e);
          break;
      }
      Ls(t, b);
      var C, O, L = null;
      for (C in g)
        if (!(b.hasOwnProperty(C) || !g.hasOwnProperty(C) || g[C] == null))
          if (C === yc) {
            var B = g[C];
            for (O in B)
              B.hasOwnProperty(O) && (L || (L = {}), L[O] = "");
          } else
            C === Op || C === mc || C === am || C === Gu || C === Yx || (wn.hasOwnProperty(C) ? p || (p = []) : (p = p || []).push(C, null));
      for (C in b) {
        var H = b[C], J = g != null ? g[C] : void 0;
        if (!(!b.hasOwnProperty(C) || H === J || H == null && J == null))
          if (C === yc)
            if (H && Object.freeze(H), J) {
              for (O in J)
                J.hasOwnProperty(O) && (!H || !H.hasOwnProperty(O)) && (L || (L = {}), L[O] = "");
              for (O in H)
                H.hasOwnProperty(O) && J[O] !== H[O] && (L || (L = {}), L[O] = H[O]);
            } else
              L || (p || (p = []), p.push(C, L)), L = H;
          else if (C === Op) {
            var Z = H ? H[lm] : void 0, le = J ? J[lm] : void 0;
            Z != null && le !== Z && (p = p || []).push(C, Z);
          } else
            C === mc ? (typeof H == "string" || typeof H == "number") && (p = p || []).push(C, "" + H) : C === am || C === Gu || (wn.hasOwnProperty(C) ? (H != null && (typeof H != "function" && um(C, H), C === "onScroll" && zn("scroll", e)), !p && J !== H && (p = [])) : (p = p || []).push(C, H));
      }
      return L && (nv(L, b[yc]), (p = p || []).push(yc, L)), p;
    }
    function dR(e, t, a, l, c) {
      a === "input" && c.type === "radio" && c.name != null && K(e, c);
      var p = ko(a, l), g = ko(a, c);
      switch (oR(e, t, p, g), a) {
        case "input":
          ie(e, c);
          break;
        case "textarea":
          Yh(e, c);
          break;
        case "select":
          rg(e, c);
          break;
      }
    }
    function pR(e) {
      {
        var t = e.toLowerCase();
        return Bc.hasOwnProperty(t) && Bc[t] || null;
      }
    }
    function hR(e, t, a, l, c, p, g) {
      var b, C;
      switch (b = ko(t, a), om(t, a), t) {
        case "dialog":
          zn("cancel", e), zn("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          zn("load", e);
          break;
        case "video":
        case "audio":
          for (var O = 0; O < Rp.length; O++)
            zn(Rp[O], e);
          break;
        case "source":
          zn("error", e);
          break;
        case "img":
        case "image":
        case "link":
          zn("error", e), zn("load", e);
          break;
        case "details":
          zn("toggle", e);
          break;
        case "input":
          j(e, a), zn("invalid", e);
          break;
        case "option":
          rn(e, a);
          break;
        case "select":
          Ds(e, a), zn("invalid", e);
          break;
        case "textarea":
          $h(e, a), zn("invalid", e);
          break;
      }
      Ls(t, a);
      {
        C = /* @__PURE__ */ new Set();
        for (var L = e.attributes, B = 0; B < L.length; B++) {
          var H = L[B].name.toLowerCase();
          switch (H) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              C.add(L[B].name);
          }
        }
      }
      var J = null;
      for (var Z in a)
        if (a.hasOwnProperty(Z)) {
          var le = a[Z];
          if (Z === mc)
            typeof le == "string" ? e.textContent !== le && (a[Gu] !== !0 && cm(e.textContent, le, p, g), J = [mc, le]) : typeof le == "number" && e.textContent !== "" + le && (a[Gu] !== !0 && cm(e.textContent, le, p, g), J = [mc, "" + le]);
          else if (wn.hasOwnProperty(Z))
            le != null && (typeof le != "function" && um(Z, le), Z === "onScroll" && zn("scroll", e));
          else if (g && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof b == "boolean") {
            var Be = void 0, ft = b && Ke ? null : dr(Z);
            if (a[Gu] !== !0) {
              if (!(Z === am || Z === Gu || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Z === "value" || Z === "checked" || Z === "selected")) {
                if (Z === Op) {
                  var rt = e.innerHTML, It = le ? le[lm] : void 0;
                  if (It != null) {
                    var jt = qx(e, It);
                    jt !== rt && Mp(Z, rt, jt);
                  }
                } else if (Z === yc) {
                  if (C.delete(Z), Qx) {
                    var Q = pg(le);
                    Be = e.getAttribute("style"), Q !== Be && Mp(Z, Be, Q);
                  }
                } else if (b && !Ke)
                  C.delete(Z.toLowerCase()), Be = ji(e, Z, le), le !== Be && Mp(Z, Be, le);
                else if (!Yt(Z, ft, b) && !tn(Z, le, ft, b)) {
                  var oe = !1;
                  if (ft !== null)
                    C.delete(ft.attributeName), Be = ca(e, Z, le, ft);
                  else {
                    var q = l;
                    if (q === nl && (q = _d(t)), q === nl)
                      C.delete(Z.toLowerCase());
                    else {
                      var be = pR(Z);
                      be !== null && be !== Z && (oe = !0, C.delete(be)), C.delete(Z);
                    }
                    Be = ji(e, Z, le);
                  }
                  var Ve = Ke;
                  !Ve && le !== Be && !oe && Mp(Z, Be, le);
                }
              }
            }
          }
        }
      switch (g && // $FlowFixMe - Should be inferred as not undefined.
      C.size > 0 && a[Gu] !== !0 && Wx(C), t) {
        case "input":
          Za(e), ke(e, a, !0);
          break;
        case "textarea":
          Za(e), Fc(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof a.onClick == "function" && fm(e);
          break;
      }
      return J;
    }
    function vR(e, t, a) {
      var l = e.nodeValue !== t;
      return l;
    }
    function Wg(e, t) {
      {
        if (Ji)
          return;
        Ji = !0, v("Did not expect server HTML to contain a <%s> in <%s>.", t.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function Qg(e, t) {
      {
        if (Ji)
          return;
        Ji = !0, v('Did not expect server HTML to contain the text node "%s" in <%s>.', t.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function qg(e, t, a) {
      {
        if (Ji)
          return;
        Ji = !0, v("Expected server HTML to contain a matching <%s> in <%s>.", t, e.nodeName.toLowerCase());
      }
    }
    function Gg(e, t) {
      {
        if (t === "" || Ji)
          return;
        Ji = !0, v('Expected server HTML to contain a matching text node for "%s" in <%s>.', t, e.nodeName.toLowerCase());
      }
    }
    function mR(e, t, a) {
      switch (t) {
        case "input":
          Je(e, a);
          return;
        case "textarea":
          ig(e, a);
          return;
        case "select":
          Bh(e, a);
          return;
      }
    }
    var Np = function() {
    }, Lp = function() {
    };
    {
      var yR = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], Xx = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], gR = Xx.concat(["button"]), SR = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], Kx = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Lp = function(e, t) {
        var a = Mt({}, e || Kx), l = {
          tag: t
        };
        return Xx.indexOf(t) !== -1 && (a.aTagInScope = null, a.buttonTagInScope = null, a.nobrTagInScope = null), gR.indexOf(t) !== -1 && (a.pTagInButtonScope = null), yR.indexOf(t) !== -1 && t !== "address" && t !== "div" && t !== "p" && (a.listItemTagAutoclosing = null, a.dlItemTagAutoclosing = null), a.current = l, t === "form" && (a.formTag = l), t === "a" && (a.aTagInScope = l), t === "button" && (a.buttonTagInScope = l), t === "nobr" && (a.nobrTagInScope = l), t === "p" && (a.pTagInButtonScope = l), t === "li" && (a.listItemTagAutoclosing = l), (t === "dd" || t === "dt") && (a.dlItemTagAutoclosing = l), a;
      };
      var xR = function(e, t) {
        switch (t) {
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          case "option":
            return e === "#text";
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          case "colgroup":
            return e === "col" || e === "template";
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t !== "h1" && t !== "h2" && t !== "h3" && t !== "h4" && t !== "h5" && t !== "h6";
          case "rp":
          case "rt":
            return SR.indexOf(t) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return t == null;
        }
        return !0;
      }, bR = function(e, t) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t.pTagInButtonScope;
          case "form":
            return t.formTag || t.pTagInButtonScope;
          case "li":
            return t.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return t.dlItemTagAutoclosing;
          case "button":
            return t.buttonTagInScope;
          case "a":
            return t.aTagInScope;
          case "nobr":
            return t.nobrTagInScope;
        }
        return null;
      }, Jx = {};
      Np = function(e, t, a) {
        a = a || Kx;
        var l = a.current, c = l && l.tag;
        t != null && (e != null && v("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var p = xR(e, c) ? null : l, g = p ? null : bR(e, a), b = p || g;
        if (b) {
          var C = b.tag, O = !!p + "|" + e + "|" + C;
          if (!Jx[O]) {
            Jx[O] = !0;
            var L = e, B = "";
            if (e === "#text" ? /\S/.test(t) ? L = "Text nodes" : (L = "Whitespace text nodes", B = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : L = "<" + e + ">", p) {
              var H = "";
              C === "table" && e === "tr" && (H += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), v("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", L, C, B, H);
            } else
              v("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", L, C);
          }
        }
      };
    }
    var dm = "suppressHydrationWarning", pm = "$", hm = "/$", zp = "$?", Ap = "$!", ER = "style", Xg = null, Kg = null;
    function CR(e) {
      var t, a, l = e.nodeType;
      switch (l) {
        case Ci:
        case Od: {
          t = l === Ci ? "#document" : "#fragment";
          var c = e.documentElement;
          a = c ? c.namespaceURI : Dd(null, "");
          break;
        }
        default: {
          var p = l === Fn ? e.parentNode : e, g = p.namespaceURI || null;
          t = p.tagName, a = Dd(g, t);
          break;
        }
      }
      {
        var b = t.toLowerCase(), C = Lp(null, b);
        return {
          namespace: a,
          ancestorInfo: C
        };
      }
    }
    function wR(e, t, a) {
      {
        var l = e, c = Dd(l.namespace, t), p = Lp(l.ancestorInfo, t);
        return {
          namespace: c,
          ancestorInfo: p
        };
      }
    }
    function Bz(e) {
      return e;
    }
    function kR(e) {
      Xg = Bu(), Kg = PT();
      var t = null;
      return vi(!1), t;
    }
    function TR(e) {
      HT(Kg), vi(Xg), Xg = null, Kg = null;
    }
    function RR(e, t, a, l, c) {
      var p;
      {
        var g = l;
        if (Np(e, null, g.ancestorInfo), typeof t.children == "string" || typeof t.children == "number") {
          var b = "" + t.children, C = Lp(g.ancestorInfo, e);
          Np(null, b, C);
        }
        p = g.namespace;
      }
      var O = uR(e, t, a, p);
      return Fp(c, O), a0(O, t), O;
    }
    function _R(e, t) {
      e.appendChild(t);
    }
    function DR(e, t, a, l, c) {
      switch (cR(e, t, a, l), t) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!a.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function OR(e, t, a, l, c, p) {
      {
        var g = p;
        if (typeof l.children != typeof a.children && (typeof l.children == "string" || typeof l.children == "number")) {
          var b = "" + l.children, C = Lp(g.ancestorInfo, t);
          Np(null, b, C);
        }
      }
      return fR(e, t, a, l);
    }
    function Jg(e, t) {
      return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
    }
    function MR(e, t, a, l) {
      {
        var c = a;
        Np(null, e, c.ancestorInfo);
      }
      var p = sR(e, t);
      return Fp(l, p), p;
    }
    function NR() {
      var e = window.event;
      return e === void 0 ? Aa : _f(e.type);
    }
    var Zg = typeof setTimeout == "function" ? setTimeout : void 0, LR = typeof clearTimeout == "function" ? clearTimeout : void 0, e0 = -1, Zx = typeof Promise == "function" ? Promise : void 0, zR = typeof queueMicrotask == "function" ? queueMicrotask : typeof Zx < "u" ? function(e) {
      return Zx.resolve(null).then(e).catch(AR);
    } : Zg;
    function AR(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function jR(e, t, a, l) {
      switch (t) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          a.autoFocus && e.focus();
          return;
        case "img": {
          a.src && (e.src = a.src);
          return;
        }
      }
    }
    function UR(e, t, a, l, c, p) {
      dR(e, t, a, l, c), a0(e, c);
    }
    function eb(e) {
      Os(e, "");
    }
    function FR(e, t, a) {
      e.nodeValue = a;
    }
    function PR(e, t) {
      e.appendChild(t);
    }
    function HR(e, t) {
      var a;
      e.nodeType === Fn ? (a = e.parentNode, a.insertBefore(t, e)) : (a = e, a.appendChild(t));
      var l = e._reactRootContainer;
      l == null && a.onclick === null && fm(a);
    }
    function IR(e, t, a) {
      e.insertBefore(t, a);
    }
    function BR(e, t, a) {
      e.nodeType === Fn ? e.parentNode.insertBefore(t, a) : e.insertBefore(t, a);
    }
    function VR(e, t) {
      e.removeChild(t);
    }
    function $R(e, t) {
      e.nodeType === Fn ? e.parentNode.removeChild(t) : e.removeChild(t);
    }
    function t0(e, t) {
      var a = t, l = 0;
      do {
        var c = a.nextSibling;
        if (e.removeChild(a), c && c.nodeType === Fn) {
          var p = c.data;
          if (p === hm)
            if (l === 0) {
              e.removeChild(c), Bn(t);
              return;
            } else
              l--;
          else
            (p === pm || p === zp || p === Ap) && l++;
        }
        a = c;
      } while (a);
      Bn(t);
    }
    function YR(e, t) {
      e.nodeType === Fn ? t0(e.parentNode, t) : e.nodeType === ai && t0(e, t), Bn(e);
    }
    function WR(e) {
      e = e;
      var t = e.style;
      typeof t.setProperty == "function" ? t.setProperty("display", "none", "important") : t.display = "none";
    }
    function QR(e) {
      e.nodeValue = "";
    }
    function qR(e, t) {
      e = e;
      var a = t[ER], l = a != null && a.hasOwnProperty("display") ? a.display : null;
      e.style.display = Ul("display", l);
    }
    function GR(e, t) {
      e.nodeValue = t;
    }
    function XR(e) {
      e.nodeType === ai ? e.textContent = "" : e.nodeType === Ci && e.documentElement && e.removeChild(e.documentElement);
    }
    function KR(e, t, a) {
      return e.nodeType !== ai || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function JR(e, t) {
      return t === "" || e.nodeType !== rl ? null : e;
    }
    function ZR(e) {
      return e.nodeType !== Fn ? null : e;
    }
    function tb(e) {
      return e.data === zp;
    }
    function n0(e) {
      return e.data === Ap;
    }
    function e_(e) {
      var t = e.nextSibling && e.nextSibling.dataset, a, l, c;
      return t && (a = t.dgst, l = t.msg, c = t.stck), {
        message: l,
        digest: a,
        stack: c
      };
    }
    function t_(e, t) {
      e._reactRetry = t;
    }
    function vm(e) {
      for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === ai || t === rl)
          break;
        if (t === Fn) {
          var a = e.data;
          if (a === pm || a === Ap || a === zp)
            break;
          if (a === hm)
            return null;
        }
      }
      return e;
    }
    function jp(e) {
      return vm(e.nextSibling);
    }
    function n_(e) {
      return vm(e.firstChild);
    }
    function r_(e) {
      return vm(e.firstChild);
    }
    function i_(e) {
      return vm(e.nextSibling);
    }
    function a_(e, t, a, l, c, p, g) {
      Fp(p, e), a0(e, a);
      var b;
      {
        var C = c;
        b = C.namespace;
      }
      var O = (p.mode & nt) !== ct;
      return hR(e, t, a, b, l, O, g);
    }
    function l_(e, t, a, l) {
      return Fp(a, e), a.mode & nt, vR(e, t);
    }
    function o_(e, t) {
      Fp(t, e);
    }
    function u_(e) {
      for (var t = e.nextSibling, a = 0; t; ) {
        if (t.nodeType === Fn) {
          var l = t.data;
          if (l === hm) {
            if (a === 0)
              return jp(t);
            a--;
          } else
            (l === pm || l === Ap || l === zp) && a++;
        }
        t = t.nextSibling;
      }
      return null;
    }
    function nb(e) {
      for (var t = e.previousSibling, a = 0; t; ) {
        if (t.nodeType === Fn) {
          var l = t.data;
          if (l === pm || l === Ap || l === zp) {
            if (a === 0)
              return t;
            a--;
          } else
            l === hm && a++;
        }
        t = t.previousSibling;
      }
      return null;
    }
    function s_(e) {
      Bn(e);
    }
    function c_(e) {
      Bn(e);
    }
    function f_(e) {
      return e !== "head" && e !== "body";
    }
    function d_(e, t, a, l) {
      var c = !0;
      cm(t.nodeValue, a, l, c);
    }
    function p_(e, t, a, l, c, p) {
      if (t[dm] !== !0) {
        var g = !0;
        cm(l.nodeValue, c, p, g);
      }
    }
    function h_(e, t) {
      t.nodeType === ai ? Wg(e, t) : t.nodeType === Fn || Qg(e, t);
    }
    function v_(e, t) {
      {
        var a = e.parentNode;
        a !== null && (t.nodeType === ai ? Wg(a, t) : t.nodeType === Fn || Qg(a, t));
      }
    }
    function m_(e, t, a, l, c) {
      (c || t[dm] !== !0) && (l.nodeType === ai ? Wg(a, l) : l.nodeType === Fn || Qg(a, l));
    }
    function y_(e, t, a) {
      qg(e, t);
    }
    function g_(e, t) {
      Gg(e, t);
    }
    function S_(e, t, a) {
      {
        var l = e.parentNode;
        l !== null && qg(l, t);
      }
    }
    function x_(e, t) {
      {
        var a = e.parentNode;
        a !== null && Gg(a, t);
      }
    }
    function b_(e, t, a, l, c, p) {
      (p || t[dm] !== !0) && qg(a, l);
    }
    function E_(e, t, a, l, c) {
      (c || t[dm] !== !0) && Gg(a, l);
    }
    function C_(e) {
      v("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function w_(e) {
      _p(e);
    }
    var Wf = Math.random().toString(36).slice(2), Qf = "__reactFiber$" + Wf, r0 = "__reactProps$" + Wf, Up = "__reactContainer$" + Wf, i0 = "__reactEvents$" + Wf, k_ = "__reactListeners$" + Wf, T_ = "__reactHandles$" + Wf;
    function R_(e) {
      delete e[Qf], delete e[r0], delete e[i0], delete e[k_], delete e[T_];
    }
    function Fp(e, t) {
      t[Qf] = e;
    }
    function mm(e, t) {
      t[Up] = e;
    }
    function rb(e) {
      e[Up] = null;
    }
    function Pp(e) {
      return !!e[Up];
    }
    function gc(e) {
      var t = e[Qf];
      if (t)
        return t;
      for (var a = e.parentNode; a; ) {
        if (t = a[Up] || a[Qf], t) {
          var l = t.alternate;
          if (t.child !== null || l !== null && l.child !== null)
            for (var c = nb(e); c !== null; ) {
              var p = c[Qf];
              if (p)
                return p;
              c = nb(c);
            }
          return t;
        }
        e = a, a = e.parentNode;
      }
      return null;
    }
    function Xu(e) {
      var t = e[Qf] || e[Up];
      return t && (t.tag === F || t.tag === $ || t.tag === Y || t.tag === N) ? t : null;
    }
    function qf(e) {
      if (e.tag === F || e.tag === $)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function ym(e) {
      return e[r0] || null;
    }
    function a0(e, t) {
      e[r0] = t;
    }
    function __(e) {
      var t = e[i0];
      return t === void 0 && (t = e[i0] = /* @__PURE__ */ new Set()), t;
    }
    var ib = {}, ab = f.ReactDebugCurrentFrame;
    function gm(e) {
      if (e) {
        var t = e._owner, a = Ft(e.type, e._source, t ? t.type : null);
        ab.setExtraStackFrame(a);
      } else
        ab.setExtraStackFrame(null);
    }
    function ml(e, t, a, l, c) {
      {
        var p = Function.call.bind(Jn);
        for (var g in e)
          if (p(e, g)) {
            var b = void 0;
            try {
              if (typeof e[g] != "function") {
                var C = Error((l || "React class") + ": " + a + " type `" + g + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[g] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw C.name = "Invariant Violation", C;
              }
              b = e[g](t, g, l, a, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (O) {
              b = O;
            }
            b && !(b instanceof Error) && (gm(c), v("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", l || "React class", a, g, typeof b), gm(null)), b instanceof Error && !(b.message in ib) && (ib[b.message] = !0, gm(c), v("Failed %s type: %s", a, b.message), gm(null));
          }
      }
    }
    var l0 = [], Sm;
    Sm = [];
    var qo = -1;
    function Ku(e) {
      return {
        current: e
      };
    }
    function mi(e, t) {
      if (qo < 0) {
        v("Unexpected pop.");
        return;
      }
      t !== Sm[qo] && v("Unexpected Fiber popped."), e.current = l0[qo], l0[qo] = null, Sm[qo] = null, qo--;
    }
    function yi(e, t, a) {
      qo++, l0[qo] = e.current, Sm[qo] = a, e.current = t;
    }
    var o0;
    o0 = {};
    var ga = {};
    Object.freeze(ga);
    var Go = Ku(ga), no = Ku(!1), u0 = ga;
    function Gf(e, t, a) {
      return a && ro(t) ? u0 : Go.current;
    }
    function lb(e, t, a) {
      {
        var l = e.stateNode;
        l.__reactInternalMemoizedUnmaskedChildContext = t, l.__reactInternalMemoizedMaskedChildContext = a;
      }
    }
    function Xf(e, t) {
      {
        var a = e.type, l = a.contextTypes;
        if (!l)
          return ga;
        var c = e.stateNode;
        if (c && c.__reactInternalMemoizedUnmaskedChildContext === t)
          return c.__reactInternalMemoizedMaskedChildContext;
        var p = {};
        for (var g in l)
          p[g] = t[g];
        {
          var b = xt(e) || "Unknown";
          ml(l, p, "context", b);
        }
        return c && lb(e, t, p), p;
      }
    }
    function xm() {
      return no.current;
    }
    function ro(e) {
      {
        var t = e.childContextTypes;
        return t != null;
      }
    }
    function bm(e) {
      mi(no, e), mi(Go, e);
    }
    function s0(e) {
      mi(no, e), mi(Go, e);
    }
    function ob(e, t, a) {
      {
        if (Go.current !== ga)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        yi(Go, t, e), yi(no, a, e);
      }
    }
    function ub(e, t, a) {
      {
        var l = e.stateNode, c = t.childContextTypes;
        if (typeof l.getChildContext != "function") {
          {
            var p = xt(e) || "Unknown";
            o0[p] || (o0[p] = !0, v("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", p, p));
          }
          return a;
        }
        var g = l.getChildContext();
        for (var b in g)
          if (!(b in c))
            throw new Error((xt(e) || "Unknown") + '.getChildContext(): key "' + b + '" is not defined in childContextTypes.');
        {
          var C = xt(e) || "Unknown";
          ml(c, g, "child context", C);
        }
        return Mt({}, a, g);
      }
    }
    function Em(e) {
      {
        var t = e.stateNode, a = t && t.__reactInternalMemoizedMergedChildContext || ga;
        return u0 = Go.current, yi(Go, a, e), yi(no, no.current, e), !0;
      }
    }
    function sb(e, t, a) {
      {
        var l = e.stateNode;
        if (!l)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (a) {
          var c = ub(e, t, u0);
          l.__reactInternalMemoizedMergedChildContext = c, mi(no, e), mi(Go, e), yi(Go, c, e), yi(no, a, e);
        } else
          mi(no, e), yi(no, a, e);
      }
    }
    function D_(e) {
      {
        if (!Ti(e) || e.tag !== R)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var t = e;
        do {
          switch (t.tag) {
            case N:
              return t.stateNode.context;
            case R: {
              var a = t.type;
              if (ro(a))
                return t.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          t = t.return;
        } while (t !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Ju = 0, Cm = 1, Xo = null, c0 = !1, f0 = !1;
    function cb(e) {
      Xo === null ? Xo = [e] : Xo.push(e);
    }
    function O_(e) {
      c0 = !0, cb(e);
    }
    function fb() {
      c0 && Zu();
    }
    function Zu() {
      if (!f0 && Xo !== null) {
        f0 = !0;
        var e = 0, t = Qi();
        try {
          var a = !0, l = Xo;
          for (In(Gn); e < l.length; e++) {
            var c = l[e];
            do
              c = c(a);
            while (c !== null);
          }
          Xo = null, c0 = !1;
        } catch (p) {
          throw Xo !== null && (Xo = Xo.slice(e + 1)), Xd(ci, Zu), p;
        } finally {
          In(t), f0 = !1;
        }
      }
      return null;
    }
    var Kf = [], Jf = 0, wm = null, km = 0, Pa = [], Ha = 0, Sc = null, Ko = 1, Jo = "";
    function M_(e) {
      return bc(), (e.flags & gv) !== st;
    }
    function N_(e) {
      return bc(), km;
    }
    function L_() {
      var e = Jo, t = Ko, a = t & ~z_(t);
      return a.toString(32) + e;
    }
    function xc(e, t) {
      bc(), Kf[Jf++] = km, Kf[Jf++] = wm, wm = e, km = t;
    }
    function db(e, t, a) {
      bc(), Pa[Ha++] = Ko, Pa[Ha++] = Jo, Pa[Ha++] = Sc, Sc = e;
      var l = Ko, c = Jo, p = Tm(l) - 1, g = l & ~(1 << p), b = a + 1, C = Tm(t) + p;
      if (C > 30) {
        var O = p - p % 5, L = (1 << O) - 1, B = (g & L).toString(32), H = g >> O, J = p - O, Z = Tm(t) + J, le = b << J, Be = le | H, ft = B + c;
        Ko = 1 << Z | Be, Jo = ft;
      } else {
        var rt = b << p, It = rt | g, jt = c;
        Ko = 1 << C | It, Jo = jt;
      }
    }
    function d0(e) {
      bc();
      var t = e.return;
      if (t !== null) {
        var a = 1, l = 0;
        xc(e, a), db(e, a, l);
      }
    }
    function Tm(e) {
      return 32 - Gs(e);
    }
    function z_(e) {
      return 1 << Tm(e) - 1;
    }
    function p0(e) {
      for (; e === wm; )
        wm = Kf[--Jf], Kf[Jf] = null, km = Kf[--Jf], Kf[Jf] = null;
      for (; e === Sc; )
        Sc = Pa[--Ha], Pa[Ha] = null, Jo = Pa[--Ha], Pa[Ha] = null, Ko = Pa[--Ha], Pa[Ha] = null;
    }
    function A_() {
      return bc(), Sc !== null ? {
        id: Ko,
        overflow: Jo
      } : null;
    }
    function j_(e, t) {
      bc(), Pa[Ha++] = Ko, Pa[Ha++] = Jo, Pa[Ha++] = Sc, Ko = t.id, Jo = t.overflow, Sc = e;
    }
    function bc() {
      Yr() || v("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var $r = null, Ia = null, yl = !1, Ec = !1, es = null;
    function U_() {
      yl && v("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function pb() {
      Ec = !0;
    }
    function F_() {
      return Ec;
    }
    function P_(e) {
      var t = e.stateNode.containerInfo;
      return Ia = r_(t), $r = e, yl = !0, es = null, Ec = !1, !0;
    }
    function H_(e, t, a) {
      return Ia = i_(t), $r = e, yl = !0, es = null, Ec = !1, a !== null && j_(e, a), !0;
    }
    function hb(e, t) {
      switch (e.tag) {
        case N: {
          h_(e.stateNode.containerInfo, t);
          break;
        }
        case F: {
          var a = (e.mode & nt) !== ct;
          m_(
            e.type,
            e.memoizedProps,
            e.stateNode,
            t,
            // TODO: Delete this argument when we remove the legacy root API.
            a
          );
          break;
        }
        case Y: {
          var l = e.memoizedState;
          l.dehydrated !== null && v_(l.dehydrated, t);
          break;
        }
      }
    }
    function vb(e, t) {
      hb(e, t);
      var a = VM();
      a.stateNode = t, a.return = e;
      var l = e.deletions;
      l === null ? (e.deletions = [a], e.flags |= qt) : l.push(a);
    }
    function h0(e, t) {
      {
        if (Ec)
          return;
        switch (e.tag) {
          case N: {
            var a = e.stateNode.containerInfo;
            switch (t.tag) {
              case F:
                var l = t.type;
                t.pendingProps, y_(a, l);
                break;
              case $:
                var c = t.pendingProps;
                g_(a, c);
                break;
            }
            break;
          }
          case F: {
            var p = e.type, g = e.memoizedProps, b = e.stateNode;
            switch (t.tag) {
              case F: {
                var C = t.type, O = t.pendingProps, L = (e.mode & nt) !== ct;
                b_(
                  p,
                  g,
                  b,
                  C,
                  O,
                  // TODO: Delete this argument when we remove the legacy root API.
                  L
                );
                break;
              }
              case $: {
                var B = t.pendingProps, H = (e.mode & nt) !== ct;
                E_(
                  p,
                  g,
                  b,
                  B,
                  // TODO: Delete this argument when we remove the legacy root API.
                  H
                );
                break;
              }
            }
            break;
          }
          case Y: {
            var J = e.memoizedState, Z = J.dehydrated;
            if (Z !== null)
              switch (t.tag) {
                case F:
                  var le = t.type;
                  t.pendingProps, S_(Z, le);
                  break;
                case $:
                  var Be = t.pendingProps;
                  x_(Z, Be);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function mb(e, t) {
      t.flags = t.flags & ~Oa | fn, h0(e, t);
    }
    function yb(e, t) {
      switch (e.tag) {
        case F: {
          var a = e.type;
          e.pendingProps;
          var l = KR(t, a);
          return l !== null ? (e.stateNode = l, $r = e, Ia = n_(l), !0) : !1;
        }
        case $: {
          var c = e.pendingProps, p = JR(t, c);
          return p !== null ? (e.stateNode = p, $r = e, Ia = null, !0) : !1;
        }
        case Y: {
          var g = ZR(t);
          if (g !== null) {
            var b = {
              dehydrated: g,
              treeContext: A_(),
              retryLane: Di
            };
            e.memoizedState = b;
            var C = $M(g);
            return C.return = e, e.child = C, $r = e, Ia = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function v0(e) {
      return (e.mode & nt) !== ct && (e.flags & Ct) === st;
    }
    function m0(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function y0(e) {
      if (yl) {
        var t = Ia;
        if (!t) {
          v0(e) && (h0($r, e), m0()), mb($r, e), yl = !1, $r = e;
          return;
        }
        var a = t;
        if (!yb(e, t)) {
          v0(e) && (h0($r, e), m0()), t = jp(a);
          var l = $r;
          if (!t || !yb(e, t)) {
            mb($r, e), yl = !1, $r = e;
            return;
          }
          vb(l, a);
        }
      }
    }
    function I_(e, t, a) {
      var l = e.stateNode, c = !Ec, p = a_(l, e.type, e.memoizedProps, t, a, e, c);
      return e.updateQueue = p, p !== null;
    }
    function B_(e) {
      var t = e.stateNode, a = e.memoizedProps, l = l_(t, a, e);
      if (l) {
        var c = $r;
        if (c !== null)
          switch (c.tag) {
            case N: {
              var p = c.stateNode.containerInfo, g = (c.mode & nt) !== ct;
              d_(
                p,
                t,
                a,
                // TODO: Delete this argument when we remove the legacy root API.
                g
              );
              break;
            }
            case F: {
              var b = c.type, C = c.memoizedProps, O = c.stateNode, L = (c.mode & nt) !== ct;
              p_(
                b,
                C,
                O,
                t,
                a,
                // TODO: Delete this argument when we remove the legacy root API.
                L
              );
              break;
            }
          }
      }
      return l;
    }
    function V_(e) {
      var t = e.memoizedState, a = t !== null ? t.dehydrated : null;
      if (!a)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      o_(a, e);
    }
    function $_(e) {
      var t = e.memoizedState, a = t !== null ? t.dehydrated : null;
      if (!a)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return u_(a);
    }
    function gb(e) {
      for (var t = e.return; t !== null && t.tag !== F && t.tag !== N && t.tag !== Y; )
        t = t.return;
      $r = t;
    }
    function Rm(e) {
      if (e !== $r)
        return !1;
      if (!yl)
        return gb(e), yl = !0, !1;
      if (e.tag !== N && (e.tag !== F || f_(e.type) && !Jg(e.type, e.memoizedProps))) {
        var t = Ia;
        if (t)
          if (v0(e))
            Sb(e), m0();
          else
            for (; t; )
              vb(e, t), t = jp(t);
      }
      return gb(e), e.tag === Y ? Ia = $_(e) : Ia = $r ? jp(e.stateNode) : null, !0;
    }
    function Y_() {
      return yl && Ia !== null;
    }
    function Sb(e) {
      for (var t = Ia; t; )
        hb(e, t), t = jp(t);
    }
    function Zf() {
      $r = null, Ia = null, yl = !1, Ec = !1;
    }
    function xb() {
      es !== null && (hC(es), es = null);
    }
    function Yr() {
      return yl;
    }
    function g0(e) {
      es === null ? es = [e] : es.push(e);
    }
    var W_ = f.ReactCurrentBatchConfig, Q_ = null;
    function q_() {
      return W_.transition;
    }
    var gl = {
      recordUnsafeLifecycleWarnings: function(e, t) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, t) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var G_ = function(e) {
        for (var t = null, a = e; a !== null; )
          a.mode & Pn && (t = a), a = a.return;
        return t;
      }, Cc = function(e) {
        var t = [];
        return e.forEach(function(a) {
          t.push(a);
        }), t.sort().join(", ");
      }, Hp = [], Ip = [], Bp = [], Vp = [], $p = [], Yp = [], wc = /* @__PURE__ */ new Set();
      gl.recordUnsafeLifecycleWarnings = function(e, t) {
        wc.has(e.type) || (typeof t.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        t.componentWillMount.__suppressDeprecationWarning !== !0 && Hp.push(e), e.mode & Pn && typeof t.UNSAFE_componentWillMount == "function" && Ip.push(e), typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Bp.push(e), e.mode & Pn && typeof t.UNSAFE_componentWillReceiveProps == "function" && Vp.push(e), typeof t.componentWillUpdate == "function" && t.componentWillUpdate.__suppressDeprecationWarning !== !0 && $p.push(e), e.mode & Pn && typeof t.UNSAFE_componentWillUpdate == "function" && Yp.push(e));
      }, gl.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        Hp.length > 0 && (Hp.forEach(function(H) {
          e.add(xt(H) || "Component"), wc.add(H.type);
        }), Hp = []);
        var t = /* @__PURE__ */ new Set();
        Ip.length > 0 && (Ip.forEach(function(H) {
          t.add(xt(H) || "Component"), wc.add(H.type);
        }), Ip = []);
        var a = /* @__PURE__ */ new Set();
        Bp.length > 0 && (Bp.forEach(function(H) {
          a.add(xt(H) || "Component"), wc.add(H.type);
        }), Bp = []);
        var l = /* @__PURE__ */ new Set();
        Vp.length > 0 && (Vp.forEach(function(H) {
          l.add(xt(H) || "Component"), wc.add(H.type);
        }), Vp = []);
        var c = /* @__PURE__ */ new Set();
        $p.length > 0 && ($p.forEach(function(H) {
          c.add(xt(H) || "Component"), wc.add(H.type);
        }), $p = []);
        var p = /* @__PURE__ */ new Set();
        if (Yp.length > 0 && (Yp.forEach(function(H) {
          p.add(xt(H) || "Component"), wc.add(H.type);
        }), Yp = []), t.size > 0) {
          var g = Cc(t);
          v(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, g);
        }
        if (l.size > 0) {
          var b = Cc(l);
          v(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, b);
        }
        if (p.size > 0) {
          var C = Cc(p);
          v(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, C);
        }
        if (e.size > 0) {
          var O = Cc(e);
          S(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, O);
        }
        if (a.size > 0) {
          var L = Cc(a);
          S(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, L);
        }
        if (c.size > 0) {
          var B = Cc(c);
          S(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, B);
        }
      };
      var _m = /* @__PURE__ */ new Map(), bb = /* @__PURE__ */ new Set();
      gl.recordLegacyContextWarning = function(e, t) {
        var a = G_(e);
        if (a === null) {
          v("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!bb.has(e.type)) {
          var l = _m.get(a);
          (e.type.contextTypes != null || e.type.childContextTypes != null || t !== null && typeof t.getChildContext == "function") && (l === void 0 && (l = [], _m.set(a, l)), l.push(e));
        }
      }, gl.flushLegacyContextWarning = function() {
        _m.forEach(function(e, t) {
          if (e.length !== 0) {
            var a = e[0], l = /* @__PURE__ */ new Set();
            e.forEach(function(p) {
              l.add(xt(p) || "Component"), bb.add(p.type);
            });
            var c = Cc(l);
            try {
              Mn(a), v(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, c);
            } finally {
              Sn();
            }
          }
        });
      }, gl.discardPendingWarnings = function() {
        Hp = [], Ip = [], Bp = [], Vp = [], $p = [], Yp = [], _m = /* @__PURE__ */ new Map();
      };
    }
    function Sl(e, t) {
      if (e && e.defaultProps) {
        var a = Mt({}, t), l = e.defaultProps;
        for (var c in l)
          a[c] === void 0 && (a[c] = l[c]);
        return a;
      }
      return t;
    }
    var S0 = Ku(null), x0;
    x0 = {};
    var Dm = null, ed = null, b0 = null, Om = !1;
    function Mm() {
      Dm = null, ed = null, b0 = null, Om = !1;
    }
    function Eb() {
      Om = !0;
    }
    function Cb() {
      Om = !1;
    }
    function wb(e, t, a) {
      yi(S0, t._currentValue, e), t._currentValue = a, t._currentRenderer !== void 0 && t._currentRenderer !== null && t._currentRenderer !== x0 && v("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), t._currentRenderer = x0;
    }
    function E0(e, t) {
      var a = S0.current;
      mi(S0, t), e._currentValue = a;
    }
    function C0(e, t, a) {
      for (var l = e; l !== null; ) {
        var c = l.alternate;
        if (Ho(l.childLanes, t) ? c !== null && !Ho(c.childLanes, t) && (c.childLanes = Rt(c.childLanes, t)) : (l.childLanes = Rt(l.childLanes, t), c !== null && (c.childLanes = Rt(c.childLanes, t))), l === a)
          break;
        l = l.return;
      }
      l !== a && v("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function X_(e, t, a) {
      K_(e, t, a);
    }
    function K_(e, t, a) {
      var l = e.child;
      for (l !== null && (l.return = e); l !== null; ) {
        var c = void 0, p = l.dependencies;
        if (p !== null) {
          c = l.child;
          for (var g = p.firstContext; g !== null; ) {
            if (g.context === t) {
              if (l.tag === R) {
                var b = Nu(a), C = Zo(yn, b);
                C.tag = Lm;
                var O = l.updateQueue;
                if (O !== null) {
                  var L = O.shared, B = L.pending;
                  B === null ? C.next = C : (C.next = B.next, B.next = C), L.pending = C;
                }
              }
              l.lanes = Rt(l.lanes, a);
              var H = l.alternate;
              H !== null && (H.lanes = Rt(H.lanes, a)), C0(l.return, a, e), p.lanes = Rt(p.lanes, a);
              break;
            }
            g = g.next;
          }
        } else if (l.tag === te)
          c = l.type === e.type ? null : l.child;
        else if (l.tag === he) {
          var J = l.return;
          if (J === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          J.lanes = Rt(J.lanes, a);
          var Z = J.alternate;
          Z !== null && (Z.lanes = Rt(Z.lanes, a)), C0(J, a, e), c = l.sibling;
        } else
          c = l.child;
        if (c !== null)
          c.return = l;
        else
          for (c = l; c !== null; ) {
            if (c === e) {
              c = null;
              break;
            }
            var le = c.sibling;
            if (le !== null) {
              le.return = c.return, c = le;
              break;
            }
            c = c.return;
          }
        l = c;
      }
    }
    function td(e, t) {
      Dm = e, ed = null, b0 = null;
      var a = e.dependencies;
      if (a !== null) {
        var l = a.firstContext;
        l !== null && (hi(a.lanes, t) && ah(), a.firstContext = null);
      }
    }
    function yr(e) {
      Om && v("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var t = e._currentValue;
      if (b0 !== e) {
        var a = {
          context: e,
          memoizedValue: t,
          next: null
        };
        if (ed === null) {
          if (Dm === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          ed = a, Dm.dependencies = {
            lanes: fe,
            firstContext: a
          };
        } else
          ed = ed.next = a;
      }
      return t;
    }
    var kc = null;
    function w0(e) {
      kc === null ? kc = [e] : kc.push(e);
    }
    function J_() {
      if (kc !== null) {
        for (var e = 0; e < kc.length; e++) {
          var t = kc[e], a = t.interleaved;
          if (a !== null) {
            t.interleaved = null;
            var l = a.next, c = t.pending;
            if (c !== null) {
              var p = c.next;
              c.next = l, a.next = p;
            }
            t.pending = a;
          }
        }
        kc = null;
      }
    }
    function kb(e, t, a, l) {
      var c = t.interleaved;
      return c === null ? (a.next = a, w0(t)) : (a.next = c.next, c.next = a), t.interleaved = a, Nm(e, l);
    }
    function Z_(e, t, a, l) {
      var c = t.interleaved;
      c === null ? (a.next = a, w0(t)) : (a.next = c.next, c.next = a), t.interleaved = a;
    }
    function eD(e, t, a, l) {
      var c = t.interleaved;
      return c === null ? (a.next = a, w0(t)) : (a.next = c.next, c.next = a), t.interleaved = a, Nm(e, l);
    }
    function Zi(e, t) {
      return Nm(e, t);
    }
    var tD = Nm;
    function Nm(e, t) {
      e.lanes = Rt(e.lanes, t);
      var a = e.alternate;
      a !== null && (a.lanes = Rt(a.lanes, t)), a === null && (e.flags & (fn | Oa)) !== st && TC(e);
      for (var l = e, c = e.return; c !== null; )
        c.childLanes = Rt(c.childLanes, t), a = c.alternate, a !== null ? a.childLanes = Rt(a.childLanes, t) : (c.flags & (fn | Oa)) !== st && TC(e), l = c, c = c.return;
      if (l.tag === N) {
        var p = l.stateNode;
        return p;
      } else
        return null;
    }
    var Tb = 0, Rb = 1, Lm = 2, k0 = 3, zm = !1, T0, Am;
    T0 = !1, Am = null;
    function R0(e) {
      var t = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: fe
        },
        effects: null
      };
      e.updateQueue = t;
    }
    function _b(e, t) {
      var a = t.updateQueue, l = e.updateQueue;
      if (a === l) {
        var c = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          effects: l.effects
        };
        t.updateQueue = c;
      }
    }
    function Zo(e, t) {
      var a = {
        eventTime: e,
        lane: t,
        tag: Tb,
        payload: null,
        callback: null,
        next: null
      };
      return a;
    }
    function ts(e, t, a) {
      var l = e.updateQueue;
      if (l === null)
        return null;
      var c = l.shared;
      if (Am === c && !T0 && (v("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), T0 = !0), tM()) {
        var p = c.pending;
        return p === null ? t.next = t : (t.next = p.next, p.next = t), c.pending = t, tD(e, a);
      } else
        return eD(e, c, t, a);
    }
    function jm(e, t, a) {
      var l = t.updateQueue;
      if (l !== null) {
        var c = l.shared;
        if (op(a)) {
          var p = c.lanes;
          p = Sf(p, e.pendingLanes);
          var g = Rt(p, a);
          c.lanes = g, up(e, g);
        }
      }
    }
    function _0(e, t) {
      var a = e.updateQueue, l = e.alternate;
      if (l !== null) {
        var c = l.updateQueue;
        if (a === c) {
          var p = null, g = null, b = a.firstBaseUpdate;
          if (b !== null) {
            var C = b;
            do {
              var O = {
                eventTime: C.eventTime,
                lane: C.lane,
                tag: C.tag,
                payload: C.payload,
                callback: C.callback,
                next: null
              };
              g === null ? p = g = O : (g.next = O, g = O), C = C.next;
            } while (C !== null);
            g === null ? p = g = t : (g.next = t, g = t);
          } else
            p = g = t;
          a = {
            baseState: c.baseState,
            firstBaseUpdate: p,
            lastBaseUpdate: g,
            shared: c.shared,
            effects: c.effects
          }, e.updateQueue = a;
          return;
        }
      }
      var L = a.lastBaseUpdate;
      L === null ? a.firstBaseUpdate = t : L.next = t, a.lastBaseUpdate = t;
    }
    function nD(e, t, a, l, c, p) {
      switch (a.tag) {
        case Rb: {
          var g = a.payload;
          if (typeof g == "function") {
            Eb();
            var b = g.call(p, l, c);
            {
              if (e.mode & Pn) {
                mn(!0);
                try {
                  g.call(p, l, c);
                } finally {
                  mn(!1);
                }
              }
              Cb();
            }
            return b;
          }
          return g;
        }
        case k0:
          e.flags = e.flags & ~xr | Ct;
        case Tb: {
          var C = a.payload, O;
          if (typeof C == "function") {
            Eb(), O = C.call(p, l, c);
            {
              if (e.mode & Pn) {
                mn(!0);
                try {
                  C.call(p, l, c);
                } finally {
                  mn(!1);
                }
              }
              Cb();
            }
          } else
            O = C;
          return O == null ? l : Mt({}, l, O);
        }
        case Lm:
          return zm = !0, l;
      }
      return l;
    }
    function Um(e, t, a, l) {
      var c = e.updateQueue;
      zm = !1, Am = c.shared;
      var p = c.firstBaseUpdate, g = c.lastBaseUpdate, b = c.shared.pending;
      if (b !== null) {
        c.shared.pending = null;
        var C = b, O = C.next;
        C.next = null, g === null ? p = O : g.next = O, g = C;
        var L = e.alternate;
        if (L !== null) {
          var B = L.updateQueue, H = B.lastBaseUpdate;
          H !== g && (H === null ? B.firstBaseUpdate = O : H.next = O, B.lastBaseUpdate = C);
        }
      }
      if (p !== null) {
        var J = c.baseState, Z = fe, le = null, Be = null, ft = null, rt = p;
        do {
          var It = rt.lane, jt = rt.eventTime;
          if (Ho(l, It)) {
            if (ft !== null) {
              var oe = {
                eventTime: jt,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Qn,
                tag: rt.tag,
                payload: rt.payload,
                callback: rt.callback,
                next: null
              };
              ft = ft.next = oe;
            }
            J = nD(e, c, rt, J, t, a);
            var q = rt.callback;
            if (q !== null && // If the update was already committed, we should not queue its
            // callback again.
            rt.lane !== Qn) {
              e.flags |= pr;
              var be = c.effects;
              be === null ? c.effects = [rt] : be.push(rt);
            }
          } else {
            var Q = {
              eventTime: jt,
              lane: It,
              tag: rt.tag,
              payload: rt.payload,
              callback: rt.callback,
              next: null
            };
            ft === null ? (Be = ft = Q, le = J) : ft = ft.next = Q, Z = Rt(Z, It);
          }
          if (rt = rt.next, rt === null) {
            if (b = c.shared.pending, b === null)
              break;
            var Ve = b, Ue = Ve.next;
            Ve.next = null, rt = Ue, c.lastBaseUpdate = Ve, c.shared.pending = null;
          }
        } while (!0);
        ft === null && (le = J), c.baseState = le, c.firstBaseUpdate = Be, c.lastBaseUpdate = ft;
        var gt = c.shared.interleaved;
        if (gt !== null) {
          var kt = gt;
          do
            Z = Rt(Z, kt.lane), kt = kt.next;
          while (kt !== gt);
        } else
          p === null && (c.shared.lanes = fe);
        yh(Z), e.lanes = Z, e.memoizedState = J;
      }
      Am = null;
    }
    function rD(e, t) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(t);
    }
    function Db() {
      zm = !1;
    }
    function Fm() {
      return zm;
    }
    function Ob(e, t, a) {
      var l = t.effects;
      if (t.effects = null, l !== null)
        for (var c = 0; c < l.length; c++) {
          var p = l[c], g = p.callback;
          g !== null && (p.callback = null, rD(g, a));
        }
    }
    var D0 = {}, Mb = new o.Component().refs, O0, M0, N0, L0, z0, Nb, Pm, A0, j0, U0;
    {
      O0 = /* @__PURE__ */ new Set(), M0 = /* @__PURE__ */ new Set(), N0 = /* @__PURE__ */ new Set(), L0 = /* @__PURE__ */ new Set(), A0 = /* @__PURE__ */ new Set(), z0 = /* @__PURE__ */ new Set(), j0 = /* @__PURE__ */ new Set(), U0 = /* @__PURE__ */ new Set();
      var Lb = /* @__PURE__ */ new Set();
      Pm = function(e, t) {
        if (!(e === null || typeof e == "function")) {
          var a = t + "_" + e;
          Lb.has(a) || (Lb.add(a), v("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t, e));
        }
      }, Nb = function(e, t) {
        if (t === void 0) {
          var a = Vt(e) || "Component";
          z0.has(a) || (z0.add(a), v("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", a));
        }
      }, Object.defineProperty(D0, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(D0);
    }
    function F0(e, t, a, l) {
      var c = e.memoizedState, p = a(l, c);
      {
        if (e.mode & Pn) {
          mn(!0);
          try {
            p = a(l, c);
          } finally {
            mn(!1);
          }
        }
        Nb(t, p);
      }
      var g = p == null ? c : Mt({}, c, p);
      if (e.memoizedState = g, e.lanes === fe) {
        var b = e.updateQueue;
        b.baseState = g;
      }
    }
    var P0 = {
      isMounted: Ri,
      enqueueSetState: function(e, t, a) {
        var l = Da(e), c = Ni(), p = ss(l), g = Zo(c, p);
        g.payload = t, a != null && (Pm(a, "setState"), g.callback = a);
        var b = ts(l, g, p);
        b !== null && (Or(b, l, p, c), jm(b, l, p)), nf(l, p);
      },
      enqueueReplaceState: function(e, t, a) {
        var l = Da(e), c = Ni(), p = ss(l), g = Zo(c, p);
        g.tag = Rb, g.payload = t, a != null && (Pm(a, "replaceState"), g.callback = a);
        var b = ts(l, g, p);
        b !== null && (Or(b, l, p, c), jm(b, l, p)), nf(l, p);
      },
      enqueueForceUpdate: function(e, t) {
        var a = Da(e), l = Ni(), c = ss(a), p = Zo(l, c);
        p.tag = Lm, t != null && (Pm(t, "forceUpdate"), p.callback = t);
        var g = ts(a, p, c);
        g !== null && (Or(g, a, c, l), jm(g, a, c)), _u(a, c);
      }
    };
    function zb(e, t, a, l, c, p, g) {
      var b = e.stateNode;
      if (typeof b.shouldComponentUpdate == "function") {
        var C = b.shouldComponentUpdate(l, p, g);
        {
          if (e.mode & Pn) {
            mn(!0);
            try {
              C = b.shouldComponentUpdate(l, p, g);
            } finally {
              mn(!1);
            }
          }
          C === void 0 && v("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Vt(t) || "Component");
        }
        return C;
      }
      return t.prototype && t.prototype.isPureReactComponent ? !ht(a, l) || !ht(c, p) : !0;
    }
    function iD(e, t, a) {
      var l = e.stateNode;
      {
        var c = Vt(t) || "Component", p = l.render;
        p || (t.prototype && typeof t.prototype.render == "function" ? v("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", c) : v("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", c)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && v("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", c), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && v("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", c), l.propTypes && v("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", c), l.contextType && v("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", c), l.contextTypes && v("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", c), t.contextType && t.contextTypes && !j0.has(t) && (j0.add(t), v("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", c)), typeof l.componentShouldUpdate == "function" && v("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", c), t.prototype && t.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && v("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Vt(t) || "A pure component"), typeof l.componentDidUnmount == "function" && v("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", c), typeof l.componentDidReceiveProps == "function" && v("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", c), typeof l.componentWillRecieveProps == "function" && v("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", c), typeof l.UNSAFE_componentWillRecieveProps == "function" && v("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", c);
        var g = l.props !== a;
        l.props !== void 0 && g && v("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", c, c), l.defaultProps && v("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", c, c), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !N0.has(t) && (N0.add(t), v("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Vt(t))), typeof l.getDerivedStateFromProps == "function" && v("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", c), typeof l.getDerivedStateFromError == "function" && v("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", c), typeof t.getSnapshotBeforeUpdate == "function" && v("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", c);
        var b = l.state;
        b && (typeof b != "object" || $t(b)) && v("%s.state: must be set to an object or null", c), typeof l.getChildContext == "function" && typeof t.childContextTypes != "object" && v("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", c);
      }
    }
    function Ab(e, t) {
      t.updater = P0, e.stateNode = t, qc(t, e), t._reactInternalInstance = D0;
    }
    function jb(e, t, a) {
      var l = !1, c = ga, p = ga, g = t.contextType;
      if ("contextType" in t) {
        var b = (
          // Allow null for conditional declaration
          g === null || g !== void 0 && g.$$typeof === Ne && g._context === void 0
        );
        if (!b && !U0.has(t)) {
          U0.add(t);
          var C = "";
          g === void 0 ? C = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof g != "object" ? C = " However, it is set to a " + typeof g + "." : g.$$typeof === me ? C = " Did you accidentally pass the Context.Provider instead?" : g._context !== void 0 ? C = " Did you accidentally pass the Context.Consumer instead?" : C = " However, it is set to an object with keys {" + Object.keys(g).join(", ") + "}.", v("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Vt(t) || "Component", C);
        }
      }
      if (typeof g == "object" && g !== null)
        p = yr(g);
      else {
        c = Gf(e, t, !0);
        var O = t.contextTypes;
        l = O != null, p = l ? Xf(e, c) : ga;
      }
      var L = new t(a, p);
      if (e.mode & Pn) {
        mn(!0);
        try {
          L = new t(a, p);
        } finally {
          mn(!1);
        }
      }
      var B = e.memoizedState = L.state !== null && L.state !== void 0 ? L.state : null;
      Ab(e, L);
      {
        if (typeof t.getDerivedStateFromProps == "function" && B === null) {
          var H = Vt(t) || "Component";
          M0.has(H) || (M0.add(H), v("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", H, L.state === null ? "null" : "undefined", H));
        }
        if (typeof t.getDerivedStateFromProps == "function" || typeof L.getSnapshotBeforeUpdate == "function") {
          var J = null, Z = null, le = null;
          if (typeof L.componentWillMount == "function" && L.componentWillMount.__suppressDeprecationWarning !== !0 ? J = "componentWillMount" : typeof L.UNSAFE_componentWillMount == "function" && (J = "UNSAFE_componentWillMount"), typeof L.componentWillReceiveProps == "function" && L.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Z = "componentWillReceiveProps" : typeof L.UNSAFE_componentWillReceiveProps == "function" && (Z = "UNSAFE_componentWillReceiveProps"), typeof L.componentWillUpdate == "function" && L.componentWillUpdate.__suppressDeprecationWarning !== !0 ? le = "componentWillUpdate" : typeof L.UNSAFE_componentWillUpdate == "function" && (le = "UNSAFE_componentWillUpdate"), J !== null || Z !== null || le !== null) {
            var Be = Vt(t) || "Component", ft = typeof t.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            L0.has(Be) || (L0.add(Be), v(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Be, ft, J !== null ? `
  ` + J : "", Z !== null ? `
  ` + Z : "", le !== null ? `
  ` + le : ""));
          }
        }
      }
      return l && lb(e, c, p), L;
    }
    function aD(e, t) {
      var a = t.state;
      typeof t.componentWillMount == "function" && t.componentWillMount(), typeof t.UNSAFE_componentWillMount == "function" && t.UNSAFE_componentWillMount(), a !== t.state && (v("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", xt(e) || "Component"), P0.enqueueReplaceState(t, t.state, null));
    }
    function Ub(e, t, a, l) {
      var c = t.state;
      if (typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(a, l), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(a, l), t.state !== c) {
        {
          var p = xt(e) || "Component";
          O0.has(p) || (O0.add(p), v("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", p));
        }
        P0.enqueueReplaceState(t, t.state, null);
      }
    }
    function H0(e, t, a, l) {
      iD(e, t, a);
      var c = e.stateNode;
      c.props = a, c.state = e.memoizedState, c.refs = Mb, R0(e);
      var p = t.contextType;
      if (typeof p == "object" && p !== null)
        c.context = yr(p);
      else {
        var g = Gf(e, t, !0);
        c.context = Xf(e, g);
      }
      {
        if (c.state === a) {
          var b = Vt(t) || "Component";
          A0.has(b) || (A0.add(b), v("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", b));
        }
        e.mode & Pn && gl.recordLegacyContextWarning(e, c), gl.recordUnsafeLifecycleWarnings(e, c);
      }
      c.state = e.memoizedState;
      var C = t.getDerivedStateFromProps;
      if (typeof C == "function" && (F0(e, t, C, a), c.state = e.memoizedState), typeof t.getDerivedStateFromProps != "function" && typeof c.getSnapshotBeforeUpdate != "function" && (typeof c.UNSAFE_componentWillMount == "function" || typeof c.componentWillMount == "function") && (aD(e, c), Um(e, a, c, l), c.state = e.memoizedState), typeof c.componentDidMount == "function") {
        var O = et;
        O |= Bi, (e.mode & Yi) !== ct && (O |= Vi), e.flags |= O;
      }
    }
    function lD(e, t, a, l) {
      var c = e.stateNode, p = e.memoizedProps;
      c.props = p;
      var g = c.context, b = t.contextType, C = ga;
      if (typeof b == "object" && b !== null)
        C = yr(b);
      else {
        var O = Gf(e, t, !0);
        C = Xf(e, O);
      }
      var L = t.getDerivedStateFromProps, B = typeof L == "function" || typeof c.getSnapshotBeforeUpdate == "function";
      !B && (typeof c.UNSAFE_componentWillReceiveProps == "function" || typeof c.componentWillReceiveProps == "function") && (p !== a || g !== C) && Ub(e, c, a, C), Db();
      var H = e.memoizedState, J = c.state = H;
      if (Um(e, a, c, l), J = e.memoizedState, p === a && H === J && !xm() && !Fm()) {
        if (typeof c.componentDidMount == "function") {
          var Z = et;
          Z |= Bi, (e.mode & Yi) !== ct && (Z |= Vi), e.flags |= Z;
        }
        return !1;
      }
      typeof L == "function" && (F0(e, t, L, a), J = e.memoizedState);
      var le = Fm() || zb(e, t, p, a, H, J, C);
      if (le) {
        if (!B && (typeof c.UNSAFE_componentWillMount == "function" || typeof c.componentWillMount == "function") && (typeof c.componentWillMount == "function" && c.componentWillMount(), typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount()), typeof c.componentDidMount == "function") {
          var Be = et;
          Be |= Bi, (e.mode & Yi) !== ct && (Be |= Vi), e.flags |= Be;
        }
      } else {
        if (typeof c.componentDidMount == "function") {
          var ft = et;
          ft |= Bi, (e.mode & Yi) !== ct && (ft |= Vi), e.flags |= ft;
        }
        e.memoizedProps = a, e.memoizedState = J;
      }
      return c.props = a, c.state = J, c.context = C, le;
    }
    function oD(e, t, a, l, c) {
      var p = t.stateNode;
      _b(e, t);
      var g = t.memoizedProps, b = t.type === t.elementType ? g : Sl(t.type, g);
      p.props = b;
      var C = t.pendingProps, O = p.context, L = a.contextType, B = ga;
      if (typeof L == "object" && L !== null)
        B = yr(L);
      else {
        var H = Gf(t, a, !0);
        B = Xf(t, H);
      }
      var J = a.getDerivedStateFromProps, Z = typeof J == "function" || typeof p.getSnapshotBeforeUpdate == "function";
      !Z && (typeof p.UNSAFE_componentWillReceiveProps == "function" || typeof p.componentWillReceiveProps == "function") && (g !== C || O !== B) && Ub(t, p, l, B), Db();
      var le = t.memoizedState, Be = p.state = le;
      if (Um(t, l, p, c), Be = t.memoizedState, g === C && le === Be && !xm() && !Fm() && !T)
        return typeof p.componentDidUpdate == "function" && (g !== e.memoizedProps || le !== e.memoizedState) && (t.flags |= et), typeof p.getSnapshotBeforeUpdate == "function" && (g !== e.memoizedProps || le !== e.memoizedState) && (t.flags |= er), !1;
      typeof J == "function" && (F0(t, a, J, l), Be = t.memoizedState);
      var ft = Fm() || zb(t, a, b, l, le, Be, B) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      T;
      return ft ? (!Z && (typeof p.UNSAFE_componentWillUpdate == "function" || typeof p.componentWillUpdate == "function") && (typeof p.componentWillUpdate == "function" && p.componentWillUpdate(l, Be, B), typeof p.UNSAFE_componentWillUpdate == "function" && p.UNSAFE_componentWillUpdate(l, Be, B)), typeof p.componentDidUpdate == "function" && (t.flags |= et), typeof p.getSnapshotBeforeUpdate == "function" && (t.flags |= er)) : (typeof p.componentDidUpdate == "function" && (g !== e.memoizedProps || le !== e.memoizedState) && (t.flags |= et), typeof p.getSnapshotBeforeUpdate == "function" && (g !== e.memoizedProps || le !== e.memoizedState) && (t.flags |= er), t.memoizedProps = l, t.memoizedState = Be), p.props = l, p.state = Be, p.context = B, ft;
    }
    var I0, B0, V0, $0, Y0, Fb = function(e, t) {
    };
    I0 = !1, B0 = !1, V0 = {}, $0 = {}, Y0 = {}, Fb = function(e, t) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var a = xt(t) || "Component";
        $0[a] || ($0[a] = !0, v('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Wp(e, t, a) {
      var l = a.ref;
      if (l !== null && typeof l != "function" && typeof l != "object") {
        if ((e.mode & Pn || bt) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(a._owner && a._self && a._owner.stateNode !== a._self)) {
          var c = xt(e) || "Component";
          V0[c] || (v('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', l), V0[c] = !0);
        }
        if (a._owner) {
          var p = a._owner, g;
          if (p) {
            var b = p;
            if (b.tag !== R)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            g = b.stateNode;
          }
          if (!g)
            throw new Error("Missing owner for string ref " + l + ". This error is likely caused by a bug in React. Please file an issue.");
          var C = g;
          $n(l, "ref");
          var O = "" + l;
          if (t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === O)
            return t.ref;
          var L = function(B) {
            var H = C.refs;
            H === Mb && (H = C.refs = {}), B === null ? delete H[O] : H[O] = B;
          };
          return L._stringRef = O, L;
        } else {
          if (typeof l != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!a._owner)
            throw new Error("Element ref was specified as a string (" + l + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return l;
    }
    function Hm(e, t) {
      var a = Object.prototype.toString.call(t);
      throw new Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Im(e) {
      {
        var t = xt(e) || "Component";
        if (Y0[t])
          return;
        Y0[t] = !0, v("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Pb(e) {
      var t = e._payload, a = e._init;
      return a(t);
    }
    function Hb(e) {
      function t(Q, oe) {
        if (e) {
          var q = Q.deletions;
          q === null ? (Q.deletions = [oe], Q.flags |= qt) : q.push(oe);
        }
      }
      function a(Q, oe) {
        if (!e)
          return null;
        for (var q = oe; q !== null; )
          t(Q, q), q = q.sibling;
        return null;
      }
      function l(Q, oe) {
        for (var q = /* @__PURE__ */ new Map(), be = oe; be !== null; )
          be.key !== null ? q.set(be.key, be) : q.set(be.index, be), be = be.sibling;
        return q;
      }
      function c(Q, oe) {
        var q = Lc(Q, oe);
        return q.index = 0, q.sibling = null, q;
      }
      function p(Q, oe, q) {
        if (Q.index = q, !e)
          return Q.flags |= gv, oe;
        var be = Q.alternate;
        if (be !== null) {
          var Ve = be.index;
          return Ve < oe ? (Q.flags |= fn, oe) : Ve;
        } else
          return Q.flags |= fn, oe;
      }
      function g(Q) {
        return e && Q.alternate === null && (Q.flags |= fn), Q;
      }
      function b(Q, oe, q, be) {
        if (oe === null || oe.tag !== $) {
          var Ve = gS(q, Q.mode, be);
          return Ve.return = Q, Ve;
        } else {
          var Ue = c(oe, q);
          return Ue.return = Q, Ue;
        }
      }
      function C(Q, oe, q, be) {
        var Ve = q.type;
        if (Ve === Ei)
          return L(Q, oe, q.props.children, be, q.key);
        if (oe !== null && (oe.elementType === Ve || // Keep this check inline so it only runs on the false path:
        OC(oe, q) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Ve == "object" && Ve !== null && Ve.$$typeof === ot && Pb(Ve) === oe.type)) {
          var Ue = c(oe, q.props);
          return Ue.ref = Wp(Q, oe, q), Ue.return = Q, Ue._debugSource = q._source, Ue._debugOwner = q._owner, Ue;
        }
        var gt = yS(q, Q.mode, be);
        return gt.ref = Wp(Q, oe, q), gt.return = Q, gt;
      }
      function O(Q, oe, q, be) {
        if (oe === null || oe.tag !== M || oe.stateNode.containerInfo !== q.containerInfo || oe.stateNode.implementation !== q.implementation) {
          var Ve = SS(q, Q.mode, be);
          return Ve.return = Q, Ve;
        } else {
          var Ue = c(oe, q.children || []);
          return Ue.return = Q, Ue;
        }
      }
      function L(Q, oe, q, be, Ve) {
        if (oe === null || oe.tag !== ce) {
          var Ue = fs(q, Q.mode, be, Ve);
          return Ue.return = Q, Ue;
        } else {
          var gt = c(oe, q);
          return gt.return = Q, gt;
        }
      }
      function B(Q, oe, q) {
        if (typeof oe == "string" && oe !== "" || typeof oe == "number") {
          var be = gS("" + oe, Q.mode, q);
          return be.return = Q, be;
        }
        if (typeof oe == "object" && oe !== null) {
          switch (oe.$$typeof) {
            case Zr: {
              var Ve = yS(oe, Q.mode, q);
              return Ve.ref = Wp(Q, null, oe), Ve.return = Q, Ve;
            }
            case ei: {
              var Ue = SS(oe, Q.mode, q);
              return Ue.return = Q, Ue;
            }
            case ot: {
              var gt = oe._payload, kt = oe._init;
              return B(Q, kt(gt), q);
            }
          }
          if ($t(oe) || wa(oe)) {
            var sn = fs(oe, Q.mode, q, null);
            return sn.return = Q, sn;
          }
          Hm(Q, oe);
        }
        return typeof oe == "function" && Im(Q), null;
      }
      function H(Q, oe, q, be) {
        var Ve = oe !== null ? oe.key : null;
        if (typeof q == "string" && q !== "" || typeof q == "number")
          return Ve !== null ? null : b(Q, oe, "" + q, be);
        if (typeof q == "object" && q !== null) {
          switch (q.$$typeof) {
            case Zr:
              return q.key === Ve ? C(Q, oe, q, be) : null;
            case ei:
              return q.key === Ve ? O(Q, oe, q, be) : null;
            case ot: {
              var Ue = q._payload, gt = q._init;
              return H(Q, oe, gt(Ue), be);
            }
          }
          if ($t(q) || wa(q))
            return Ve !== null ? null : L(Q, oe, q, be, null);
          Hm(Q, q);
        }
        return typeof q == "function" && Im(Q), null;
      }
      function J(Q, oe, q, be, Ve) {
        if (typeof be == "string" && be !== "" || typeof be == "number") {
          var Ue = Q.get(q) || null;
          return b(oe, Ue, "" + be, Ve);
        }
        if (typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case Zr: {
              var gt = Q.get(be.key === null ? q : be.key) || null;
              return C(oe, gt, be, Ve);
            }
            case ei: {
              var kt = Q.get(be.key === null ? q : be.key) || null;
              return O(oe, kt, be, Ve);
            }
            case ot:
              var sn = be._payload, Xt = be._init;
              return J(Q, oe, q, Xt(sn), Ve);
          }
          if ($t(be) || wa(be)) {
            var ur = Q.get(q) || null;
            return L(oe, ur, be, Ve, null);
          }
          Hm(oe, be);
        }
        return typeof be == "function" && Im(oe), null;
      }
      function Z(Q, oe, q) {
        {
          if (typeof Q != "object" || Q === null)
            return oe;
          switch (Q.$$typeof) {
            case Zr:
            case ei:
              Fb(Q, q);
              var be = Q.key;
              if (typeof be != "string")
                break;
              if (oe === null) {
                oe = /* @__PURE__ */ new Set(), oe.add(be);
                break;
              }
              if (!oe.has(be)) {
                oe.add(be);
                break;
              }
              v("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", be);
              break;
            case ot:
              var Ve = Q._payload, Ue = Q._init;
              Z(Ue(Ve), oe, q);
              break;
          }
        }
        return oe;
      }
      function le(Q, oe, q, be) {
        for (var Ve = null, Ue = 0; Ue < q.length; Ue++) {
          var gt = q[Ue];
          Ve = Z(gt, Ve, Q);
        }
        for (var kt = null, sn = null, Xt = oe, ur = 0, Kt = 0, nr = null; Xt !== null && Kt < q.length; Kt++) {
          Xt.index > Kt ? (nr = Xt, Xt = null) : nr = Xt.sibling;
          var Si = H(Q, Xt, q[Kt], be);
          if (Si === null) {
            Xt === null && (Xt = nr);
            break;
          }
          e && Xt && Si.alternate === null && t(Q, Xt), ur = p(Si, ur, Kt), sn === null ? kt = Si : sn.sibling = Si, sn = Si, Xt = nr;
        }
        if (Kt === q.length) {
          if (a(Q, Xt), Yr()) {
            var Jr = Kt;
            xc(Q, Jr);
          }
          return kt;
        }
        if (Xt === null) {
          for (; Kt < q.length; Kt++) {
            var xa = B(Q, q[Kt], be);
            xa !== null && (ur = p(xa, ur, Kt), sn === null ? kt = xa : sn.sibling = xa, sn = xa);
          }
          if (Yr()) {
            var Li = Kt;
            xc(Q, Li);
          }
          return kt;
        }
        for (var zi = l(Q, Xt); Kt < q.length; Kt++) {
          var xi = J(zi, Q, Kt, q[Kt], be);
          xi !== null && (e && xi.alternate !== null && zi.delete(xi.key === null ? Kt : xi.key), ur = p(xi, ur, Kt), sn === null ? kt = xi : sn.sibling = xi, sn = xi);
        }
        if (e && zi.forEach(function(gd) {
          return t(Q, gd);
        }), Yr()) {
          var au = Kt;
          xc(Q, au);
        }
        return kt;
      }
      function Be(Q, oe, q, be) {
        var Ve = wa(q);
        if (typeof Ve != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          q[Symbol.toStringTag] === "Generator" && (B0 || v("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), B0 = !0), q.entries === Ve && (I0 || v("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), I0 = !0);
          var Ue = Ve.call(q);
          if (Ue)
            for (var gt = null, kt = Ue.next(); !kt.done; kt = Ue.next()) {
              var sn = kt.value;
              gt = Z(sn, gt, Q);
            }
        }
        var Xt = Ve.call(q);
        if (Xt == null)
          throw new Error("An iterable object provided no iterator.");
        for (var ur = null, Kt = null, nr = oe, Si = 0, Jr = 0, xa = null, Li = Xt.next(); nr !== null && !Li.done; Jr++, Li = Xt.next()) {
          nr.index > Jr ? (xa = nr, nr = null) : xa = nr.sibling;
          var zi = H(Q, nr, Li.value, be);
          if (zi === null) {
            nr === null && (nr = xa);
            break;
          }
          e && nr && zi.alternate === null && t(Q, nr), Si = p(zi, Si, Jr), Kt === null ? ur = zi : Kt.sibling = zi, Kt = zi, nr = xa;
        }
        if (Li.done) {
          if (a(Q, nr), Yr()) {
            var xi = Jr;
            xc(Q, xi);
          }
          return ur;
        }
        if (nr === null) {
          for (; !Li.done; Jr++, Li = Xt.next()) {
            var au = B(Q, Li.value, be);
            au !== null && (Si = p(au, Si, Jr), Kt === null ? ur = au : Kt.sibling = au, Kt = au);
          }
          if (Yr()) {
            var gd = Jr;
            xc(Q, gd);
          }
          return ur;
        }
        for (var Eh = l(Q, nr); !Li.done; Jr++, Li = Xt.next()) {
          var fo = J(Eh, Q, Jr, Li.value, be);
          fo !== null && (e && fo.alternate !== null && Eh.delete(fo.key === null ? Jr : fo.key), Si = p(fo, Si, Jr), Kt === null ? ur = fo : Kt.sibling = fo, Kt = fo);
        }
        if (e && Eh.forEach(function(bN) {
          return t(Q, bN);
        }), Yr()) {
          var xN = Jr;
          xc(Q, xN);
        }
        return ur;
      }
      function ft(Q, oe, q, be) {
        if (oe !== null && oe.tag === $) {
          a(Q, oe.sibling);
          var Ve = c(oe, q);
          return Ve.return = Q, Ve;
        }
        a(Q, oe);
        var Ue = gS(q, Q.mode, be);
        return Ue.return = Q, Ue;
      }
      function rt(Q, oe, q, be) {
        for (var Ve = q.key, Ue = oe; Ue !== null; ) {
          if (Ue.key === Ve) {
            var gt = q.type;
            if (gt === Ei) {
              if (Ue.tag === ce) {
                a(Q, Ue.sibling);
                var kt = c(Ue, q.props.children);
                return kt.return = Q, kt._debugSource = q._source, kt._debugOwner = q._owner, kt;
              }
            } else if (Ue.elementType === gt || // Keep this check inline so it only runs on the false path:
            OC(Ue, q) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof gt == "object" && gt !== null && gt.$$typeof === ot && Pb(gt) === Ue.type) {
              a(Q, Ue.sibling);
              var sn = c(Ue, q.props);
              return sn.ref = Wp(Q, Ue, q), sn.return = Q, sn._debugSource = q._source, sn._debugOwner = q._owner, sn;
            }
            a(Q, Ue);
            break;
          } else
            t(Q, Ue);
          Ue = Ue.sibling;
        }
        if (q.type === Ei) {
          var Xt = fs(q.props.children, Q.mode, be, q.key);
          return Xt.return = Q, Xt;
        } else {
          var ur = yS(q, Q.mode, be);
          return ur.ref = Wp(Q, oe, q), ur.return = Q, ur;
        }
      }
      function It(Q, oe, q, be) {
        for (var Ve = q.key, Ue = oe; Ue !== null; ) {
          if (Ue.key === Ve)
            if (Ue.tag === M && Ue.stateNode.containerInfo === q.containerInfo && Ue.stateNode.implementation === q.implementation) {
              a(Q, Ue.sibling);
              var gt = c(Ue, q.children || []);
              return gt.return = Q, gt;
            } else {
              a(Q, Ue);
              break;
            }
          else
            t(Q, Ue);
          Ue = Ue.sibling;
        }
        var kt = SS(q, Q.mode, be);
        return kt.return = Q, kt;
      }
      function jt(Q, oe, q, be) {
        var Ve = typeof q == "object" && q !== null && q.type === Ei && q.key === null;
        if (Ve && (q = q.props.children), typeof q == "object" && q !== null) {
          switch (q.$$typeof) {
            case Zr:
              return g(rt(Q, oe, q, be));
            case ei:
              return g(It(Q, oe, q, be));
            case ot:
              var Ue = q._payload, gt = q._init;
              return jt(Q, oe, gt(Ue), be);
          }
          if ($t(q))
            return le(Q, oe, q, be);
          if (wa(q))
            return Be(Q, oe, q, be);
          Hm(Q, q);
        }
        return typeof q == "string" && q !== "" || typeof q == "number" ? g(ft(Q, oe, "" + q, be)) : (typeof q == "function" && Im(Q), a(Q, oe));
      }
      return jt;
    }
    var nd = Hb(!0), Ib = Hb(!1);
    function uD(e, t) {
      if (e !== null && t.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (t.child !== null) {
        var a = t.child, l = Lc(a, a.pendingProps);
        for (t.child = l, l.return = t; a.sibling !== null; )
          a = a.sibling, l = l.sibling = Lc(a, a.pendingProps), l.return = t;
        l.sibling = null;
      }
    }
    function sD(e, t) {
      for (var a = e.child; a !== null; )
        FM(a, t), a = a.sibling;
    }
    var Qp = {}, ns = Ku(Qp), qp = Ku(Qp), Bm = Ku(Qp);
    function Vm(e) {
      if (e === Qp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function Bb() {
      var e = Vm(Bm.current);
      return e;
    }
    function W0(e, t) {
      yi(Bm, t, e), yi(qp, e, e), yi(ns, Qp, e);
      var a = CR(t);
      mi(ns, e), yi(ns, a, e);
    }
    function rd(e) {
      mi(ns, e), mi(qp, e), mi(Bm, e);
    }
    function Q0() {
      var e = Vm(ns.current);
      return e;
    }
    function Vb(e) {
      Vm(Bm.current);
      var t = Vm(ns.current), a = wR(t, e.type);
      t !== a && (yi(qp, e, e), yi(ns, a, e));
    }
    function q0(e) {
      qp.current === e && (mi(ns, e), mi(qp, e));
    }
    var cD = 0, $b = 1, Yb = 1, Gp = 2, xl = Ku(cD);
    function G0(e, t) {
      return (e & t) !== 0;
    }
    function id(e) {
      return e & $b;
    }
    function X0(e, t) {
      return e & $b | t;
    }
    function fD(e, t) {
      return e | t;
    }
    function rs(e, t) {
      yi(xl, t, e);
    }
    function ad(e) {
      mi(xl, e);
    }
    function dD(e, t) {
      var a = e.memoizedState;
      return a !== null ? a.dehydrated !== null : (e.memoizedProps, !0);
    }
    function $m(e) {
      for (var t = e; t !== null; ) {
        if (t.tag === Y) {
          var a = t.memoizedState;
          if (a !== null) {
            var l = a.dehydrated;
            if (l === null || tb(l) || n0(l))
              return t;
          }
        } else if (t.tag === ne && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        t.memoizedProps.revealOrder !== void 0) {
          var c = (t.flags & Ct) !== st;
          if (c)
            return t;
        } else if (t.child !== null) {
          t.child.return = t, t = t.child;
          continue;
        }
        if (t === e)
          return null;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
            return null;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      return null;
    }
    var ea = (
      /*   */
      0
    ), Cr = (
      /* */
      1
    ), io = (
      /*  */
      2
    ), wr = (
      /*    */
      4
    ), Wr = (
      /*   */
      8
    ), K0 = [];
    function J0() {
      for (var e = 0; e < K0.length; e++) {
        var t = K0[e];
        t._workInProgressVersionPrimary = null;
      }
      K0.length = 0;
    }
    function pD(e, t) {
      var a = t._getVersion, l = a(t._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, l] : e.mutableSourceEagerHydrationData.push(t, l);
    }
    var He = f.ReactCurrentDispatcher, Xp = f.ReactCurrentBatchConfig, Z0, ld;
    Z0 = /* @__PURE__ */ new Set();
    var Tc = fe, un = null, kr = null, Tr = null, Ym = !1, Kp = !1, Jp = 0, hD = 0, vD = 25, pe = null, Ba = null, is = -1, e1 = !1;
    function en() {
      {
        var e = pe;
        Ba === null ? Ba = [e] : Ba.push(e);
      }
    }
    function Le() {
      {
        var e = pe;
        Ba !== null && (is++, Ba[is] !== e && mD(e));
      }
    }
    function od(e) {
      e != null && !$t(e) && v("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", pe, typeof e);
    }
    function mD(e) {
      {
        var t = xt(un);
        if (!Z0.has(t) && (Z0.add(t), Ba !== null)) {
          for (var a = "", l = 30, c = 0; c <= is; c++) {
            for (var p = Ba[c], g = c === is ? e : p, b = c + 1 + ". " + p; b.length < l; )
              b += " ";
            b += g + `
`, a += b;
          }
          v(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, t, a);
        }
      }
    }
    function gi() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function t1(e, t) {
      if (e1)
        return !1;
      if (t === null)
        return v("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", pe), !1;
      e.length !== t.length && v(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, pe, "[" + t.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var a = 0; a < t.length && a < e.length; a++)
        if (!Ge(e[a], t[a]))
          return !1;
      return !0;
    }
    function ud(e, t, a, l, c, p) {
      Tc = p, un = t, Ba = e !== null ? e._debugHookTypes : null, is = -1, e1 = e !== null && e.type !== t.type, t.memoizedState = null, t.updateQueue = null, t.lanes = fe, e !== null && e.memoizedState !== null ? He.current = pE : Ba !== null ? He.current = dE : He.current = fE;
      var g = a(l, c);
      if (Kp) {
        var b = 0;
        do {
          if (Kp = !1, Jp = 0, b >= vD)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          b += 1, e1 = !1, kr = null, Tr = null, t.updateQueue = null, is = -1, He.current = hE, g = a(l, c);
        } while (Kp);
      }
      He.current = iy, t._debugHookTypes = Ba;
      var C = kr !== null && kr.next !== null;
      if (Tc = fe, un = null, kr = null, Tr = null, pe = null, Ba = null, is = -1, e !== null && (e.flags & br) !== (t.flags & br) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & nt) !== ct && v("Internal React error: Expected static flag was missing. Please notify the React team."), Ym = !1, C)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return g;
    }
    function sd() {
      var e = Jp !== 0;
      return Jp = 0, e;
    }
    function Wb(e, t, a) {
      t.updateQueue = e.updateQueue, (t.mode & Yi) !== ct ? t.flags &= ~(Oo | Vi | li | et) : t.flags &= ~(li | et), e.lanes = rc(e.lanes, a);
    }
    function Qb() {
      if (He.current = iy, Ym) {
        for (var e = un.memoizedState; e !== null; ) {
          var t = e.queue;
          t !== null && (t.pending = null), e = e.next;
        }
        Ym = !1;
      }
      Tc = fe, un = null, kr = null, Tr = null, Ba = null, is = -1, pe = null, lE = !1, Kp = !1, Jp = 0;
    }
    function ao() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Tr === null ? un.memoizedState = Tr = e : Tr = Tr.next = e, Tr;
    }
    function Va() {
      var e;
      if (kr === null) {
        var t = un.alternate;
        t !== null ? e = t.memoizedState : e = null;
      } else
        e = kr.next;
      var a;
      if (Tr === null ? a = un.memoizedState : a = Tr.next, a !== null)
        Tr = a, a = Tr.next, kr = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        kr = e;
        var l = {
          memoizedState: kr.memoizedState,
          baseState: kr.baseState,
          baseQueue: kr.baseQueue,
          queue: kr.queue,
          next: null
        };
        Tr === null ? un.memoizedState = Tr = l : Tr = Tr.next = l;
      }
      return Tr;
    }
    function qb() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function n1(e, t) {
      return typeof t == "function" ? t(e) : t;
    }
    function r1(e, t, a) {
      var l = ao(), c;
      a !== void 0 ? c = a(t) : c = t, l.memoizedState = l.baseState = c;
      var p = {
        pending: null,
        interleaved: null,
        lanes: fe,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: c
      };
      l.queue = p;
      var g = p.dispatch = xD.bind(null, un, p);
      return [l.memoizedState, g];
    }
    function i1(e, t, a) {
      var l = Va(), c = l.queue;
      if (c === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      c.lastRenderedReducer = e;
      var p = kr, g = p.baseQueue, b = c.pending;
      if (b !== null) {
        if (g !== null) {
          var C = g.next, O = b.next;
          g.next = O, b.next = C;
        }
        p.baseQueue !== g && v("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), p.baseQueue = g = b, c.pending = null;
      }
      if (g !== null) {
        var L = g.next, B = p.baseState, H = null, J = null, Z = null, le = L;
        do {
          var Be = le.lane;
          if (Ho(Tc, Be)) {
            if (Z !== null) {
              var rt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Qn,
                action: le.action,
                hasEagerState: le.hasEagerState,
                eagerState: le.eagerState,
                next: null
              };
              Z = Z.next = rt;
            }
            if (le.hasEagerState)
              B = le.eagerState;
            else {
              var It = le.action;
              B = e(B, It);
            }
          } else {
            var ft = {
              lane: Be,
              action: le.action,
              hasEagerState: le.hasEagerState,
              eagerState: le.eagerState,
              next: null
            };
            Z === null ? (J = Z = ft, H = B) : Z = Z.next = ft, un.lanes = Rt(un.lanes, Be), yh(Be);
          }
          le = le.next;
        } while (le !== null && le !== L);
        Z === null ? H = B : Z.next = J, Ge(B, l.memoizedState) || ah(), l.memoizedState = B, l.baseState = H, l.baseQueue = Z, c.lastRenderedState = B;
      }
      var jt = c.interleaved;
      if (jt !== null) {
        var Q = jt;
        do {
          var oe = Q.lane;
          un.lanes = Rt(un.lanes, oe), yh(oe), Q = Q.next;
        } while (Q !== jt);
      } else
        g === null && (c.lanes = fe);
      var q = c.dispatch;
      return [l.memoizedState, q];
    }
    function a1(e, t, a) {
      var l = Va(), c = l.queue;
      if (c === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      c.lastRenderedReducer = e;
      var p = c.dispatch, g = c.pending, b = l.memoizedState;
      if (g !== null) {
        c.pending = null;
        var C = g.next, O = C;
        do {
          var L = O.action;
          b = e(b, L), O = O.next;
        } while (O !== C);
        Ge(b, l.memoizedState) || ah(), l.memoizedState = b, l.baseQueue === null && (l.baseState = b), c.lastRenderedState = b;
      }
      return [b, p];
    }
    function Vz(e, t, a) {
    }
    function $z(e, t, a) {
    }
    function l1(e, t, a) {
      var l = un, c = ao(), p, g = Yr();
      if (g) {
        if (a === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        p = a(), ld || p !== a() && (v("The result of getServerSnapshot should be cached to avoid an infinite loop"), ld = !0);
      } else {
        if (p = t(), !ld) {
          var b = t();
          Ge(p, b) || (v("The result of getSnapshot should be cached to avoid an infinite loop"), ld = !0);
        }
        var C = Ey();
        if (C === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        nc(C, Tc) || Gb(l, t, p);
      }
      c.memoizedState = p;
      var O = {
        value: p,
        getSnapshot: t
      };
      return c.queue = O, Xm(Kb.bind(null, l, O, e), [e]), l.flags |= li, Zp(Cr | Wr, Xb.bind(null, l, O, p, t), void 0, null), p;
    }
    function Wm(e, t, a) {
      var l = un, c = Va(), p = t();
      if (!ld) {
        var g = t();
        Ge(p, g) || (v("The result of getSnapshot should be cached to avoid an infinite loop"), ld = !0);
      }
      var b = c.memoizedState, C = !Ge(b, p);
      C && (c.memoizedState = p, ah());
      var O = c.queue;
      if (th(Kb.bind(null, l, O, e), [e]), O.getSnapshot !== t || C || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Tr !== null && Tr.memoizedState.tag & Cr) {
        l.flags |= li, Zp(Cr | Wr, Xb.bind(null, l, O, p, t), void 0, null);
        var L = Ey();
        if (L === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        nc(L, Tc) || Gb(l, t, p);
      }
      return p;
    }
    function Gb(e, t, a) {
      e.flags |= Do;
      var l = {
        getSnapshot: t,
        value: a
      }, c = un.updateQueue;
      if (c === null)
        c = qb(), un.updateQueue = c, c.stores = [l];
      else {
        var p = c.stores;
        p === null ? c.stores = [l] : p.push(l);
      }
    }
    function Xb(e, t, a, l) {
      t.value = a, t.getSnapshot = l, Jb(t) && Zb(e);
    }
    function Kb(e, t, a) {
      var l = function() {
        Jb(t) && Zb(e);
      };
      return a(l);
    }
    function Jb(e) {
      var t = e.getSnapshot, a = e.value;
      try {
        var l = t();
        return !Ge(a, l);
      } catch {
        return !0;
      }
    }
    function Zb(e) {
      var t = Zi(e, dt);
      t !== null && Or(t, e, dt, yn);
    }
    function Qm(e) {
      var t = ao();
      typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e;
      var a = {
        pending: null,
        interleaved: null,
        lanes: fe,
        dispatch: null,
        lastRenderedReducer: n1,
        lastRenderedState: e
      };
      t.queue = a;
      var l = a.dispatch = bD.bind(null, un, a);
      return [t.memoizedState, l];
    }
    function o1(e) {
      return i1(n1);
    }
    function u1(e) {
      return a1(n1);
    }
    function Zp(e, t, a, l) {
      var c = {
        tag: e,
        create: t,
        destroy: a,
        deps: l,
        // Circular
        next: null
      }, p = un.updateQueue;
      if (p === null)
        p = qb(), un.updateQueue = p, p.lastEffect = c.next = c;
      else {
        var g = p.lastEffect;
        if (g === null)
          p.lastEffect = c.next = c;
        else {
          var b = g.next;
          g.next = c, c.next = b, p.lastEffect = c;
        }
      }
      return c;
    }
    function s1(e) {
      var t = ao();
      {
        var a = {
          current: e
        };
        return t.memoizedState = a, a;
      }
    }
    function qm(e) {
      var t = Va();
      return t.memoizedState;
    }
    function eh(e, t, a, l) {
      var c = ao(), p = l === void 0 ? null : l;
      un.flags |= e, c.memoizedState = Zp(Cr | t, a, void 0, p);
    }
    function Gm(e, t, a, l) {
      var c = Va(), p = l === void 0 ? null : l, g = void 0;
      if (kr !== null) {
        var b = kr.memoizedState;
        if (g = b.destroy, p !== null) {
          var C = b.deps;
          if (t1(p, C)) {
            c.memoizedState = Zp(t, a, g, p);
            return;
          }
        }
      }
      un.flags |= e, c.memoizedState = Zp(Cr | t, a, g, p);
    }
    function Xm(e, t) {
      return (un.mode & Yi) !== ct ? eh(Oo | li | Bl, Wr, e, t) : eh(li | Bl, Wr, e, t);
    }
    function th(e, t) {
      return Gm(li, Wr, e, t);
    }
    function c1(e, t) {
      return eh(et, io, e, t);
    }
    function Km(e, t) {
      return Gm(et, io, e, t);
    }
    function f1(e, t) {
      var a = et;
      return a |= Bi, (un.mode & Yi) !== ct && (a |= Vi), eh(a, wr, e, t);
    }
    function Jm(e, t) {
      return Gm(et, wr, e, t);
    }
    function eE(e, t) {
      if (typeof t == "function") {
        var a = t, l = e();
        return a(l), function() {
          a(null);
        };
      } else if (t != null) {
        var c = t;
        c.hasOwnProperty("current") || v("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(c).join(", ") + "}");
        var p = e();
        return c.current = p, function() {
          c.current = null;
        };
      }
    }
    function d1(e, t, a) {
      typeof t != "function" && v("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t !== null ? typeof t : "null");
      var l = a != null ? a.concat([e]) : null, c = et;
      return c |= Bi, (un.mode & Yi) !== ct && (c |= Vi), eh(c, wr, eE.bind(null, t, e), l);
    }
    function Zm(e, t, a) {
      typeof t != "function" && v("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t !== null ? typeof t : "null");
      var l = a != null ? a.concat([e]) : null;
      return Gm(et, wr, eE.bind(null, t, e), l);
    }
    function yD(e, t) {
    }
    var ey = yD;
    function p1(e, t) {
      var a = ao(), l = t === void 0 ? null : t;
      return a.memoizedState = [e, l], e;
    }
    function ty(e, t) {
      var a = Va(), l = t === void 0 ? null : t, c = a.memoizedState;
      if (c !== null && l !== null) {
        var p = c[1];
        if (t1(l, p))
          return c[0];
      }
      return a.memoizedState = [e, l], e;
    }
    function h1(e, t) {
      var a = ao(), l = t === void 0 ? null : t, c = e();
      return a.memoizedState = [c, l], c;
    }
    function ny(e, t) {
      var a = Va(), l = t === void 0 ? null : t, c = a.memoizedState;
      if (c !== null && l !== null) {
        var p = c[1];
        if (t1(l, p))
          return c[0];
      }
      var g = e();
      return a.memoizedState = [g, l], g;
    }
    function v1(e) {
      var t = ao();
      return t.memoizedState = e, e;
    }
    function tE(e) {
      var t = Va(), a = kr, l = a.memoizedState;
      return rE(t, l, e);
    }
    function nE(e) {
      var t = Va();
      if (kr === null)
        return t.memoizedState = e, e;
      var a = kr.memoizedState;
      return rE(t, a, e);
    }
    function rE(e, t, a) {
      var l = !Mv(Tc);
      if (l) {
        if (!Ge(a, t)) {
          var c = zv();
          un.lanes = Rt(un.lanes, c), yh(c), e.baseState = !0;
        }
        return t;
      } else
        return e.baseState && (e.baseState = !1, ah()), e.memoizedState = a, a;
    }
    function gD(e, t, a) {
      var l = Qi();
      In(Cg(l, dl)), e(!0);
      var c = Xp.transition;
      Xp.transition = {};
      var p = Xp.transition;
      Xp.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), t();
      } finally {
        if (In(l), Xp.transition = c, c === null && p._updatedFibers) {
          var g = p._updatedFibers.size;
          g > 10 && S("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), p._updatedFibers.clear();
        }
      }
    }
    function m1() {
      var e = Qm(!1), t = e[0], a = e[1], l = gD.bind(null, a), c = ao();
      return c.memoizedState = l, [t, l];
    }
    function iE() {
      var e = o1(), t = e[0], a = Va(), l = a.memoizedState;
      return [t, l];
    }
    function aE() {
      var e = u1(), t = e[0], a = Va(), l = a.memoizedState;
      return [t, l];
    }
    var lE = !1;
    function SD() {
      return lE;
    }
    function y1() {
      var e = ao(), t = Ey(), a = t.identifierPrefix, l;
      if (Yr()) {
        var c = L_();
        l = ":" + a + "R" + c;
        var p = Jp++;
        p > 0 && (l += "H" + p.toString(32)), l += ":";
      } else {
        var g = hD++;
        l = ":" + a + "r" + g.toString(32) + ":";
      }
      return e.memoizedState = l, l;
    }
    function ry() {
      var e = Va(), t = e.memoizedState;
      return t;
    }
    function xD(e, t, a) {
      typeof arguments[3] == "function" && v("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var l = ss(e), c = {
        lane: l,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (oE(e))
        uE(t, c);
      else {
        var p = kb(e, t, c, l);
        if (p !== null) {
          var g = Ni();
          Or(p, e, l, g), sE(p, t, l);
        }
      }
      cE(e, l);
    }
    function bD(e, t, a) {
      typeof arguments[3] == "function" && v("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var l = ss(e), c = {
        lane: l,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (oE(e))
        uE(t, c);
      else {
        var p = e.alternate;
        if (e.lanes === fe && (p === null || p.lanes === fe)) {
          var g = t.lastRenderedReducer;
          if (g !== null) {
            var b;
            b = He.current, He.current = bl;
            try {
              var C = t.lastRenderedState, O = g(C, a);
              if (c.hasEagerState = !0, c.eagerState = O, Ge(O, C)) {
                Z_(e, t, c, l);
                return;
              }
            } catch {
            } finally {
              He.current = b;
            }
          }
        }
        var L = kb(e, t, c, l);
        if (L !== null) {
          var B = Ni();
          Or(L, e, l, B), sE(L, t, l);
        }
      }
      cE(e, l);
    }
    function oE(e) {
      var t = e.alternate;
      return e === un || t !== null && t === un;
    }
    function uE(e, t) {
      Kp = Ym = !0;
      var a = e.pending;
      a === null ? t.next = t : (t.next = a.next, a.next = t), e.pending = t;
    }
    function sE(e, t, a) {
      if (op(a)) {
        var l = t.lanes;
        l = Sf(l, e.pendingLanes);
        var c = Rt(l, a);
        t.lanes = c, up(e, c);
      }
    }
    function cE(e, t, a) {
      nf(e, t);
    }
    var iy = {
      readContext: yr,
      useCallback: gi,
      useContext: gi,
      useEffect: gi,
      useImperativeHandle: gi,
      useInsertionEffect: gi,
      useLayoutEffect: gi,
      useMemo: gi,
      useReducer: gi,
      useRef: gi,
      useState: gi,
      useDebugValue: gi,
      useDeferredValue: gi,
      useTransition: gi,
      useMutableSource: gi,
      useSyncExternalStore: gi,
      useId: gi,
      unstable_isNewReconciler: _e
    }, fE = null, dE = null, pE = null, hE = null, lo = null, bl = null, ay = null;
    {
      var g1 = function() {
        v("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, wt = function() {
        v("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      fE = {
        readContext: function(e) {
          return yr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", en(), od(t), p1(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", en(), yr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", en(), od(t), Xm(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", en(), od(a), d1(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", en(), od(t), c1(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", en(), od(t), f1(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", en(), od(t);
          var a = He.current;
          He.current = lo;
          try {
            return h1(e, t);
          } finally {
            He.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", en();
          var l = He.current;
          He.current = lo;
          try {
            return r1(e, t, a);
          } finally {
            He.current = l;
          }
        },
        useRef: function(e) {
          return pe = "useRef", en(), s1(e);
        },
        useState: function(e) {
          pe = "useState", en();
          var t = He.current;
          He.current = lo;
          try {
            return Qm(e);
          } finally {
            He.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", en(), void 0;
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", en(), v1(e);
        },
        useTransition: function() {
          return pe = "useTransition", en(), m1();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", en(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", en(), l1(e, t, a);
        },
        useId: function() {
          return pe = "useId", en(), y1();
        },
        unstable_isNewReconciler: _e
      }, dE = {
        readContext: function(e) {
          return yr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Le(), p1(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Le(), yr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Le(), Xm(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Le(), d1(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Le(), c1(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Le(), f1(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Le();
          var a = He.current;
          He.current = lo;
          try {
            return h1(e, t);
          } finally {
            He.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Le();
          var l = He.current;
          He.current = lo;
          try {
            return r1(e, t, a);
          } finally {
            He.current = l;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Le(), s1(e);
        },
        useState: function(e) {
          pe = "useState", Le();
          var t = He.current;
          He.current = lo;
          try {
            return Qm(e);
          } finally {
            He.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Le(), void 0;
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Le(), v1(e);
        },
        useTransition: function() {
          return pe = "useTransition", Le(), m1();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Le(), l1(e, t, a);
        },
        useId: function() {
          return pe = "useId", Le(), y1();
        },
        unstable_isNewReconciler: _e
      }, pE = {
        readContext: function(e) {
          return yr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Le(), ty(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Le(), yr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Le(), th(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Le(), Zm(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Le(), Km(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Le(), Jm(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Le();
          var a = He.current;
          He.current = bl;
          try {
            return ny(e, t);
          } finally {
            He.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Le();
          var l = He.current;
          He.current = bl;
          try {
            return i1(e, t, a);
          } finally {
            He.current = l;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Le(), qm();
        },
        useState: function(e) {
          pe = "useState", Le();
          var t = He.current;
          He.current = bl;
          try {
            return o1(e);
          } finally {
            He.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Le(), ey();
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Le(), tE(e);
        },
        useTransition: function() {
          return pe = "useTransition", Le(), iE();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Le(), Wm(e, t);
        },
        useId: function() {
          return pe = "useId", Le(), ry();
        },
        unstable_isNewReconciler: _e
      }, hE = {
        readContext: function(e) {
          return yr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Le(), ty(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Le(), yr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Le(), th(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Le(), Zm(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Le(), Km(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Le(), Jm(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Le();
          var a = He.current;
          He.current = ay;
          try {
            return ny(e, t);
          } finally {
            He.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Le();
          var l = He.current;
          He.current = ay;
          try {
            return a1(e, t, a);
          } finally {
            He.current = l;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Le(), qm();
        },
        useState: function(e) {
          pe = "useState", Le();
          var t = He.current;
          He.current = ay;
          try {
            return u1(e);
          } finally {
            He.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Le(), ey();
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Le(), nE(e);
        },
        useTransition: function() {
          return pe = "useTransition", Le(), aE();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Le(), Wm(e, t);
        },
        useId: function() {
          return pe = "useId", Le(), ry();
        },
        unstable_isNewReconciler: _e
      }, lo = {
        readContext: function(e) {
          return g1(), yr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", wt(), en(), p1(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", wt(), en(), yr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", wt(), en(), Xm(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", wt(), en(), d1(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", wt(), en(), c1(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", wt(), en(), f1(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", wt(), en();
          var a = He.current;
          He.current = lo;
          try {
            return h1(e, t);
          } finally {
            He.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", wt(), en();
          var l = He.current;
          He.current = lo;
          try {
            return r1(e, t, a);
          } finally {
            He.current = l;
          }
        },
        useRef: function(e) {
          return pe = "useRef", wt(), en(), s1(e);
        },
        useState: function(e) {
          pe = "useState", wt(), en();
          var t = He.current;
          He.current = lo;
          try {
            return Qm(e);
          } finally {
            He.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", wt(), en(), void 0;
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", wt(), en(), v1(e);
        },
        useTransition: function() {
          return pe = "useTransition", wt(), en(), m1();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", wt(), en(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", wt(), en(), l1(e, t, a);
        },
        useId: function() {
          return pe = "useId", wt(), en(), y1();
        },
        unstable_isNewReconciler: _e
      }, bl = {
        readContext: function(e) {
          return g1(), yr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", wt(), Le(), ty(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", wt(), Le(), yr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", wt(), Le(), th(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", wt(), Le(), Zm(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", wt(), Le(), Km(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", wt(), Le(), Jm(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", wt(), Le();
          var a = He.current;
          He.current = bl;
          try {
            return ny(e, t);
          } finally {
            He.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", wt(), Le();
          var l = He.current;
          He.current = bl;
          try {
            return i1(e, t, a);
          } finally {
            He.current = l;
          }
        },
        useRef: function(e) {
          return pe = "useRef", wt(), Le(), qm();
        },
        useState: function(e) {
          pe = "useState", wt(), Le();
          var t = He.current;
          He.current = bl;
          try {
            return o1(e);
          } finally {
            He.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", wt(), Le(), ey();
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", wt(), Le(), tE(e);
        },
        useTransition: function() {
          return pe = "useTransition", wt(), Le(), iE();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", wt(), Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", wt(), Le(), Wm(e, t);
        },
        useId: function() {
          return pe = "useId", wt(), Le(), ry();
        },
        unstable_isNewReconciler: _e
      }, ay = {
        readContext: function(e) {
          return g1(), yr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", wt(), Le(), ty(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", wt(), Le(), yr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", wt(), Le(), th(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", wt(), Le(), Zm(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", wt(), Le(), Km(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", wt(), Le(), Jm(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", wt(), Le();
          var a = He.current;
          He.current = bl;
          try {
            return ny(e, t);
          } finally {
            He.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", wt(), Le();
          var l = He.current;
          He.current = bl;
          try {
            return a1(e, t, a);
          } finally {
            He.current = l;
          }
        },
        useRef: function(e) {
          return pe = "useRef", wt(), Le(), qm();
        },
        useState: function(e) {
          pe = "useState", wt(), Le();
          var t = He.current;
          He.current = bl;
          try {
            return u1(e);
          } finally {
            He.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", wt(), Le(), ey();
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", wt(), Le(), nE(e);
        },
        useTransition: function() {
          return pe = "useTransition", wt(), Le(), aE();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", wt(), Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", wt(), Le(), Wm(e, t);
        },
        useId: function() {
          return pe = "useId", wt(), Le(), ry();
        },
        unstable_isNewReconciler: _e
      };
    }
    var as = s.unstable_now, vE = 0, ly = -1, nh = -1, oy = -1, S1 = !1, uy = !1;
    function mE() {
      return S1;
    }
    function ED() {
      uy = !0;
    }
    function CD() {
      S1 = !1, uy = !1;
    }
    function wD() {
      S1 = uy, uy = !1;
    }
    function yE() {
      return vE;
    }
    function gE() {
      vE = as();
    }
    function x1(e) {
      nh = as(), e.actualStartTime < 0 && (e.actualStartTime = as());
    }
    function SE(e) {
      nh = -1;
    }
    function sy(e, t) {
      if (nh >= 0) {
        var a = as() - nh;
        e.actualDuration += a, t && (e.selfBaseDuration = a), nh = -1;
      }
    }
    function oo(e) {
      if (ly >= 0) {
        var t = as() - ly;
        ly = -1;
        for (var a = e.return; a !== null; ) {
          switch (a.tag) {
            case N:
              var l = a.stateNode;
              l.effectDuration += t;
              return;
            case Ce:
              var c = a.stateNode;
              c.effectDuration += t;
              return;
          }
          a = a.return;
        }
      }
    }
    function b1(e) {
      if (oy >= 0) {
        var t = as() - oy;
        oy = -1;
        for (var a = e.return; a !== null; ) {
          switch (a.tag) {
            case N:
              var l = a.stateNode;
              l !== null && (l.passiveEffectDuration += t);
              return;
            case Ce:
              var c = a.stateNode;
              c !== null && (c.passiveEffectDuration += t);
              return;
          }
          a = a.return;
        }
      }
    }
    function uo() {
      ly = as();
    }
    function E1() {
      oy = as();
    }
    function C1(e) {
      for (var t = e.child; t; )
        e.actualDuration += t.actualDuration, t = t.sibling;
    }
    function Rc(e, t) {
      return {
        value: e,
        source: t,
        stack: uu(t),
        digest: null
      };
    }
    function w1(e, t, a) {
      return {
        value: e,
        source: null,
        stack: a ?? null,
        digest: t ?? null
      };
    }
    function kD(e, t) {
      return !0;
    }
    function k1(e, t) {
      try {
        var a = kD(e, t);
        if (a === !1)
          return;
        var l = t.value, c = t.source, p = t.stack, g = p !== null ? p : "";
        if (l != null && l._suppressLogging) {
          if (e.tag === R)
            return;
          console.error(l);
        }
        var b = c ? xt(c) : null, C = b ? "The above error occurred in the <" + b + "> component:" : "The above error occurred in one of your React components:", O;
        if (e.tag === N)
          O = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var L = xt(e) || "Anonymous";
          O = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + L + ".");
        }
        var B = C + `
` + g + `

` + ("" + O);
        console.error(B);
      } catch (H) {
        setTimeout(function() {
          throw H;
        });
      }
    }
    var TD = typeof WeakMap == "function" ? WeakMap : Map;
    function xE(e, t, a) {
      var l = Zo(yn, a);
      l.tag = k0, l.payload = {
        element: null
      };
      var c = t.value;
      return l.callback = function() {
        gM(c), k1(e, t);
      }, l;
    }
    function T1(e, t, a) {
      var l = Zo(yn, a);
      l.tag = k0;
      var c = e.type.getDerivedStateFromError;
      if (typeof c == "function") {
        var p = t.value;
        l.payload = function() {
          return c(p);
        }, l.callback = function() {
          MC(e), k1(e, t);
        };
      }
      var g = e.stateNode;
      return g !== null && typeof g.componentDidCatch == "function" && (l.callback = function() {
        MC(e), k1(e, t), typeof c != "function" && mM(this);
        var C = t.value, O = t.stack;
        this.componentDidCatch(C, {
          componentStack: O !== null ? O : ""
        }), typeof c != "function" && (hi(e.lanes, dt) || v("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", xt(e) || "Unknown"));
      }), l;
    }
    function bE(e, t, a) {
      var l = e.pingCache, c;
      if (l === null ? (l = e.pingCache = new TD(), c = /* @__PURE__ */ new Set(), l.set(t, c)) : (c = l.get(t), c === void 0 && (c = /* @__PURE__ */ new Set(), l.set(t, c))), !c.has(a)) {
        c.add(a);
        var p = SM.bind(null, e, t, a);
        _i && gh(e, a), t.then(p, p);
      }
    }
    function RD(e, t, a, l) {
      var c = e.updateQueue;
      if (c === null) {
        var p = /* @__PURE__ */ new Set();
        p.add(a), e.updateQueue = p;
      } else
        c.add(a);
    }
    function _D(e, t) {
      var a = e.tag;
      if ((e.mode & nt) === ct && (a === E || a === Se || a === ze)) {
        var l = e.alternate;
        l ? (e.updateQueue = l.updateQueue, e.memoizedState = l.memoizedState, e.lanes = l.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function EE(e) {
      var t = e;
      do {
        if (t.tag === Y && dD(t))
          return t;
        t = t.return;
      } while (t !== null);
      return null;
    }
    function CE(e, t, a, l, c) {
      if ((e.mode & nt) === ct) {
        if (e === t)
          e.flags |= xr;
        else {
          if (e.flags |= Ct, a.flags |= Gc, a.flags &= ~(yv | Il), a.tag === R) {
            var p = a.alternate;
            if (p === null)
              a.tag = lt;
            else {
              var g = Zo(yn, dt);
              g.tag = Lm, ts(a, g, dt);
            }
          }
          a.lanes = Rt(a.lanes, dt);
        }
        return e;
      }
      return e.flags |= xr, e.lanes = c, e;
    }
    function DD(e, t, a, l, c) {
      if (a.flags |= Il, _i && gh(e, c), l !== null && typeof l == "object" && typeof l.then == "function") {
        var p = l;
        _D(a), Yr() && a.mode & nt && pb();
        var g = EE(t);
        if (g !== null) {
          g.flags &= ~Br, CE(g, t, a, e, c), g.mode & nt && bE(e, p, c), RD(g, e, p);
          return;
        } else {
          if (!lp(c)) {
            bE(e, p, c), aS();
            return;
          }
          var b = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          l = b;
        }
      } else if (Yr() && a.mode & nt) {
        pb();
        var C = EE(t);
        if (C !== null) {
          (C.flags & xr) === st && (C.flags |= Br), CE(C, t, a, e, c), g0(Rc(l, a));
          return;
        }
      }
      l = Rc(l, a), uM(l);
      var O = t;
      do {
        switch (O.tag) {
          case N: {
            var L = l;
            O.flags |= xr;
            var B = Nu(c);
            O.lanes = Rt(O.lanes, B);
            var H = xE(O, L, B);
            _0(O, H);
            return;
          }
          case R:
            var J = l, Z = O.type, le = O.stateNode;
            if ((O.flags & Ct) === st && (typeof Z.getDerivedStateFromError == "function" || le !== null && typeof le.componentDidCatch == "function" && !EC(le))) {
              O.flags |= xr;
              var Be = Nu(c);
              O.lanes = Rt(O.lanes, Be);
              var ft = T1(O, J, Be);
              _0(O, ft);
              return;
            }
            break;
        }
        O = O.return;
      } while (O !== null);
    }
    function OD() {
      return null;
    }
    var rh = f.ReactCurrentOwner, El = !1, R1, ih, _1, D1, O1, _c, M1, cy;
    R1 = {}, ih = {}, _1 = {}, D1 = {}, O1 = {}, _c = !1, M1 = {}, cy = {};
    function Oi(e, t, a, l) {
      e === null ? t.child = Ib(t, null, a, l) : t.child = nd(t, e.child, a, l);
    }
    function MD(e, t, a, l) {
      t.child = nd(t, e.child, null, l), t.child = nd(t, null, a, l);
    }
    function wE(e, t, a, l, c) {
      if (t.type !== t.elementType) {
        var p = a.propTypes;
        p && ml(
          p,
          l,
          // Resolved props
          "prop",
          Vt(a)
        );
      }
      var g = a.render, b = t.ref, C, O;
      td(t, c), wu(t);
      {
        if (rh.current = t, Sr(!0), C = ud(e, t, g, l, b, c), O = sd(), t.mode & Pn) {
          mn(!0);
          try {
            C = ud(e, t, g, l, b, c), O = sd();
          } finally {
            mn(!1);
          }
        }
        Sr(!1);
      }
      return No(), e !== null && !El ? (Wb(e, t, c), eu(e, t, c)) : (Yr() && O && d0(t), t.flags |= ma, Oi(e, t, C, c), t.child);
    }
    function kE(e, t, a, l, c) {
      if (e === null) {
        var p = a.type;
        if (jM(p) && a.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        a.defaultProps === void 0) {
          var g = p;
          return g = yd(p), t.tag = ze, t.type = g, z1(t, p), TE(e, t, g, l, c);
        }
        {
          var b = p.propTypes;
          b && ml(
            b,
            l,
            // Resolved props
            "prop",
            Vt(p)
          );
        }
        var C = mS(a.type, null, l, t, t.mode, c);
        return C.ref = t.ref, C.return = t, t.child = C, C;
      }
      {
        var O = a.type, L = O.propTypes;
        L && ml(
          L,
          l,
          // Resolved props
          "prop",
          Vt(O)
        );
      }
      var B = e.child, H = H1(e, c);
      if (!H) {
        var J = B.memoizedProps, Z = a.compare;
        if (Z = Z !== null ? Z : ht, Z(J, l) && e.ref === t.ref)
          return eu(e, t, c);
      }
      t.flags |= ma;
      var le = Lc(B, l);
      return le.ref = t.ref, le.return = t, t.child = le, le;
    }
    function TE(e, t, a, l, c) {
      if (t.type !== t.elementType) {
        var p = t.elementType;
        if (p.$$typeof === ot) {
          var g = p, b = g._payload, C = g._init;
          try {
            p = C(b);
          } catch {
            p = null;
          }
          var O = p && p.propTypes;
          O && ml(
            O,
            l,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Vt(p)
          );
        }
      }
      if (e !== null) {
        var L = e.memoizedProps;
        if (ht(L, l) && e.ref === t.ref && // Prevent bailout if the implementation changed due to hot reload.
        t.type === e.type)
          if (El = !1, t.pendingProps = l = L, H1(e, c))
            (e.flags & Gc) !== st && (El = !0);
          else
            return t.lanes = e.lanes, eu(e, t, c);
      }
      return N1(e, t, a, l, c);
    }
    function RE(e, t, a) {
      var l = t.pendingProps, c = l.children, p = e !== null ? e.memoizedState : null;
      if (l.mode === "hidden" || ue)
        if ((t.mode & nt) === ct) {
          var g = {
            baseLanes: fe,
            cachePool: null,
            transitions: null
          };
          t.memoizedState = g, Cy(t, a);
        } else if (hi(a, Di)) {
          var B = {
            baseLanes: fe,
            cachePool: null,
            transitions: null
          };
          t.memoizedState = B;
          var H = p !== null ? p.baseLanes : a;
          Cy(t, H);
        } else {
          var b = null, C;
          if (p !== null) {
            var O = p.baseLanes;
            C = Rt(O, a);
          } else
            C = a;
          t.lanes = t.childLanes = Di;
          var L = {
            baseLanes: C,
            cachePool: b,
            transitions: null
          };
          return t.memoizedState = L, t.updateQueue = null, Cy(t, C), null;
        }
      else {
        var J;
        p !== null ? (J = Rt(p.baseLanes, a), t.memoizedState = null) : J = a, Cy(t, J);
      }
      return Oi(e, t, c, a), t.child;
    }
    function ND(e, t, a) {
      var l = t.pendingProps;
      return Oi(e, t, l, a), t.child;
    }
    function LD(e, t, a) {
      var l = t.pendingProps.children;
      return Oi(e, t, l, a), t.child;
    }
    function zD(e, t, a) {
      {
        t.flags |= et;
        {
          var l = t.stateNode;
          l.effectDuration = 0, l.passiveEffectDuration = 0;
        }
      }
      var c = t.pendingProps, p = c.children;
      return Oi(e, t, p, a), t.child;
    }
    function _E(e, t) {
      var a = t.ref;
      (e === null && a !== null || e !== null && e.ref !== a) && (t.flags |= ki, t.flags |= Ma);
    }
    function N1(e, t, a, l, c) {
      if (t.type !== t.elementType) {
        var p = a.propTypes;
        p && ml(
          p,
          l,
          // Resolved props
          "prop",
          Vt(a)
        );
      }
      var g;
      {
        var b = Gf(t, a, !0);
        g = Xf(t, b);
      }
      var C, O;
      td(t, c), wu(t);
      {
        if (rh.current = t, Sr(!0), C = ud(e, t, a, l, g, c), O = sd(), t.mode & Pn) {
          mn(!0);
          try {
            C = ud(e, t, a, l, g, c), O = sd();
          } finally {
            mn(!1);
          }
        }
        Sr(!1);
      }
      return No(), e !== null && !El ? (Wb(e, t, c), eu(e, t, c)) : (Yr() && O && d0(t), t.flags |= ma, Oi(e, t, C, c), t.child);
    }
    function DE(e, t, a, l, c) {
      {
        switch (KM(t)) {
          case !1: {
            var p = t.stateNode, g = t.type, b = new g(t.memoizedProps, p.context), C = b.state;
            p.updater.enqueueSetState(p, C, null);
            break;
          }
          case !0: {
            t.flags |= Ct, t.flags |= xr;
            var O = new Error("Simulated error coming from DevTools"), L = Nu(c);
            t.lanes = Rt(t.lanes, L);
            var B = T1(t, Rc(O, t), L);
            _0(t, B);
            break;
          }
        }
        if (t.type !== t.elementType) {
          var H = a.propTypes;
          H && ml(
            H,
            l,
            // Resolved props
            "prop",
            Vt(a)
          );
        }
      }
      var J;
      ro(a) ? (J = !0, Em(t)) : J = !1, td(t, c);
      var Z = t.stateNode, le;
      Z === null ? (dy(e, t), jb(t, a, l), H0(t, a, l, c), le = !0) : e === null ? le = lD(t, a, l, c) : le = oD(e, t, a, l, c);
      var Be = L1(e, t, a, le, J, c);
      {
        var ft = t.stateNode;
        le && ft.props !== l && (_c || v("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", xt(t) || "a component"), _c = !0);
      }
      return Be;
    }
    function L1(e, t, a, l, c, p) {
      _E(e, t);
      var g = (t.flags & Ct) !== st;
      if (!l && !g)
        return c && sb(t, a, !1), eu(e, t, p);
      var b = t.stateNode;
      rh.current = t;
      var C;
      if (g && typeof a.getDerivedStateFromError != "function")
        C = null, SE();
      else {
        wu(t);
        {
          if (Sr(!0), C = b.render(), t.mode & Pn) {
            mn(!0);
            try {
              b.render();
            } finally {
              mn(!1);
            }
          }
          Sr(!1);
        }
        No();
      }
      return t.flags |= ma, e !== null && g ? MD(e, t, C, p) : Oi(e, t, C, p), t.memoizedState = b.state, c && sb(t, a, !0), t.child;
    }
    function OE(e) {
      var t = e.stateNode;
      t.pendingContext ? ob(e, t.pendingContext, t.pendingContext !== t.context) : t.context && ob(e, t.context, !1), W0(e, t.containerInfo);
    }
    function AD(e, t, a) {
      if (OE(t), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var l = t.pendingProps, c = t.memoizedState, p = c.element;
      _b(e, t), Um(t, l, null, a);
      var g = t.memoizedState;
      t.stateNode;
      var b = g.element;
      if (c.isDehydrated) {
        var C = {
          element: b,
          isDehydrated: !1,
          cache: g.cache,
          pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
          transitions: g.transitions
        }, O = t.updateQueue;
        if (O.baseState = C, t.memoizedState = C, t.flags & Br) {
          var L = Rc(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), t);
          return ME(e, t, b, a, L);
        } else if (b !== p) {
          var B = Rc(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), t);
          return ME(e, t, b, a, B);
        } else {
          P_(t);
          var H = Ib(t, null, b, a);
          t.child = H;
          for (var J = H; J; )
            J.flags = J.flags & ~fn | Oa, J = J.sibling;
        }
      } else {
        if (Zf(), b === p)
          return eu(e, t, a);
        Oi(e, t, b, a);
      }
      return t.child;
    }
    function ME(e, t, a, l, c) {
      return Zf(), g0(c), t.flags |= Br, Oi(e, t, a, l), t.child;
    }
    function jD(e, t, a) {
      Vb(t), e === null && y0(t);
      var l = t.type, c = t.pendingProps, p = e !== null ? e.memoizedProps : null, g = c.children, b = Jg(l, c);
      return b ? g = null : p !== null && Jg(l, p) && (t.flags |= Ii), _E(e, t), Oi(e, t, g, a), t.child;
    }
    function UD(e, t) {
      return e === null && y0(t), null;
    }
    function FD(e, t, a, l) {
      dy(e, t);
      var c = t.pendingProps, p = a, g = p._payload, b = p._init, C = b(g);
      t.type = C;
      var O = t.tag = UM(C), L = Sl(C, c), B;
      switch (O) {
        case E:
          return z1(t, C), t.type = C = yd(C), B = N1(null, t, C, L, l), B;
        case R:
          return t.type = C = cS(C), B = DE(null, t, C, L, l), B;
        case Se:
          return t.type = C = fS(C), B = wE(null, t, C, L, l), B;
        case Oe: {
          if (t.type !== t.elementType) {
            var H = C.propTypes;
            H && ml(
              H,
              L,
              // Resolved for outer only
              "prop",
              Vt(C)
            );
          }
          return B = kE(
            null,
            t,
            C,
            Sl(C.type, L),
            // The inner type can have defaults too
            l
          ), B;
        }
      }
      var J = "";
      throw C !== null && typeof C == "object" && C.$$typeof === ot && (J = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + C + ". " + ("Lazy element type must resolve to a class or function." + J));
    }
    function PD(e, t, a, l, c) {
      dy(e, t), t.tag = R;
      var p;
      return ro(a) ? (p = !0, Em(t)) : p = !1, td(t, c), jb(t, a, l), H0(t, a, l, c), L1(null, t, a, !0, p, c);
    }
    function HD(e, t, a, l) {
      dy(e, t);
      var c = t.pendingProps, p;
      {
        var g = Gf(t, a, !1);
        p = Xf(t, g);
      }
      td(t, l);
      var b, C;
      wu(t);
      {
        if (a.prototype && typeof a.prototype.render == "function") {
          var O = Vt(a) || "Unknown";
          R1[O] || (v("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", O, O), R1[O] = !0);
        }
        t.mode & Pn && gl.recordLegacyContextWarning(t, null), Sr(!0), rh.current = t, b = ud(null, t, a, c, p, l), C = sd(), Sr(!1);
      }
      if (No(), t.flags |= ma, typeof b == "object" && b !== null && typeof b.render == "function" && b.$$typeof === void 0) {
        var L = Vt(a) || "Unknown";
        ih[L] || (v("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", L, L, L), ih[L] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof b == "object" && b !== null && typeof b.render == "function" && b.$$typeof === void 0
      ) {
        {
          var B = Vt(a) || "Unknown";
          ih[B] || (v("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", B, B, B), ih[B] = !0);
        }
        t.tag = R, t.memoizedState = null, t.updateQueue = null;
        var H = !1;
        return ro(a) ? (H = !0, Em(t)) : H = !1, t.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null, R0(t), Ab(t, b), H0(t, a, c, l), L1(null, t, a, !0, H, l);
      } else {
        if (t.tag = E, t.mode & Pn) {
          mn(!0);
          try {
            b = ud(null, t, a, c, p, l), C = sd();
          } finally {
            mn(!1);
          }
        }
        return Yr() && C && d0(t), Oi(null, t, b, l), z1(t, a), t.child;
      }
    }
    function z1(e, t) {
      {
        if (t && t.childContextTypes && v("%s(...): childContextTypes cannot be defined on a function component.", t.displayName || t.name || "Component"), e.ref !== null) {
          var a = "", l = Fi();
          l && (a += `

Check the render method of \`` + l + "`.");
          var c = l || "", p = e._debugSource;
          p && (c = p.fileName + ":" + p.lineNumber), O1[c] || (O1[c] = !0, v("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", a));
        }
        if (typeof t.getDerivedStateFromProps == "function") {
          var g = Vt(t) || "Unknown";
          D1[g] || (v("%s: Function components do not support getDerivedStateFromProps.", g), D1[g] = !0);
        }
        if (typeof t.contextType == "object" && t.contextType !== null) {
          var b = Vt(t) || "Unknown";
          _1[b] || (v("%s: Function components do not support contextType.", b), _1[b] = !0);
        }
      }
    }
    var A1 = {
      dehydrated: null,
      treeContext: null,
      retryLane: Qn
    };
    function j1(e) {
      return {
        baseLanes: e,
        cachePool: OD(),
        transitions: null
      };
    }
    function ID(e, t) {
      var a = null;
      return {
        baseLanes: Rt(e.baseLanes, t),
        cachePool: a,
        transitions: e.transitions
      };
    }
    function BD(e, t, a, l) {
      if (t !== null) {
        var c = t.memoizedState;
        if (c === null)
          return !1;
      }
      return G0(e, Gp);
    }
    function VD(e, t) {
      return rc(e.childLanes, t);
    }
    function NE(e, t, a) {
      var l = t.pendingProps;
      JM(t) && (t.flags |= Ct);
      var c = xl.current, p = !1, g = (t.flags & Ct) !== st;
      if (g || BD(c, e) ? (p = !0, t.flags &= ~Ct) : (e === null || e.memoizedState !== null) && (c = fD(c, Yb)), c = id(c), rs(t, c), e === null) {
        y0(t);
        var b = t.memoizedState;
        if (b !== null) {
          var C = b.dehydrated;
          if (C !== null)
            return qD(t, C);
        }
        var O = l.children, L = l.fallback;
        if (p) {
          var B = $D(t, O, L, a), H = t.child;
          return H.memoizedState = j1(a), t.memoizedState = A1, B;
        } else
          return U1(t, O);
      } else {
        var J = e.memoizedState;
        if (J !== null) {
          var Z = J.dehydrated;
          if (Z !== null)
            return GD(e, t, g, l, Z, J, a);
        }
        if (p) {
          var le = l.fallback, Be = l.children, ft = WD(e, t, Be, le, a), rt = t.child, It = e.child.memoizedState;
          return rt.memoizedState = It === null ? j1(a) : ID(It, a), rt.childLanes = VD(e, a), t.memoizedState = A1, ft;
        } else {
          var jt = l.children, Q = YD(e, t, jt, a);
          return t.memoizedState = null, Q;
        }
      }
    }
    function U1(e, t, a) {
      var l = e.mode, c = {
        mode: "visible",
        children: t
      }, p = F1(c, l);
      return p.return = e, e.child = p, p;
    }
    function $D(e, t, a, l) {
      var c = e.mode, p = e.child, g = {
        mode: "hidden",
        children: t
      }, b, C;
      return (c & nt) === ct && p !== null ? (b = p, b.childLanes = fe, b.pendingProps = g, e.mode & Wt && (b.actualDuration = 0, b.actualStartTime = -1, b.selfBaseDuration = 0, b.treeBaseDuration = 0), C = fs(a, c, l, null)) : (b = F1(g, c), C = fs(a, c, l, null)), b.return = e, C.return = e, b.sibling = C, e.child = b, C;
    }
    function F1(e, t, a) {
      return LC(e, t, fe, null);
    }
    function LE(e, t) {
      return Lc(e, t);
    }
    function YD(e, t, a, l) {
      var c = e.child, p = c.sibling, g = LE(c, {
        mode: "visible",
        children: a
      });
      if ((t.mode & nt) === ct && (g.lanes = l), g.return = t, g.sibling = null, p !== null) {
        var b = t.deletions;
        b === null ? (t.deletions = [p], t.flags |= qt) : b.push(p);
      }
      return t.child = g, g;
    }
    function WD(e, t, a, l, c) {
      var p = t.mode, g = e.child, b = g.sibling, C = {
        mode: "hidden",
        children: a
      }, O;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (p & nt) === ct && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        t.child !== g
      ) {
        var L = t.child;
        O = L, O.childLanes = fe, O.pendingProps = C, t.mode & Wt && (O.actualDuration = 0, O.actualStartTime = -1, O.selfBaseDuration = g.selfBaseDuration, O.treeBaseDuration = g.treeBaseDuration), t.deletions = null;
      } else
        O = LE(g, C), O.subtreeFlags = g.subtreeFlags & br;
      var B;
      return b !== null ? B = Lc(b, l) : (B = fs(l, p, c, null), B.flags |= fn), B.return = t, O.return = t, O.sibling = B, t.child = O, B;
    }
    function fy(e, t, a, l) {
      l !== null && g0(l), nd(t, e.child, null, a);
      var c = t.pendingProps, p = c.children, g = U1(t, p);
      return g.flags |= fn, t.memoizedState = null, g;
    }
    function QD(e, t, a, l, c) {
      var p = t.mode, g = {
        mode: "visible",
        children: a
      }, b = F1(g, p), C = fs(l, p, c, null);
      return C.flags |= fn, b.return = t, C.return = t, b.sibling = C, t.child = b, (t.mode & nt) !== ct && nd(t, e.child, null, c), C;
    }
    function qD(e, t, a) {
      return (e.mode & nt) === ct ? (v("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = dt) : n0(t) ? e.lanes = Hn : e.lanes = Di, null;
    }
    function GD(e, t, a, l, c, p, g) {
      if (a)
        if (t.flags & Br) {
          t.flags &= ~Br;
          var Q = w1(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return fy(e, t, g, Q);
        } else {
          if (t.memoizedState !== null)
            return t.child = e.child, t.flags |= Ct, null;
          var oe = l.children, q = l.fallback, be = QD(e, t, oe, q, g), Ve = t.child;
          return Ve.memoizedState = j1(g), t.memoizedState = A1, be;
        }
      else {
        if (U_(), (t.mode & nt) === ct)
          return fy(
            e,
            t,
            g,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (n0(c)) {
          var b, C, O;
          {
            var L = e_(c);
            b = L.digest, C = L.message, O = L.stack;
          }
          var B;
          C ? B = new Error(C) : B = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var H = w1(B, b, O);
          return fy(e, t, g, H);
        }
        var J = hi(g, e.childLanes);
        if (El || J) {
          var Z = Ey();
          if (Z !== null) {
            var le = Uv(Z, g);
            if (le !== Qn && le !== p.retryLane) {
              p.retryLane = le;
              var Be = yn;
              Zi(e, le), Or(Z, e, le, Be);
            }
          }
          aS();
          var ft = w1(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return fy(e, t, g, ft);
        } else if (tb(c)) {
          t.flags |= Ct, t.child = e.child;
          var rt = xM.bind(null, e);
          return t_(c, rt), null;
        } else {
          H_(t, c, p.treeContext);
          var It = l.children, jt = U1(t, It);
          return jt.flags |= Oa, jt;
        }
      }
    }
    function zE(e, t, a) {
      e.lanes = Rt(e.lanes, t);
      var l = e.alternate;
      l !== null && (l.lanes = Rt(l.lanes, t)), C0(e.return, t, a);
    }
    function XD(e, t, a) {
      for (var l = t; l !== null; ) {
        if (l.tag === Y) {
          var c = l.memoizedState;
          c !== null && zE(l, a, e);
        } else if (l.tag === ne)
          zE(l, a, e);
        else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === e)
          return;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === e)
            return;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    function KD(e) {
      for (var t = e, a = null; t !== null; ) {
        var l = t.alternate;
        l !== null && $m(l) === null && (a = t), t = t.sibling;
      }
      return a;
    }
    function JD(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !M1[e])
        if (M1[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              v('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              v('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              v('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          v('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function ZD(e, t) {
      e !== void 0 && !cy[e] && (e !== "collapsed" && e !== "hidden" ? (cy[e] = !0, v('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : t !== "forwards" && t !== "backwards" && (cy[e] = !0, v('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function AE(e, t) {
      {
        var a = $t(e), l = !a && typeof wa(e) == "function";
        if (a || l) {
          var c = a ? "array" : "iterable";
          return v("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", c, t, c), !1;
        }
      }
      return !0;
    }
    function eO(e, t) {
      if ((t === "forwards" || t === "backwards") && e !== void 0 && e !== null && e !== !1)
        if ($t(e)) {
          for (var a = 0; a < e.length; a++)
            if (!AE(e[a], a))
              return;
        } else {
          var l = wa(e);
          if (typeof l == "function") {
            var c = l.call(e);
            if (c)
              for (var p = c.next(), g = 0; !p.done; p = c.next()) {
                if (!AE(p.value, g))
                  return;
                g++;
              }
          } else
            v('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', t);
        }
    }
    function P1(e, t, a, l, c) {
      var p = e.memoizedState;
      p === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: l,
        tail: a,
        tailMode: c
      } : (p.isBackwards = t, p.rendering = null, p.renderingStartTime = 0, p.last = l, p.tail = a, p.tailMode = c);
    }
    function jE(e, t, a) {
      var l = t.pendingProps, c = l.revealOrder, p = l.tail, g = l.children;
      JD(c), ZD(p, c), eO(g, c), Oi(e, t, g, a);
      var b = xl.current, C = G0(b, Gp);
      if (C)
        b = X0(b, Gp), t.flags |= Ct;
      else {
        var O = e !== null && (e.flags & Ct) !== st;
        O && XD(t, t.child, a), b = id(b);
      }
      if (rs(t, b), (t.mode & nt) === ct)
        t.memoizedState = null;
      else
        switch (c) {
          case "forwards": {
            var L = KD(t.child), B;
            L === null ? (B = t.child, t.child = null) : (B = L.sibling, L.sibling = null), P1(
              t,
              !1,
              // isBackwards
              B,
              L,
              p
            );
            break;
          }
          case "backwards": {
            var H = null, J = t.child;
            for (t.child = null; J !== null; ) {
              var Z = J.alternate;
              if (Z !== null && $m(Z) === null) {
                t.child = J;
                break;
              }
              var le = J.sibling;
              J.sibling = H, H = J, J = le;
            }
            P1(
              t,
              !0,
              // isBackwards
              H,
              null,
              // last
              p
            );
            break;
          }
          case "together": {
            P1(
              t,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            t.memoizedState = null;
        }
      return t.child;
    }
    function tO(e, t, a) {
      W0(t, t.stateNode.containerInfo);
      var l = t.pendingProps;
      return e === null ? t.child = nd(t, null, l, a) : Oi(e, t, l, a), t.child;
    }
    var UE = !1;
    function nO(e, t, a) {
      var l = t.type, c = l._context, p = t.pendingProps, g = t.memoizedProps, b = p.value;
      {
        "value" in p || UE || (UE = !0, v("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var C = t.type.propTypes;
        C && ml(C, p, "prop", "Context.Provider");
      }
      if (wb(t, c, b), g !== null) {
        var O = g.value;
        if (Ge(O, b)) {
          if (g.children === p.children && !xm())
            return eu(e, t, a);
        } else
          X_(t, c, a);
      }
      var L = p.children;
      return Oi(e, t, L, a), t.child;
    }
    var FE = !1;
    function rO(e, t, a) {
      var l = t.type;
      l._context === void 0 ? l !== l.Consumer && (FE || (FE = !0, v("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : l = l._context;
      var c = t.pendingProps, p = c.children;
      typeof p != "function" && v("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), td(t, a);
      var g = yr(l);
      wu(t);
      var b;
      return rh.current = t, Sr(!0), b = p(g), Sr(!1), No(), t.flags |= ma, Oi(e, t, b, a), t.child;
    }
    function ah() {
      El = !0;
    }
    function dy(e, t) {
      (t.mode & nt) === ct && e !== null && (e.alternate = null, t.alternate = null, t.flags |= fn);
    }
    function eu(e, t, a) {
      return e !== null && (t.dependencies = e.dependencies), SE(), yh(t.lanes), hi(a, t.childLanes) ? (uD(e, t), t.child) : null;
    }
    function iO(e, t, a) {
      {
        var l = t.return;
        if (l === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, t.alternate = null, a.index = t.index, a.sibling = t.sibling, a.return = t.return, a.ref = t.ref, t === l.child)
          l.child = a;
        else {
          var c = l.child;
          if (c === null)
            throw new Error("Expected parent to have a child.");
          for (; c.sibling !== t; )
            if (c = c.sibling, c === null)
              throw new Error("Expected to find the previous sibling.");
          c.sibling = a;
        }
        var p = l.deletions;
        return p === null ? (l.deletions = [e], l.flags |= qt) : p.push(e), a.flags |= fn, a;
      }
    }
    function H1(e, t) {
      var a = e.lanes;
      return !!hi(a, t);
    }
    function aO(e, t, a) {
      switch (t.tag) {
        case N:
          OE(t), t.stateNode, Zf();
          break;
        case F:
          Vb(t);
          break;
        case R: {
          var l = t.type;
          ro(l) && Em(t);
          break;
        }
        case M:
          W0(t, t.stateNode.containerInfo);
          break;
        case te: {
          var c = t.memoizedProps.value, p = t.type._context;
          wb(t, p, c);
          break;
        }
        case Ce:
          {
            var g = hi(a, t.childLanes);
            g && (t.flags |= et);
            {
              var b = t.stateNode;
              b.effectDuration = 0, b.passiveEffectDuration = 0;
            }
          }
          break;
        case Y: {
          var C = t.memoizedState;
          if (C !== null) {
            if (C.dehydrated !== null)
              return rs(t, id(xl.current)), t.flags |= Ct, null;
            var O = t.child, L = O.childLanes;
            if (hi(a, L))
              return NE(e, t, a);
            rs(t, id(xl.current));
            var B = eu(e, t, a);
            return B !== null ? B.sibling : null;
          } else
            rs(t, id(xl.current));
          break;
        }
        case ne: {
          var H = (e.flags & Ct) !== st, J = hi(a, t.childLanes);
          if (H) {
            if (J)
              return jE(e, t, a);
            t.flags |= Ct;
          }
          var Z = t.memoizedState;
          if (Z !== null && (Z.rendering = null, Z.tail = null, Z.lastEffect = null), rs(t, xl.current), J)
            break;
          return null;
        }
        case de:
        case ge:
          return t.lanes = fe, RE(e, t, a);
      }
      return eu(e, t, a);
    }
    function PE(e, t, a) {
      if (t._debugNeedsRemount && e !== null)
        return iO(e, t, mS(t.type, t.key, t.pendingProps, t._debugOwner || null, t.mode, t.lanes));
      if (e !== null) {
        var l = e.memoizedProps, c = t.pendingProps;
        if (l !== c || xm() || // Force a re-render if the implementation changed due to hot reload:
        t.type !== e.type)
          El = !0;
        else {
          var p = H1(e, a);
          if (!p && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (t.flags & Ct) === st)
            return El = !1, aO(e, t, a);
          (e.flags & Gc) !== st ? El = !0 : El = !1;
        }
      } else if (El = !1, Yr() && M_(t)) {
        var g = t.index, b = N_();
        db(t, b, g);
      }
      switch (t.lanes = fe, t.tag) {
        case D:
          return HD(e, t, t.type, a);
        case it: {
          var C = t.elementType;
          return FD(e, t, C, a);
        }
        case E: {
          var O = t.type, L = t.pendingProps, B = t.elementType === O ? L : Sl(O, L);
          return N1(e, t, O, B, a);
        }
        case R: {
          var H = t.type, J = t.pendingProps, Z = t.elementType === H ? J : Sl(H, J);
          return DE(e, t, H, Z, a);
        }
        case N:
          return AD(e, t, a);
        case F:
          return jD(e, t, a);
        case $:
          return UD(e, t);
        case Y:
          return NE(e, t, a);
        case M:
          return tO(e, t, a);
        case Se: {
          var le = t.type, Be = t.pendingProps, ft = t.elementType === le ? Be : Sl(le, Be);
          return wE(e, t, le, ft, a);
        }
        case ce:
          return ND(e, t, a);
        case X:
          return LD(e, t, a);
        case Ce:
          return zD(e, t, a);
        case te:
          return nO(e, t, a);
        case se:
          return rO(e, t, a);
        case Oe: {
          var rt = t.type, It = t.pendingProps, jt = Sl(rt, It);
          if (t.type !== t.elementType) {
            var Q = rt.propTypes;
            Q && ml(
              Q,
              jt,
              // Resolved for outer only
              "prop",
              Vt(rt)
            );
          }
          return jt = Sl(rt.type, jt), kE(e, t, rt, jt, a);
        }
        case ze:
          return TE(e, t, t.type, t.pendingProps, a);
        case lt: {
          var oe = t.type, q = t.pendingProps, be = t.elementType === oe ? q : Sl(oe, q);
          return PD(e, t, oe, be, a);
        }
        case ne:
          return jE(e, t, a);
        case we:
          break;
        case de:
          return RE(e, t, a);
      }
      throw new Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function cd(e) {
      e.flags |= et;
    }
    function HE(e) {
      e.flags |= ki, e.flags |= Ma;
    }
    var IE, I1, BE, VE;
    IE = function(e, t, a, l) {
      for (var c = t.child; c !== null; ) {
        if (c.tag === F || c.tag === $)
          _R(e, c.stateNode);
        else if (c.tag !== M) {
          if (c.child !== null) {
            c.child.return = c, c = c.child;
            continue;
          }
        }
        if (c === t)
          return;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === t)
            return;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
    }, I1 = function(e, t) {
    }, BE = function(e, t, a, l, c) {
      var p = e.memoizedProps;
      if (p !== l) {
        var g = t.stateNode, b = Q0(), C = OR(g, a, p, l, c, b);
        t.updateQueue = C, C && cd(t);
      }
    }, VE = function(e, t, a, l) {
      a !== l && cd(t);
    };
    function lh(e, t) {
      if (!Yr())
        switch (e.tailMode) {
          case "hidden": {
            for (var a = e.tail, l = null; a !== null; )
              a.alternate !== null && (l = a), a = a.sibling;
            l === null ? e.tail = null : l.sibling = null;
            break;
          }
          case "collapsed": {
            for (var c = e.tail, p = null; c !== null; )
              c.alternate !== null && (p = c), c = c.sibling;
            p === null ? !t && e.tail !== null ? e.tail.sibling = null : e.tail = null : p.sibling = null;
            break;
          }
        }
    }
    function Qr(e) {
      var t = e.alternate !== null && e.alternate.child === e.child, a = fe, l = st;
      if (t) {
        if ((e.mode & Wt) !== ct) {
          for (var C = e.selfBaseDuration, O = e.child; O !== null; )
            a = Rt(a, Rt(O.lanes, O.childLanes)), l |= O.subtreeFlags & br, l |= O.flags & br, C += O.treeBaseDuration, O = O.sibling;
          e.treeBaseDuration = C;
        } else
          for (var L = e.child; L !== null; )
            a = Rt(a, Rt(L.lanes, L.childLanes)), l |= L.subtreeFlags & br, l |= L.flags & br, L.return = e, L = L.sibling;
        e.subtreeFlags |= l;
      } else {
        if ((e.mode & Wt) !== ct) {
          for (var c = e.actualDuration, p = e.selfBaseDuration, g = e.child; g !== null; )
            a = Rt(a, Rt(g.lanes, g.childLanes)), l |= g.subtreeFlags, l |= g.flags, c += g.actualDuration, p += g.treeBaseDuration, g = g.sibling;
          e.actualDuration = c, e.treeBaseDuration = p;
        } else
          for (var b = e.child; b !== null; )
            a = Rt(a, Rt(b.lanes, b.childLanes)), l |= b.subtreeFlags, l |= b.flags, b.return = e, b = b.sibling;
        e.subtreeFlags |= l;
      }
      return e.childLanes = a, t;
    }
    function lO(e, t, a) {
      if (Y_() && (t.mode & nt) !== ct && (t.flags & Ct) === st)
        return Sb(t), Zf(), t.flags |= Br | Il | xr, !1;
      var l = Rm(t);
      if (a !== null && a.dehydrated !== null)
        if (e === null) {
          if (!l)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (V_(t), Qr(t), (t.mode & Wt) !== ct) {
            var c = a !== null;
            if (c) {
              var p = t.child;
              p !== null && (t.treeBaseDuration -= p.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Zf(), (t.flags & Ct) === st && (t.memoizedState = null), t.flags |= et, Qr(t), (t.mode & Wt) !== ct) {
            var g = a !== null;
            if (g) {
              var b = t.child;
              b !== null && (t.treeBaseDuration -= b.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return xb(), !0;
    }
    function $E(e, t, a) {
      var l = t.pendingProps;
      switch (p0(t), t.tag) {
        case D:
        case it:
        case ze:
        case E:
        case Se:
        case ce:
        case X:
        case Ce:
        case se:
        case Oe:
          return Qr(t), null;
        case R: {
          var c = t.type;
          return ro(c) && bm(t), Qr(t), null;
        }
        case N: {
          var p = t.stateNode;
          if (rd(t), s0(t), J0(), p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null), e === null || e.child === null) {
            var g = Rm(t);
            if (g)
              cd(t);
            else if (e !== null) {
              var b = e.memoizedState;
              // Check if this is a client root
              (!b.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (t.flags & Br) !== st) && (t.flags |= er, xb());
            }
          }
          return I1(e, t), Qr(t), null;
        }
        case F: {
          q0(t);
          var C = Bb(), O = t.type;
          if (e !== null && t.stateNode != null)
            BE(e, t, O, l, C), e.ref !== t.ref && HE(t);
          else {
            if (!l) {
              if (t.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Qr(t), null;
            }
            var L = Q0(), B = Rm(t);
            if (B)
              I_(t, C, L) && cd(t);
            else {
              var H = RR(O, l, C, L, t);
              IE(H, t, !1, !1), t.stateNode = H, DR(H, O, l, C) && cd(t);
            }
            t.ref !== null && HE(t);
          }
          return Qr(t), null;
        }
        case $: {
          var J = l;
          if (e && t.stateNode != null) {
            var Z = e.memoizedProps;
            VE(e, t, Z, J);
          } else {
            if (typeof J != "string" && t.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var le = Bb(), Be = Q0(), ft = Rm(t);
            ft ? B_(t) && cd(t) : t.stateNode = MR(J, le, Be, t);
          }
          return Qr(t), null;
        }
        case Y: {
          ad(t);
          var rt = t.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var It = lO(e, t, rt);
            if (!It)
              return t.flags & xr ? t : null;
          }
          if ((t.flags & Ct) !== st)
            return t.lanes = a, (t.mode & Wt) !== ct && C1(t), t;
          var jt = rt !== null, Q = e !== null && e.memoizedState !== null;
          if (jt !== Q && jt) {
            var oe = t.child;
            if (oe.flags |= Hl, (t.mode & nt) !== ct) {
              var q = e === null && (t.memoizedProps.unstable_avoidThisFallback !== !0 || !Ae);
              q || G0(xl.current, Yb) ? oM() : aS();
            }
          }
          var be = t.updateQueue;
          if (be !== null && (t.flags |= et), Qr(t), (t.mode & Wt) !== ct && jt) {
            var Ve = t.child;
            Ve !== null && (t.treeBaseDuration -= Ve.treeBaseDuration);
          }
          return null;
        }
        case M:
          return rd(t), I1(e, t), e === null && w_(t.stateNode.containerInfo), Qr(t), null;
        case te:
          var Ue = t.type._context;
          return E0(Ue, t), Qr(t), null;
        case lt: {
          var gt = t.type;
          return ro(gt) && bm(t), Qr(t), null;
        }
        case ne: {
          ad(t);
          var kt = t.memoizedState;
          if (kt === null)
            return Qr(t), null;
          var sn = (t.flags & Ct) !== st, Xt = kt.rendering;
          if (Xt === null)
            if (sn)
              lh(kt, !1);
            else {
              var ur = sM() && (e === null || (e.flags & Ct) === st);
              if (!ur)
                for (var Kt = t.child; Kt !== null; ) {
                  var nr = $m(Kt);
                  if (nr !== null) {
                    sn = !0, t.flags |= Ct, lh(kt, !1);
                    var Si = nr.updateQueue;
                    return Si !== null && (t.updateQueue = Si, t.flags |= et), t.subtreeFlags = st, sD(t, a), rs(t, X0(xl.current, Gp)), t.child;
                  }
                  Kt = Kt.sibling;
                }
              kt.tail !== null && tr() > fC() && (t.flags |= Ct, sn = !0, lh(kt, !1), t.lanes = ip);
            }
          else {
            if (!sn) {
              var Jr = $m(Xt);
              if (Jr !== null) {
                t.flags |= Ct, sn = !0;
                var xa = Jr.updateQueue;
                if (xa !== null && (t.updateQueue = xa, t.flags |= et), lh(kt, !0), kt.tail === null && kt.tailMode === "hidden" && !Xt.alternate && !Yr())
                  return Qr(t), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                tr() * 2 - kt.renderingStartTime > fC() && a !== Di && (t.flags |= Ct, sn = !0, lh(kt, !1), t.lanes = ip);
            }
            if (kt.isBackwards)
              Xt.sibling = t.child, t.child = Xt;
            else {
              var Li = kt.last;
              Li !== null ? Li.sibling = Xt : t.child = Xt, kt.last = Xt;
            }
          }
          if (kt.tail !== null) {
            var zi = kt.tail;
            kt.rendering = zi, kt.tail = zi.sibling, kt.renderingStartTime = tr(), zi.sibling = null;
            var xi = xl.current;
            return sn ? xi = X0(xi, Gp) : xi = id(xi), rs(t, xi), zi;
          }
          return Qr(t), null;
        }
        case we:
          break;
        case de:
        case ge: {
          iS(t);
          var au = t.memoizedState, gd = au !== null;
          if (e !== null) {
            var Eh = e.memoizedState, fo = Eh !== null;
            fo !== gd && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !ue && (t.flags |= Hl);
          }
          return !gd || (t.mode & nt) === ct ? Qr(t) : hi(co, Di) && (Qr(t), t.subtreeFlags & (fn | et) && (t.flags |= Hl)), null;
        }
        case Qe:
          return null;
        case Fe:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function oO(e, t, a) {
      switch (p0(t), t.tag) {
        case R: {
          var l = t.type;
          ro(l) && bm(t);
          var c = t.flags;
          return c & xr ? (t.flags = c & ~xr | Ct, (t.mode & Wt) !== ct && C1(t), t) : null;
        }
        case N: {
          t.stateNode, rd(t), s0(t), J0();
          var p = t.flags;
          return (p & xr) !== st && (p & Ct) === st ? (t.flags = p & ~xr | Ct, t) : null;
        }
        case F:
          return q0(t), null;
        case Y: {
          ad(t);
          var g = t.memoizedState;
          if (g !== null && g.dehydrated !== null) {
            if (t.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Zf();
          }
          var b = t.flags;
          return b & xr ? (t.flags = b & ~xr | Ct, (t.mode & Wt) !== ct && C1(t), t) : null;
        }
        case ne:
          return ad(t), null;
        case M:
          return rd(t), null;
        case te:
          var C = t.type._context;
          return E0(C, t), null;
        case de:
        case ge:
          return iS(t), null;
        case Qe:
          return null;
        default:
          return null;
      }
    }
    function YE(e, t, a) {
      switch (p0(t), t.tag) {
        case R: {
          var l = t.type.childContextTypes;
          l != null && bm(t);
          break;
        }
        case N: {
          t.stateNode, rd(t), s0(t), J0();
          break;
        }
        case F: {
          q0(t);
          break;
        }
        case M:
          rd(t);
          break;
        case Y:
          ad(t);
          break;
        case ne:
          ad(t);
          break;
        case te:
          var c = t.type._context;
          E0(c, t);
          break;
        case de:
        case ge:
          iS(t);
          break;
      }
    }
    var WE = null;
    WE = /* @__PURE__ */ new Set();
    var py = !1, qr = !1, uO = typeof WeakSet == "function" ? WeakSet : Set, Xe = null, fd = null, dd = null;
    function sO(e) {
      va(null, function() {
        throw e;
      }), ul();
    }
    var cO = function(e, t) {
      if (t.props = e.memoizedProps, t.state = e.memoizedState, e.mode & Wt)
        try {
          uo(), t.componentWillUnmount();
        } finally {
          oo(e);
        }
      else
        t.componentWillUnmount();
    };
    function QE(e, t) {
      try {
        ls(wr, e);
      } catch (a) {
        Cn(e, t, a);
      }
    }
    function B1(e, t, a) {
      try {
        cO(e, a);
      } catch (l) {
        Cn(e, t, l);
      }
    }
    function fO(e, t, a) {
      try {
        a.componentDidMount();
      } catch (l) {
        Cn(e, t, l);
      }
    }
    function qE(e, t) {
      try {
        XE(e);
      } catch (a) {
        Cn(e, t, a);
      }
    }
    function pd(e, t) {
      var a = e.ref;
      if (a !== null)
        if (typeof a == "function") {
          var l;
          try {
            if (_t && mt && e.mode & Wt)
              try {
                uo(), l = a(null);
              } finally {
                oo(e);
              }
            else
              l = a(null);
          } catch (c) {
            Cn(e, t, c);
          }
          typeof l == "function" && v("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xt(e));
        } else
          a.current = null;
    }
    function hy(e, t, a) {
      try {
        a();
      } catch (l) {
        Cn(e, t, l);
      }
    }
    var GE = !1;
    function dO(e, t) {
      kR(e.containerInfo), Xe = t, pO();
      var a = GE;
      return GE = !1, a;
    }
    function pO() {
      for (; Xe !== null; ) {
        var e = Xe, t = e.child;
        (e.subtreeFlags & oi) !== st && t !== null ? (t.return = e, Xe = t) : hO();
      }
    }
    function hO() {
      for (; Xe !== null; ) {
        var e = Xe;
        Mn(e);
        try {
          vO(e);
        } catch (a) {
          Cn(e, e.return, a);
        }
        Sn();
        var t = e.sibling;
        if (t !== null) {
          t.return = e.return, Xe = t;
          return;
        }
        Xe = e.return;
      }
    }
    function vO(e) {
      var t = e.alternate, a = e.flags;
      if ((a & er) !== st) {
        switch (Mn(e), e.tag) {
          case E:
          case Se:
          case ze:
            break;
          case R: {
            if (t !== null) {
              var l = t.memoizedProps, c = t.memoizedState, p = e.stateNode;
              e.type === e.elementType && !_c && (p.props !== e.memoizedProps && v("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xt(e) || "instance"), p.state !== e.memoizedState && v("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xt(e) || "instance"));
              var g = p.getSnapshotBeforeUpdate(e.elementType === e.type ? l : Sl(e.type, l), c);
              {
                var b = WE;
                g === void 0 && !b.has(e.type) && (b.add(e.type), v("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", xt(e)));
              }
              p.__reactInternalSnapshotBeforeUpdate = g;
            }
            break;
          }
          case N: {
            {
              var C = e.stateNode;
              XR(C.containerInfo);
            }
            break;
          }
          case F:
          case $:
          case M:
          case lt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Sn();
      }
    }
    function Cl(e, t, a) {
      var l = t.updateQueue, c = l !== null ? l.lastEffect : null;
      if (c !== null) {
        var p = c.next, g = p;
        do {
          if ((g.tag & e) === e) {
            var b = g.destroy;
            g.destroy = void 0, b !== void 0 && ((e & Wr) !== ea ? Cv(t) : (e & wr) !== ea && ku(t), (e & io) !== ea && Sh(!0), hy(t, a, b), (e & io) !== ea && Sh(!1), (e & Wr) !== ea ? wv() : (e & wr) !== ea && Ws());
          }
          g = g.next;
        } while (g !== p);
      }
    }
    function ls(e, t) {
      var a = t.updateQueue, l = a !== null ? a.lastEffect : null;
      if (l !== null) {
        var c = l.next, p = c;
        do {
          if ((p.tag & e) === e) {
            (e & Wr) !== ea ? ep(t) : (e & wr) !== ea && kv(t);
            var g = p.create;
            (e & io) !== ea && Sh(!0), p.destroy = g(), (e & io) !== ea && Sh(!1), (e & Wr) !== ea ? tf() : (e & wr) !== ea && tp();
            {
              var b = p.destroy;
              if (b !== void 0 && typeof b != "function") {
                var C = void 0;
                (p.tag & wr) !== st ? C = "useLayoutEffect" : (p.tag & io) !== st ? C = "useInsertionEffect" : C = "useEffect";
                var O = void 0;
                b === null ? O = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof b.then == "function" ? O = `

It looks like you wrote ` + C + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + C + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : O = " You returned: " + b, v("%s must not return anything besides a function, which is used for clean-up.%s", C, O);
              }
            }
          }
          p = p.next;
        } while (p !== c);
      }
    }
    function mO(e, t) {
      if ((t.flags & et) !== st)
        switch (t.tag) {
          case Ce: {
            var a = t.stateNode.passiveEffectDuration, l = t.memoizedProps, c = l.id, p = l.onPostCommit, g = yE(), b = t.alternate === null ? "mount" : "update";
            mE() && (b = "nested-update"), typeof p == "function" && p(c, b, a, g);
            var C = t.return;
            e:
              for (; C !== null; ) {
                switch (C.tag) {
                  case N:
                    var O = C.stateNode;
                    O.passiveEffectDuration += a;
                    break e;
                  case Ce:
                    var L = C.stateNode;
                    L.passiveEffectDuration += a;
                    break e;
                }
                C = C.return;
              }
            break;
          }
        }
    }
    function yO(e, t, a, l) {
      if ((a.flags & ya) !== st)
        switch (a.tag) {
          case E:
          case Se:
          case ze: {
            if (!qr)
              if (a.mode & Wt)
                try {
                  uo(), ls(wr | Cr, a);
                } finally {
                  oo(a);
                }
              else
                ls(wr | Cr, a);
            break;
          }
          case R: {
            var c = a.stateNode;
            if (a.flags & et && !qr)
              if (t === null)
                if (a.type === a.elementType && !_c && (c.props !== a.memoizedProps && v("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xt(a) || "instance"), c.state !== a.memoizedState && v("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xt(a) || "instance")), a.mode & Wt)
                  try {
                    uo(), c.componentDidMount();
                  } finally {
                    oo(a);
                  }
                else
                  c.componentDidMount();
              else {
                var p = a.elementType === a.type ? t.memoizedProps : Sl(a.type, t.memoizedProps), g = t.memoizedState;
                if (a.type === a.elementType && !_c && (c.props !== a.memoizedProps && v("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xt(a) || "instance"), c.state !== a.memoizedState && v("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xt(a) || "instance")), a.mode & Wt)
                  try {
                    uo(), c.componentDidUpdate(p, g, c.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    oo(a);
                  }
                else
                  c.componentDidUpdate(p, g, c.__reactInternalSnapshotBeforeUpdate);
              }
            var b = a.updateQueue;
            b !== null && (a.type === a.elementType && !_c && (c.props !== a.memoizedProps && v("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xt(a) || "instance"), c.state !== a.memoizedState && v("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xt(a) || "instance")), Ob(a, b, c));
            break;
          }
          case N: {
            var C = a.updateQueue;
            if (C !== null) {
              var O = null;
              if (a.child !== null)
                switch (a.child.tag) {
                  case F:
                    O = a.child.stateNode;
                    break;
                  case R:
                    O = a.child.stateNode;
                    break;
                }
              Ob(a, C, O);
            }
            break;
          }
          case F: {
            var L = a.stateNode;
            if (t === null && a.flags & et) {
              var B = a.type, H = a.memoizedProps;
              jR(L, B, H);
            }
            break;
          }
          case $:
            break;
          case M:
            break;
          case Ce: {
            {
              var J = a.memoizedProps, Z = J.onCommit, le = J.onRender, Be = a.stateNode.effectDuration, ft = yE(), rt = t === null ? "mount" : "update";
              mE() && (rt = "nested-update"), typeof le == "function" && le(a.memoizedProps.id, rt, a.actualDuration, a.treeBaseDuration, a.actualStartTime, ft);
              {
                typeof Z == "function" && Z(a.memoizedProps.id, rt, Be, ft), hM(a);
                var It = a.return;
                e:
                  for (; It !== null; ) {
                    switch (It.tag) {
                      case N:
                        var jt = It.stateNode;
                        jt.effectDuration += Be;
                        break e;
                      case Ce:
                        var Q = It.stateNode;
                        Q.effectDuration += Be;
                        break e;
                    }
                    It = It.return;
                  }
              }
            }
            break;
          }
          case Y: {
            kO(e, a);
            break;
          }
          case ne:
          case lt:
          case we:
          case de:
          case ge:
          case Fe:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      qr || a.flags & ki && XE(a);
    }
    function gO(e) {
      switch (e.tag) {
        case E:
        case Se:
        case ze: {
          if (e.mode & Wt)
            try {
              uo(), QE(e, e.return);
            } finally {
              oo(e);
            }
          else
            QE(e, e.return);
          break;
        }
        case R: {
          var t = e.stateNode;
          typeof t.componentDidMount == "function" && fO(e, e.return, t), qE(e, e.return);
          break;
        }
        case F: {
          qE(e, e.return);
          break;
        }
      }
    }
    function SO(e, t) {
      for (var a = null, l = e; ; ) {
        if (l.tag === F) {
          if (a === null) {
            a = l;
            try {
              var c = l.stateNode;
              t ? WR(c) : qR(l.stateNode, l.memoizedProps);
            } catch (g) {
              Cn(e, e.return, g);
            }
          }
        } else if (l.tag === $) {
          if (a === null)
            try {
              var p = l.stateNode;
              t ? QR(p) : GR(p, l.memoizedProps);
            } catch (g) {
              Cn(e, e.return, g);
            }
        } else if (!((l.tag === de || l.tag === ge) && l.memoizedState !== null && l !== e)) {
          if (l.child !== null) {
            l.child.return = l, l = l.child;
            continue;
          }
        }
        if (l === e)
          return;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === e)
            return;
          a === l && (a = null), l = l.return;
        }
        a === l && (a = null), l.sibling.return = l.return, l = l.sibling;
      }
    }
    function XE(e) {
      var t = e.ref;
      if (t !== null) {
        var a = e.stateNode, l;
        switch (e.tag) {
          case F:
            l = a;
            break;
          default:
            l = a;
        }
        if (typeof t == "function") {
          var c;
          if (e.mode & Wt)
            try {
              uo(), c = t(l);
            } finally {
              oo(e);
            }
          else
            c = t(l);
          typeof c == "function" && v("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xt(e));
        } else
          t.hasOwnProperty("current") || v("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", xt(e)), t.current = l;
      }
    }
    function xO(e) {
      var t = e.alternate;
      t !== null && (t.return = null), e.return = null;
    }
    function KE(e) {
      var t = e.alternate;
      t !== null && (e.alternate = null, KE(t));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === F) {
          var a = e.stateNode;
          a !== null && R_(a);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function bO(e) {
      for (var t = e.return; t !== null; ) {
        if (JE(t))
          return t;
        t = t.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function JE(e) {
      return e.tag === F || e.tag === N || e.tag === M;
    }
    function ZE(e) {
      var t = e;
      e:
        for (; ; ) {
          for (; t.sibling === null; ) {
            if (t.return === null || JE(t.return))
              return null;
            t = t.return;
          }
          for (t.sibling.return = t.return, t = t.sibling; t.tag !== F && t.tag !== $ && t.tag !== he; ) {
            if (t.flags & fn || t.child === null || t.tag === M)
              continue e;
            t.child.return = t, t = t.child;
          }
          if (!(t.flags & fn))
            return t.stateNode;
        }
    }
    function EO(e) {
      var t = bO(e);
      switch (t.tag) {
        case F: {
          var a = t.stateNode;
          t.flags & Ii && (eb(a), t.flags &= ~Ii);
          var l = ZE(e);
          $1(e, l, a);
          break;
        }
        case N:
        case M: {
          var c = t.stateNode.containerInfo, p = ZE(e);
          V1(e, p, c);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function V1(e, t, a) {
      var l = e.tag, c = l === F || l === $;
      if (c) {
        var p = e.stateNode;
        t ? BR(a, p, t) : HR(a, p);
      } else if (l !== M) {
        var g = e.child;
        if (g !== null) {
          V1(g, t, a);
          for (var b = g.sibling; b !== null; )
            V1(b, t, a), b = b.sibling;
        }
      }
    }
    function $1(e, t, a) {
      var l = e.tag, c = l === F || l === $;
      if (c) {
        var p = e.stateNode;
        t ? IR(a, p, t) : PR(a, p);
      } else if (l !== M) {
        var g = e.child;
        if (g !== null) {
          $1(g, t, a);
          for (var b = g.sibling; b !== null; )
            $1(b, t, a), b = b.sibling;
        }
      }
    }
    var Gr = null, wl = !1;
    function CO(e, t, a) {
      {
        var l = t;
        e:
          for (; l !== null; ) {
            switch (l.tag) {
              case F: {
                Gr = l.stateNode, wl = !1;
                break e;
              }
              case N: {
                Gr = l.stateNode.containerInfo, wl = !0;
                break e;
              }
              case M: {
                Gr = l.stateNode.containerInfo, wl = !0;
                break e;
              }
            }
            l = l.return;
          }
        if (Gr === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        eC(e, t, a), Gr = null, wl = !1;
      }
      xO(a);
    }
    function os(e, t, a) {
      for (var l = a.child; l !== null; )
        eC(e, t, l), l = l.sibling;
    }
    function eC(e, t, a) {
      switch (bv(a), a.tag) {
        case F:
          qr || pd(a, t);
        case $: {
          {
            var l = Gr, c = wl;
            Gr = null, os(e, t, a), Gr = l, wl = c, Gr !== null && (wl ? $R(Gr, a.stateNode) : VR(Gr, a.stateNode));
          }
          return;
        }
        case he: {
          Gr !== null && (wl ? YR(Gr, a.stateNode) : t0(Gr, a.stateNode));
          return;
        }
        case M: {
          {
            var p = Gr, g = wl;
            Gr = a.stateNode.containerInfo, wl = !0, os(e, t, a), Gr = p, wl = g;
          }
          return;
        }
        case E:
        case Se:
        case Oe:
        case ze: {
          if (!qr) {
            var b = a.updateQueue;
            if (b !== null) {
              var C = b.lastEffect;
              if (C !== null) {
                var O = C.next, L = O;
                do {
                  var B = L, H = B.destroy, J = B.tag;
                  H !== void 0 && ((J & io) !== ea ? hy(a, t, H) : (J & wr) !== ea && (ku(a), a.mode & Wt ? (uo(), hy(a, t, H), oo(a)) : hy(a, t, H), Ws())), L = L.next;
                } while (L !== O);
              }
            }
          }
          os(e, t, a);
          return;
        }
        case R: {
          if (!qr) {
            pd(a, t);
            var Z = a.stateNode;
            typeof Z.componentWillUnmount == "function" && B1(a, t, Z);
          }
          os(e, t, a);
          return;
        }
        case we: {
          os(e, t, a);
          return;
        }
        case de: {
          if (
            // TODO: Remove this dead flag
            a.mode & nt
          ) {
            var le = qr;
            qr = le || a.memoizedState !== null, os(e, t, a), qr = le;
          } else
            os(e, t, a);
          break;
        }
        default: {
          os(e, t, a);
          return;
        }
      }
    }
    function wO(e) {
      e.memoizedState;
    }
    function kO(e, t) {
      var a = t.memoizedState;
      if (a === null) {
        var l = t.alternate;
        if (l !== null) {
          var c = l.memoizedState;
          if (c !== null) {
            var p = c.dehydrated;
            p !== null && c_(p);
          }
        }
      }
    }
    function tC(e) {
      var t = e.updateQueue;
      if (t !== null) {
        e.updateQueue = null;
        var a = e.stateNode;
        a === null && (a = e.stateNode = new uO()), t.forEach(function(l) {
          var c = bM.bind(null, e, l);
          if (!a.has(l)) {
            if (a.add(l), _i)
              if (fd !== null && dd !== null)
                gh(dd, fd);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            l.then(c, c);
          }
        });
      }
    }
    function TO(e, t, a) {
      fd = a, dd = e, Mn(t), nC(t, e), Mn(t), fd = null, dd = null;
    }
    function kl(e, t, a) {
      var l = t.deletions;
      if (l !== null)
        for (var c = 0; c < l.length; c++) {
          var p = l[c];
          try {
            CO(e, t, p);
          } catch (C) {
            Cn(p, t, C);
          }
        }
      var g = ws();
      if (t.subtreeFlags & ui)
        for (var b = t.child; b !== null; )
          Mn(b), nC(b, e), b = b.sibling;
      Mn(g);
    }
    function nC(e, t, a) {
      var l = e.alternate, c = e.flags;
      switch (e.tag) {
        case E:
        case Se:
        case Oe:
        case ze: {
          if (kl(t, e), so(e), c & et) {
            try {
              Cl(io | Cr, e, e.return), ls(io | Cr, e);
            } catch (gt) {
              Cn(e, e.return, gt);
            }
            if (e.mode & Wt) {
              try {
                uo(), Cl(wr | Cr, e, e.return);
              } catch (gt) {
                Cn(e, e.return, gt);
              }
              oo(e);
            } else
              try {
                Cl(wr | Cr, e, e.return);
              } catch (gt) {
                Cn(e, e.return, gt);
              }
          }
          return;
        }
        case R: {
          kl(t, e), so(e), c & ki && l !== null && pd(l, l.return);
          return;
        }
        case F: {
          kl(t, e), so(e), c & ki && l !== null && pd(l, l.return);
          {
            if (e.flags & Ii) {
              var p = e.stateNode;
              try {
                eb(p);
              } catch (gt) {
                Cn(e, e.return, gt);
              }
            }
            if (c & et) {
              var g = e.stateNode;
              if (g != null) {
                var b = e.memoizedProps, C = l !== null ? l.memoizedProps : b, O = e.type, L = e.updateQueue;
                if (e.updateQueue = null, L !== null)
                  try {
                    UR(g, L, O, C, b, e);
                  } catch (gt) {
                    Cn(e, e.return, gt);
                  }
              }
            }
          }
          return;
        }
        case $: {
          if (kl(t, e), so(e), c & et) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var B = e.stateNode, H = e.memoizedProps, J = l !== null ? l.memoizedProps : H;
            try {
              FR(B, J, H);
            } catch (gt) {
              Cn(e, e.return, gt);
            }
          }
          return;
        }
        case N: {
          if (kl(t, e), so(e), c & et && l !== null) {
            var Z = l.memoizedState;
            if (Z.isDehydrated)
              try {
                s_(t.containerInfo);
              } catch (gt) {
                Cn(e, e.return, gt);
              }
          }
          return;
        }
        case M: {
          kl(t, e), so(e);
          return;
        }
        case Y: {
          kl(t, e), so(e);
          var le = e.child;
          if (le.flags & Hl) {
            var Be = le.stateNode, ft = le.memoizedState, rt = ft !== null;
            if (Be.isHidden = rt, rt) {
              var It = le.alternate !== null && le.alternate.memoizedState !== null;
              It || lM();
            }
          }
          if (c & et) {
            try {
              wO(e);
            } catch (gt) {
              Cn(e, e.return, gt);
            }
            tC(e);
          }
          return;
        }
        case de: {
          var jt = l !== null && l.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & nt
          ) {
            var Q = qr;
            qr = Q || jt, kl(t, e), qr = Q;
          } else
            kl(t, e);
          if (so(e), c & Hl) {
            var oe = e.stateNode, q = e.memoizedState, be = q !== null, Ve = e;
            if (oe.isHidden = be, be && !jt && (Ve.mode & nt) !== ct) {
              Xe = Ve;
              for (var Ue = Ve.child; Ue !== null; )
                Xe = Ue, _O(Ue), Ue = Ue.sibling;
            }
            SO(Ve, be);
          }
          return;
        }
        case ne: {
          kl(t, e), so(e), c & et && tC(e);
          return;
        }
        case we:
          return;
        default: {
          kl(t, e), so(e);
          return;
        }
      }
    }
    function so(e) {
      var t = e.flags;
      if (t & fn) {
        try {
          EO(e);
        } catch (a) {
          Cn(e, e.return, a);
        }
        e.flags &= ~fn;
      }
      t & Oa && (e.flags &= ~Oa);
    }
    function RO(e, t, a) {
      fd = a, dd = t, Xe = e, rC(e, t, a), fd = null, dd = null;
    }
    function rC(e, t, a) {
      for (var l = (e.mode & nt) !== ct; Xe !== null; ) {
        var c = Xe, p = c.child;
        if (c.tag === de && l) {
          var g = c.memoizedState !== null, b = g || py;
          if (b) {
            Y1(e, t, a);
            continue;
          } else {
            var C = c.alternate, O = C !== null && C.memoizedState !== null, L = O || qr, B = py, H = qr;
            py = b, qr = L, qr && !H && (Xe = c, DO(c));
            for (var J = p; J !== null; )
              Xe = J, rC(
                J,
                // New root; bubble back up to here and stop.
                t,
                a
              ), J = J.sibling;
            Xe = c, py = B, qr = H, Y1(e, t, a);
            continue;
          }
        }
        (c.subtreeFlags & ya) !== st && p !== null ? (p.return = c, Xe = p) : Y1(e, t, a);
      }
    }
    function Y1(e, t, a) {
      for (; Xe !== null; ) {
        var l = Xe;
        if ((l.flags & ya) !== st) {
          var c = l.alternate;
          Mn(l);
          try {
            yO(t, c, l, a);
          } catch (g) {
            Cn(l, l.return, g);
          }
          Sn();
        }
        if (l === e) {
          Xe = null;
          return;
        }
        var p = l.sibling;
        if (p !== null) {
          p.return = l.return, Xe = p;
          return;
        }
        Xe = l.return;
      }
    }
    function _O(e) {
      for (; Xe !== null; ) {
        var t = Xe, a = t.child;
        switch (t.tag) {
          case E:
          case Se:
          case Oe:
          case ze: {
            if (t.mode & Wt)
              try {
                uo(), Cl(wr, t, t.return);
              } finally {
                oo(t);
              }
            else
              Cl(wr, t, t.return);
            break;
          }
          case R: {
            pd(t, t.return);
            var l = t.stateNode;
            typeof l.componentWillUnmount == "function" && B1(t, t.return, l);
            break;
          }
          case F: {
            pd(t, t.return);
            break;
          }
          case de: {
            var c = t.memoizedState !== null;
            if (c) {
              iC(e);
              continue;
            }
            break;
          }
        }
        a !== null ? (a.return = t, Xe = a) : iC(e);
      }
    }
    function iC(e) {
      for (; Xe !== null; ) {
        var t = Xe;
        if (t === e) {
          Xe = null;
          return;
        }
        var a = t.sibling;
        if (a !== null) {
          a.return = t.return, Xe = a;
          return;
        }
        Xe = t.return;
      }
    }
    function DO(e) {
      for (; Xe !== null; ) {
        var t = Xe, a = t.child;
        if (t.tag === de) {
          var l = t.memoizedState !== null;
          if (l) {
            aC(e);
            continue;
          }
        }
        a !== null ? (a.return = t, Xe = a) : aC(e);
      }
    }
    function aC(e) {
      for (; Xe !== null; ) {
        var t = Xe;
        Mn(t);
        try {
          gO(t);
        } catch (l) {
          Cn(t, t.return, l);
        }
        if (Sn(), t === e) {
          Xe = null;
          return;
        }
        var a = t.sibling;
        if (a !== null) {
          a.return = t.return, Xe = a;
          return;
        }
        Xe = t.return;
      }
    }
    function OO(e, t, a, l) {
      Xe = t, MO(t, e, a, l);
    }
    function MO(e, t, a, l) {
      for (; Xe !== null; ) {
        var c = Xe, p = c.child;
        (c.subtreeFlags & si) !== st && p !== null ? (p.return = c, Xe = p) : NO(e, t, a, l);
      }
    }
    function NO(e, t, a, l) {
      for (; Xe !== null; ) {
        var c = Xe;
        if ((c.flags & li) !== st) {
          Mn(c);
          try {
            LO(t, c, a, l);
          } catch (g) {
            Cn(c, c.return, g);
          }
          Sn();
        }
        if (c === e) {
          Xe = null;
          return;
        }
        var p = c.sibling;
        if (p !== null) {
          p.return = c.return, Xe = p;
          return;
        }
        Xe = c.return;
      }
    }
    function LO(e, t, a, l) {
      switch (t.tag) {
        case E:
        case Se:
        case ze: {
          if (t.mode & Wt) {
            E1();
            try {
              ls(Wr | Cr, t);
            } finally {
              b1(t);
            }
          } else
            ls(Wr | Cr, t);
          break;
        }
      }
    }
    function zO(e) {
      Xe = e, AO();
    }
    function AO() {
      for (; Xe !== null; ) {
        var e = Xe, t = e.child;
        if ((Xe.flags & qt) !== st) {
          var a = e.deletions;
          if (a !== null) {
            for (var l = 0; l < a.length; l++) {
              var c = a[l];
              Xe = c, FO(c, e);
            }
            {
              var p = e.alternate;
              if (p !== null) {
                var g = p.child;
                if (g !== null) {
                  p.child = null;
                  do {
                    var b = g.sibling;
                    g.sibling = null, g = b;
                  } while (g !== null);
                }
              }
            }
            Xe = e;
          }
        }
        (e.subtreeFlags & si) !== st && t !== null ? (t.return = e, Xe = t) : jO();
      }
    }
    function jO() {
      for (; Xe !== null; ) {
        var e = Xe;
        (e.flags & li) !== st && (Mn(e), UO(e), Sn());
        var t = e.sibling;
        if (t !== null) {
          t.return = e.return, Xe = t;
          return;
        }
        Xe = e.return;
      }
    }
    function UO(e) {
      switch (e.tag) {
        case E:
        case Se:
        case ze: {
          e.mode & Wt ? (E1(), Cl(Wr | Cr, e, e.return), b1(e)) : Cl(Wr | Cr, e, e.return);
          break;
        }
      }
    }
    function FO(e, t) {
      for (; Xe !== null; ) {
        var a = Xe;
        Mn(a), HO(a, t), Sn();
        var l = a.child;
        l !== null ? (l.return = a, Xe = l) : PO(e);
      }
    }
    function PO(e) {
      for (; Xe !== null; ) {
        var t = Xe, a = t.sibling, l = t.return;
        if (KE(t), t === e) {
          Xe = null;
          return;
        }
        if (a !== null) {
          a.return = l, Xe = a;
          return;
        }
        Xe = l;
      }
    }
    function HO(e, t) {
      switch (e.tag) {
        case E:
        case Se:
        case ze: {
          e.mode & Wt ? (E1(), Cl(Wr, e, t), b1(e)) : Cl(Wr, e, t);
          break;
        }
      }
    }
    function IO(e) {
      switch (e.tag) {
        case E:
        case Se:
        case ze: {
          try {
            ls(wr | Cr, e);
          } catch (a) {
            Cn(e, e.return, a);
          }
          break;
        }
        case R: {
          var t = e.stateNode;
          try {
            t.componentDidMount();
          } catch (a) {
            Cn(e, e.return, a);
          }
          break;
        }
      }
    }
    function BO(e) {
      switch (e.tag) {
        case E:
        case Se:
        case ze: {
          try {
            ls(Wr | Cr, e);
          } catch (t) {
            Cn(e, e.return, t);
          }
          break;
        }
      }
    }
    function VO(e) {
      switch (e.tag) {
        case E:
        case Se:
        case ze: {
          try {
            Cl(wr | Cr, e, e.return);
          } catch (a) {
            Cn(e, e.return, a);
          }
          break;
        }
        case R: {
          var t = e.stateNode;
          typeof t.componentWillUnmount == "function" && B1(e, e.return, t);
          break;
        }
      }
    }
    function $O(e) {
      switch (e.tag) {
        case E:
        case Se:
        case ze:
          try {
            Cl(Wr | Cr, e, e.return);
          } catch (t) {
            Cn(e, e.return, t);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var oh = Symbol.for;
      oh("selector.component"), oh("selector.has_pseudo_class"), oh("selector.role"), oh("selector.test_id"), oh("selector.text");
    }
    var YO = [];
    function WO() {
      YO.forEach(function(e) {
        return e();
      });
    }
    var QO = f.ReactCurrentActQueue;
    function qO(e) {
      {
        var t = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), a = typeof jest < "u";
        return a && t !== !1;
      }
    }
    function lC() {
      {
        var e = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && QO.current !== null && v("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var GO = Math.ceil, W1 = f.ReactCurrentDispatcher, Q1 = f.ReactCurrentOwner, Xr = f.ReactCurrentBatchConfig, Tl = f.ReactCurrentActQueue, Rr = (
      /*             */
      0
    ), oC = (
      /*               */
      1
    ), Kr = (
      /*                */
      2
    ), $a = (
      /*                */
      4
    ), tu = 0, uh = 1, Dc = 2, vy = 3, sh = 4, uC = 5, q1 = 6, Ht = Rr, Mi = null, Kn = null, _r = fe, co = fe, G1 = Ku(fe), Dr = tu, ch = null, my = fe, fh = fe, yy = fe, dh = null, ta = null, X1 = 0, sC = 500, cC = 1 / 0, XO = 500, nu = null;
    function ph() {
      cC = tr() + XO;
    }
    function fC() {
      return cC;
    }
    var gy = !1, K1 = null, hd = null, Oc = !1, us = null, hh = fe, J1 = [], Z1 = null, KO = 50, vh = 0, eS = null, tS = !1, Sy = !1, JO = 50, vd = 0, xy = null, mh = yn, by = fe, dC = !1;
    function Ey() {
      return Mi;
    }
    function Ni() {
      return (Ht & (Kr | $a)) !== Rr ? tr() : (mh !== yn || (mh = tr()), mh);
    }
    function ss(e) {
      var t = e.mode;
      if ((t & nt) === ct)
        return dt;
      if ((Ht & Kr) !== Rr && _r !== fe)
        return Nu(_r);
      var a = q_() !== Q_;
      if (a) {
        if (Xr.transition !== null) {
          var l = Xr.transition;
          l._updatedFibers || (l._updatedFibers = /* @__PURE__ */ new Set()), l._updatedFibers.add(e);
        }
        return by === Qn && (by = zv()), by;
      }
      var c = Qi();
      if (c !== Qn)
        return c;
      var p = NR();
      return p;
    }
    function ZO(e) {
      var t = e.mode;
      return (t & nt) === ct ? dt : pi();
    }
    function Or(e, t, a, l) {
      CM(), dC && v("useInsertionEffect must not schedule updates."), tS && (Sy = !0), Io(e, a, l), (Ht & Kr) !== fe && e === Mi ? TM(t) : (_i && Ef(e, t, a), RM(t), e === Mi && ((Ht & Kr) === Rr && (fh = Rt(fh, a)), Dr === sh && cs(e, _r)), na(e, l), a === dt && Ht === Rr && (t.mode & nt) === ct && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Tl.isBatchingLegacy && (ph(), fb()));
    }
    function eM(e, t, a) {
      var l = e.current;
      l.lanes = t, Io(e, t, a), na(e, a);
    }
    function tM(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Ht & Kr) !== Rr
      );
    }
    function na(e, t) {
      var a = e.callbackNode;
      xg(e, t);
      var l = ec(e, e === Mi ? _r : fe);
      if (l === fe) {
        a !== null && _C(a), e.callbackNode = null, e.callbackPriority = Qn;
        return;
      }
      var c = qn(l), p = e.callbackPriority;
      if (p === c && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Tl.current !== null && a !== uS)) {
        a == null && p !== dt && v("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      a != null && _C(a);
      var g;
      if (c === dt)
        e.tag === Ju ? (Tl.isBatchingLegacy !== null && (Tl.didScheduleLegacyUpdate = !0), O_(vC.bind(null, e))) : cb(vC.bind(null, e)), Tl.current !== null ? Tl.current.push(Zu) : zR(function() {
          (Ht & (Kr | $a)) === Rr && Zu();
        }), g = null;
      else {
        var b;
        switch (Er(l)) {
          case Gn:
            b = ci;
            break;
          case dl:
            b = Eu;
            break;
          case Aa:
            b = Na;
            break;
          case Lu:
            b = $s;
            break;
          default:
            b = Na;
            break;
        }
        g = sS(b, pC.bind(null, e));
      }
      e.callbackPriority = c, e.callbackNode = g;
    }
    function pC(e, t) {
      if (CD(), mh = yn, by = fe, (Ht & (Kr | $a)) !== Rr)
        throw new Error("Should not already be working.");
      var a = e.callbackNode, l = iu();
      if (l && e.callbackNode !== a)
        return null;
      var c = ec(e, e === Mi ? _r : fe);
      if (c === fe)
        return null;
      var p = !nc(e, c) && !Lv(e, c) && !t, g = p ? fM(e, c) : wy(e, c);
      if (g !== tu) {
        if (g === Dc) {
          var b = Xl(e);
          b !== fe && (c = b, g = nS(e, b));
        }
        if (g === uh) {
          var C = ch;
          throw Mc(e, fe), cs(e, c), na(e, tr()), C;
        }
        if (g === q1)
          cs(e, c);
        else {
          var O = !nc(e, c), L = e.current.alternate;
          if (O && !rM(L)) {
            if (g = wy(e, c), g === Dc) {
              var B = Xl(e);
              B !== fe && (c = B, g = nS(e, B));
            }
            if (g === uh) {
              var H = ch;
              throw Mc(e, fe), cs(e, c), na(e, tr()), H;
            }
          }
          e.finishedWork = L, e.finishedLanes = c, nM(e, g, c);
        }
      }
      return na(e, tr()), e.callbackNode === a ? pC.bind(null, e) : null;
    }
    function nS(e, t) {
      var a = dh;
      if (Cf(e)) {
        var l = Mc(e, t);
        l.flags |= Br, C_(e.containerInfo);
      }
      var c = wy(e, t);
      if (c !== Dc) {
        var p = ta;
        ta = a, p !== null && hC(p);
      }
      return c;
    }
    function hC(e) {
      ta === null ? ta = e : ta.push.apply(ta, e);
    }
    function nM(e, t, a) {
      switch (t) {
        case tu:
        case uh:
          throw new Error("Root did not complete. This is a bug in React.");
        case Dc: {
          Nc(e, ta, nu);
          break;
        }
        case vy: {
          if (cs(e, a), Ov(a) && // do not delay if we're inside an act() scope
          !DC()) {
            var l = X1 + sC - tr();
            if (l > 10) {
              var c = ec(e, fe);
              if (c !== fe)
                break;
              var p = e.suspendedLanes;
              if (!Ho(p, a)) {
                Ni(), xf(e, p);
                break;
              }
              e.timeoutHandle = Zg(Nc.bind(null, e, ta, nu), l);
              break;
            }
          }
          Nc(e, ta, nu);
          break;
        }
        case sh: {
          if (cs(e, a), Nv(a))
            break;
          if (!DC()) {
            var g = yf(e, a), b = g, C = tr() - b, O = EM(C) - C;
            if (O > 10) {
              e.timeoutHandle = Zg(Nc.bind(null, e, ta, nu), O);
              break;
            }
          }
          Nc(e, ta, nu);
          break;
        }
        case uC: {
          Nc(e, ta, nu);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function rM(e) {
      for (var t = e; ; ) {
        if (t.flags & Do) {
          var a = t.updateQueue;
          if (a !== null) {
            var l = a.stores;
            if (l !== null)
              for (var c = 0; c < l.length; c++) {
                var p = l[c], g = p.getSnapshot, b = p.value;
                try {
                  if (!Ge(g(), b))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var C = t.child;
        if (t.subtreeFlags & Do && C !== null) {
          C.return = t, t = C;
          continue;
        }
        if (t === e)
          return !0;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
            return !0;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      return !0;
    }
    function cs(e, t) {
      t = rc(t, yy), t = rc(t, fh), jv(e, t);
    }
    function vC(e) {
      if (wD(), (Ht & (Kr | $a)) !== Rr)
        throw new Error("Should not already be working.");
      iu();
      var t = ec(e, fe);
      if (!hi(t, dt))
        return na(e, tr()), null;
      var a = wy(e, t);
      if (e.tag !== Ju && a === Dc) {
        var l = Xl(e);
        l !== fe && (t = l, a = nS(e, l));
      }
      if (a === uh) {
        var c = ch;
        throw Mc(e, fe), cs(e, t), na(e, tr()), c;
      }
      if (a === q1)
        throw new Error("Root did not complete. This is a bug in React.");
      var p = e.current.alternate;
      return e.finishedWork = p, e.finishedLanes = t, Nc(e, ta, nu), na(e, tr()), null;
    }
    function iM(e, t) {
      t !== fe && (up(e, Rt(t, dt)), na(e, tr()), (Ht & (Kr | $a)) === Rr && (ph(), Zu()));
    }
    function rS(e, t) {
      var a = Ht;
      Ht |= oC;
      try {
        return e(t);
      } finally {
        Ht = a, Ht === Rr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Tl.isBatchingLegacy && (ph(), fb());
      }
    }
    function aM(e, t, a, l, c) {
      var p = Qi(), g = Xr.transition;
      try {
        return Xr.transition = null, In(Gn), e(t, a, l, c);
      } finally {
        In(p), Xr.transition = g, Ht === Rr && ph();
      }
    }
    function ru(e) {
      us !== null && us.tag === Ju && (Ht & (Kr | $a)) === Rr && iu();
      var t = Ht;
      Ht |= oC;
      var a = Xr.transition, l = Qi();
      try {
        return Xr.transition = null, In(Gn), e ? e() : void 0;
      } finally {
        In(l), Xr.transition = a, Ht = t, (Ht & (Kr | $a)) === Rr && Zu();
      }
    }
    function mC() {
      return (Ht & (Kr | $a)) !== Rr;
    }
    function Cy(e, t) {
      yi(G1, co, e), co = Rt(co, t);
    }
    function iS(e) {
      co = G1.current, mi(G1, e);
    }
    function Mc(e, t) {
      e.finishedWork = null, e.finishedLanes = fe;
      var a = e.timeoutHandle;
      if (a !== e0 && (e.timeoutHandle = e0, LR(a)), Kn !== null)
        for (var l = Kn.return; l !== null; ) {
          var c = l.alternate;
          YE(c, l), l = l.return;
        }
      Mi = e;
      var p = Lc(e.current, null);
      return Kn = p, _r = co = t, Dr = tu, ch = null, my = fe, fh = fe, yy = fe, dh = null, ta = null, J_(), gl.discardPendingWarnings(), p;
    }
    function yC(e, t) {
      do {
        var a = Kn;
        try {
          if (Mm(), Qb(), Sn(), Q1.current = null, a === null || a.return === null) {
            Dr = uh, ch = t, Kn = null;
            return;
          }
          if (_t && a.mode & Wt && sy(a, !0), at)
            if (No(), t !== null && typeof t == "object" && typeof t.then == "function") {
              var l = t;
              Rv(a, l, _r);
            } else
              Tv(a, t, _r);
          DD(e, a.return, a, t, _r), bC(a);
        } catch (c) {
          t = c, Kn === a && a !== null ? (a = a.return, Kn = a) : a = Kn;
          continue;
        }
        return;
      } while (!0);
    }
    function gC() {
      var e = W1.current;
      return W1.current = iy, e === null ? iy : e;
    }
    function SC(e) {
      W1.current = e;
    }
    function lM() {
      X1 = tr();
    }
    function yh(e) {
      my = Rt(e, my);
    }
    function oM() {
      Dr === tu && (Dr = vy);
    }
    function aS() {
      (Dr === tu || Dr === vy || Dr === Dc) && (Dr = sh), Mi !== null && (tc(my) || tc(fh)) && cs(Mi, _r);
    }
    function uM(e) {
      Dr !== sh && (Dr = Dc), dh === null ? dh = [e] : dh.push(e);
    }
    function sM() {
      return Dr === tu;
    }
    function wy(e, t) {
      var a = Ht;
      Ht |= Kr;
      var l = gC();
      if (Mi !== e || _r !== t) {
        if (_i) {
          var c = e.memoizedUpdaters;
          c.size > 0 && (gh(e, _r), c.clear()), sp(e, t);
        }
        nu = ac(), Mc(e, t);
      }
      Ru(t);
      do
        try {
          cM();
          break;
        } catch (p) {
          yC(e, p);
        }
      while (!0);
      if (Mm(), Ht = a, SC(l), Kn !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Ql(), Mi = null, _r = fe, Dr;
    }
    function cM() {
      for (; Kn !== null; )
        xC(Kn);
    }
    function fM(e, t) {
      var a = Ht;
      Ht |= Kr;
      var l = gC();
      if (Mi !== e || _r !== t) {
        if (_i) {
          var c = e.memoizedUpdaters;
          c.size > 0 && (gh(e, _r), c.clear()), sp(e, t);
        }
        nu = ac(), ph(), Mc(e, t);
      }
      Ru(t);
      do
        try {
          dM();
          break;
        } catch (p) {
          yC(e, p);
        }
      while (!0);
      return Mm(), SC(l), Ht = a, Kn !== null ? (qs(), tu) : (Ql(), Mi = null, _r = fe, Dr);
    }
    function dM() {
      for (; Kn !== null && !Sv(); )
        xC(Kn);
    }
    function xC(e) {
      var t = e.alternate;
      Mn(e);
      var a;
      (e.mode & Wt) !== ct ? (x1(e), a = lS(t, e, co), sy(e, !0)) : a = lS(t, e, co), Sn(), e.memoizedProps = e.pendingProps, a === null ? bC(e) : Kn = a, Q1.current = null;
    }
    function bC(e) {
      var t = e;
      do {
        var a = t.alternate, l = t.return;
        if ((t.flags & Il) === st) {
          Mn(t);
          var c = void 0;
          if ((t.mode & Wt) === ct ? c = $E(a, t, co) : (x1(t), c = $E(a, t, co), sy(t, !1)), Sn(), c !== null) {
            Kn = c;
            return;
          }
        } else {
          var p = oO(a, t);
          if (p !== null) {
            p.flags &= sl, Kn = p;
            return;
          }
          if ((t.mode & Wt) !== ct) {
            sy(t, !1);
            for (var g = t.actualDuration, b = t.child; b !== null; )
              g += b.actualDuration, b = b.sibling;
            t.actualDuration = g;
          }
          if (l !== null)
            l.flags |= Il, l.subtreeFlags = st, l.deletions = null;
          else {
            Dr = q1, Kn = null;
            return;
          }
        }
        var C = t.sibling;
        if (C !== null) {
          Kn = C;
          return;
        }
        t = l, Kn = t;
      } while (t !== null);
      Dr === tu && (Dr = uC);
    }
    function Nc(e, t, a) {
      var l = Qi(), c = Xr.transition;
      try {
        Xr.transition = null, In(Gn), pM(e, t, a, l);
      } finally {
        Xr.transition = c, In(l);
      }
      return null;
    }
    function pM(e, t, a, l) {
      do
        iu();
      while (us !== null);
      if (wM(), (Ht & (Kr | $a)) !== Rr)
        throw new Error("Should not already be working.");
      var c = e.finishedWork, p = e.finishedLanes;
      if (Ev(p), c === null)
        return Ys(), null;
      if (p === fe && v("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = fe, c === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = Qn;
      var g = Rt(c.lanes, c.childLanes);
      bf(e, g), e === Mi && (Mi = null, Kn = null, _r = fe), ((c.subtreeFlags & si) !== st || (c.flags & si) !== st) && (Oc || (Oc = !0, Z1 = a, sS(Na, function() {
        return iu(), null;
      })));
      var b = (c.subtreeFlags & (oi | ui | ya | si)) !== st, C = (c.flags & (oi | ui | ya | si)) !== st;
      if (b || C) {
        var O = Xr.transition;
        Xr.transition = null;
        var L = Qi();
        In(Gn);
        var B = Ht;
        Ht |= $a, Q1.current = null, dO(e, c), gE(), TO(e, c, p), TR(e.containerInfo), e.current = c, Tu(p), RO(c, e, p), _v(), bu(), Ht = B, In(L), Xr.transition = O;
      } else
        e.current = c, gE();
      var H = Oc;
      if (Oc ? (Oc = !1, us = e, hh = p) : (vd = 0, xy = null), g = e.pendingLanes, g === fe && (hd = null), H || kC(e.current, !1), Yl(c.stateNode, l), _i && e.memoizedUpdaters.clear(), WO(), na(e, tr()), t !== null)
        for (var J = e.onRecoverableError, Z = 0; Z < t.length; Z++) {
          var le = t[Z], Be = le.stack, ft = le.digest;
          J(le.value, {
            componentStack: Be,
            digest: ft
          });
        }
      if (gy) {
        gy = !1;
        var rt = K1;
        throw K1 = null, rt;
      }
      return hi(hh, dt) && e.tag !== Ju && iu(), g = e.pendingLanes, hi(g, dt) ? (ED(), e === eS ? vh++ : (vh = 0, eS = e)) : vh = 0, Zu(), Ys(), null;
    }
    function iu() {
      if (us !== null) {
        var e = Er(hh), t = wg(Aa, e), a = Xr.transition, l = Qi();
        try {
          return Xr.transition = null, In(t), vM();
        } finally {
          In(l), Xr.transition = a;
        }
      }
      return !1;
    }
    function hM(e) {
      J1.push(e), Oc || (Oc = !0, sS(Na, function() {
        return iu(), null;
      }));
    }
    function vM() {
      if (us === null)
        return !1;
      var e = Z1;
      Z1 = null;
      var t = us, a = hh;
      if (us = null, hh = fe, (Ht & (Kr | $a)) !== Rr)
        throw new Error("Cannot flush passive effects while already rendering.");
      tS = !0, Sy = !1, Qs(a);
      var l = Ht;
      Ht |= $a, zO(t.current), OO(t, t.current, a, e);
      {
        var c = J1;
        J1 = [];
        for (var p = 0; p < c.length; p++) {
          var g = c[p];
          mO(t, g);
        }
      }
      La(), kC(t.current, !0), Ht = l, Zu(), Sy ? t === xy ? vd++ : (vd = 0, xy = t) : vd = 0, tS = !1, Sy = !1, Zd(t);
      {
        var b = t.current.stateNode;
        b.effectDuration = 0, b.passiveEffectDuration = 0;
      }
      return !0;
    }
    function EC(e) {
      return hd !== null && hd.has(e);
    }
    function mM(e) {
      hd === null ? hd = /* @__PURE__ */ new Set([e]) : hd.add(e);
    }
    function yM(e) {
      gy || (gy = !0, K1 = e);
    }
    var gM = yM;
    function CC(e, t, a) {
      var l = Rc(a, t), c = xE(e, l, dt), p = ts(e, c, dt), g = Ni();
      p !== null && (Io(p, dt, g), na(p, g));
    }
    function Cn(e, t, a) {
      if (sO(a), Sh(!1), e.tag === N) {
        CC(e, e, a);
        return;
      }
      var l = null;
      for (l = t; l !== null; ) {
        if (l.tag === N) {
          CC(l, e, a);
          return;
        } else if (l.tag === R) {
          var c = l.type, p = l.stateNode;
          if (typeof c.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && !EC(p)) {
            var g = Rc(a, e), b = T1(l, g, dt), C = ts(l, b, dt), O = Ni();
            C !== null && (Io(C, dt, O), na(C, O));
            return;
          }
        }
        l = l.return;
      }
      v(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, a);
    }
    function SM(e, t, a) {
      var l = e.pingCache;
      l !== null && l.delete(t);
      var c = Ni();
      xf(e, a), _M(e), Mi === e && Ho(_r, a) && (Dr === sh || Dr === vy && Ov(_r) && tr() - X1 < sC ? Mc(e, fe) : yy = Rt(yy, a)), na(e, c);
    }
    function wC(e, t) {
      t === Qn && (t = ZO(e));
      var a = Ni(), l = Zi(e, t);
      l !== null && (Io(l, t, a), na(l, a));
    }
    function xM(e) {
      var t = e.memoizedState, a = Qn;
      t !== null && (a = t.retryLane), wC(e, a);
    }
    function bM(e, t) {
      var a = Qn, l;
      switch (e.tag) {
        case Y:
          l = e.stateNode;
          var c = e.memoizedState;
          c !== null && (a = c.retryLane);
          break;
        case ne:
          l = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      l !== null && l.delete(t), wC(e, a);
    }
    function EM(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : GO(e / 1960) * 1960;
    }
    function CM() {
      if (vh > KO)
        throw vh = 0, eS = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      vd > JO && (vd = 0, xy = null, v("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function wM() {
      gl.flushLegacyContextWarning(), gl.flushPendingUnsafeLifecycleWarnings();
    }
    function kC(e, t) {
      Mn(e), ky(e, Vi, VO), t && ky(e, Oo, $O), ky(e, Vi, IO), t && ky(e, Oo, BO), Sn();
    }
    function ky(e, t, a) {
      for (var l = e, c = null; l !== null; ) {
        var p = l.subtreeFlags & t;
        l !== c && l.child !== null && p !== st ? l = l.child : ((l.flags & t) !== st && a(l), l.sibling !== null ? l = l.sibling : l = c = l.return);
      }
    }
    var Ty = null;
    function TC(e) {
      {
        if ((Ht & Kr) !== Rr || !(e.mode & nt))
          return;
        var t = e.tag;
        if (t !== D && t !== N && t !== R && t !== E && t !== Se && t !== Oe && t !== ze)
          return;
        var a = xt(e) || "ReactComponent";
        if (Ty !== null) {
          if (Ty.has(a))
            return;
          Ty.add(a);
        } else
          Ty = /* @__PURE__ */ new Set([a]);
        var l = On;
        try {
          Mn(e), v("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          l ? Mn(e) : Sn();
        }
      }
    }
    var lS;
    {
      var kM = null;
      lS = function(e, t, a) {
        var l = zC(kM, t);
        try {
          return PE(e, t, a);
        } catch (p) {
          if (F_() || p !== null && typeof p == "object" && typeof p.then == "function")
            throw p;
          if (Mm(), Qb(), YE(e, t), zC(t, l), t.mode & Wt && x1(t), va(null, PE, null, e, t, a), yg()) {
            var c = ul();
            typeof c == "object" && c !== null && c._suppressLogging && typeof p == "object" && p !== null && !p._suppressLogging && (p._suppressLogging = !0);
          }
          throw p;
        }
      };
    }
    var RC = !1, oS;
    oS = /* @__PURE__ */ new Set();
    function TM(e) {
      if (ri && !SD())
        switch (e.tag) {
          case E:
          case Se:
          case ze: {
            var t = Kn && xt(Kn) || "Unknown", a = t;
            if (!oS.has(a)) {
              oS.add(a);
              var l = xt(e) || "Unknown";
              v("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", l, t, t);
            }
            break;
          }
          case R: {
            RC || (v("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), RC = !0);
            break;
          }
        }
    }
    function gh(e, t) {
      if (_i) {
        var a = e.memoizedUpdaters;
        a.forEach(function(l) {
          Ef(e, l, t);
        });
      }
    }
    var uS = {};
    function sS(e, t) {
      {
        var a = Tl.current;
        return a !== null ? (a.push(t), uS) : Xd(e, t);
      }
    }
    function _C(e) {
      if (e !== uS)
        return Zc(e);
    }
    function DC() {
      return Tl.current !== null;
    }
    function RM(e) {
      {
        if (e.mode & nt) {
          if (!lC())
            return;
        } else if (!qO() || Ht !== Rr || e.tag !== E && e.tag !== Se && e.tag !== ze)
          return;
        if (Tl.current === null) {
          var t = On;
          try {
            Mn(e), v(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, xt(e));
          } finally {
            t ? Mn(e) : Sn();
          }
        }
      }
    }
    function _M(e) {
      e.tag !== Ju && lC() && Tl.current === null && v(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Sh(e) {
      dC = e;
    }
    var Ya = null, md = null, DM = function(e) {
      Ya = e;
    };
    function yd(e) {
      {
        if (Ya === null)
          return e;
        var t = Ya(e);
        return t === void 0 ? e : t.current;
      }
    }
    function cS(e) {
      return yd(e);
    }
    function fS(e) {
      {
        if (Ya === null)
          return e;
        var t = Ya(e);
        if (t === void 0) {
          if (e != null && typeof e.render == "function") {
            var a = yd(e.render);
            if (e.render !== a) {
              var l = {
                $$typeof: je,
                render: a
              };
              return e.displayName !== void 0 && (l.displayName = e.displayName), l;
            }
          }
          return e;
        }
        return t.current;
      }
    }
    function OC(e, t) {
      {
        if (Ya === null)
          return !1;
        var a = e.elementType, l = t.type, c = !1, p = typeof l == "object" && l !== null ? l.$$typeof : null;
        switch (e.tag) {
          case R: {
            typeof l == "function" && (c = !0);
            break;
          }
          case E: {
            (typeof l == "function" || p === ot) && (c = !0);
            break;
          }
          case Se: {
            (p === je || p === ot) && (c = !0);
            break;
          }
          case Oe:
          case ze: {
            (p === Dt || p === ot) && (c = !0);
            break;
          }
          default:
            return !1;
        }
        if (c) {
          var g = Ya(a);
          if (g !== void 0 && g === Ya(l))
            return !0;
        }
        return !1;
      }
    }
    function MC(e) {
      {
        if (Ya === null || typeof WeakSet != "function")
          return;
        md === null && (md = /* @__PURE__ */ new WeakSet()), md.add(e);
      }
    }
    var OM = function(e, t) {
      {
        if (Ya === null)
          return;
        var a = t.staleFamilies, l = t.updatedFamilies;
        iu(), ru(function() {
          dS(e.current, l, a);
        });
      }
    }, MM = function(e, t) {
      {
        if (e.context !== ga)
          return;
        iu(), ru(function() {
          xh(t, e, null, null);
        });
      }
    };
    function dS(e, t, a) {
      {
        var l = e.alternate, c = e.child, p = e.sibling, g = e.tag, b = e.type, C = null;
        switch (g) {
          case E:
          case ze:
          case R:
            C = b;
            break;
          case Se:
            C = b.render;
            break;
        }
        if (Ya === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var O = !1, L = !1;
        if (C !== null) {
          var B = Ya(C);
          B !== void 0 && (a.has(B) ? L = !0 : t.has(B) && (g === R ? L = !0 : O = !0));
        }
        if (md !== null && (md.has(e) || l !== null && md.has(l)) && (L = !0), L && (e._debugNeedsRemount = !0), L || O) {
          var H = Zi(e, dt);
          H !== null && Or(H, e, dt, yn);
        }
        c !== null && !L && dS(c, t, a), p !== null && dS(p, t, a);
      }
    }
    var NM = function(e, t) {
      {
        var a = /* @__PURE__ */ new Set(), l = new Set(t.map(function(c) {
          return c.current;
        }));
        return pS(e.current, l, a), a;
      }
    };
    function pS(e, t, a) {
      {
        var l = e.child, c = e.sibling, p = e.tag, g = e.type, b = null;
        switch (p) {
          case E:
          case ze:
          case R:
            b = g;
            break;
          case Se:
            b = g.render;
            break;
        }
        var C = !1;
        b !== null && t.has(b) && (C = !0), C ? LM(e, a) : l !== null && pS(l, t, a), c !== null && pS(c, t, a);
      }
    }
    function LM(e, t) {
      {
        var a = zM(e, t);
        if (a)
          return;
        for (var l = e; ; ) {
          switch (l.tag) {
            case F:
              t.add(l.stateNode);
              return;
            case M:
              t.add(l.stateNode.containerInfo);
              return;
            case N:
              t.add(l.stateNode.containerInfo);
              return;
          }
          if (l.return === null)
            throw new Error("Expected to reach root first.");
          l = l.return;
        }
      }
    }
    function zM(e, t) {
      for (var a = e, l = !1; ; ) {
        if (a.tag === F)
          l = !0, t.add(a.stateNode);
        else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === e)
          return l;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === e)
            return l;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return !1;
    }
    var hS;
    {
      hS = !1;
      try {
        var NC = Object.preventExtensions({});
      } catch {
        hS = !0;
      }
    }
    function AM(e, t, a, l) {
      this.tag = e, this.key = a, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = t, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = l, this.flags = st, this.subtreeFlags = st, this.deletions = null, this.lanes = fe, this.childLanes = fe, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !hS && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Sa = function(e, t, a, l) {
      return new AM(e, t, a, l);
    };
    function vS(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function jM(e) {
      return typeof e == "function" && !vS(e) && e.defaultProps === void 0;
    }
    function UM(e) {
      if (typeof e == "function")
        return vS(e) ? R : E;
      if (e != null) {
        var t = e.$$typeof;
        if (t === je)
          return Se;
        if (t === Dt)
          return Oe;
      }
      return D;
    }
    function Lc(e, t) {
      var a = e.alternate;
      a === null ? (a = Sa(e.tag, t, e.key, e.mode), a.elementType = e.elementType, a.type = e.type, a.stateNode = e.stateNode, a._debugSource = e._debugSource, a._debugOwner = e._debugOwner, a._debugHookTypes = e._debugHookTypes, a.alternate = e, e.alternate = a) : (a.pendingProps = t, a.type = e.type, a.flags = st, a.subtreeFlags = st, a.deletions = null, a.actualDuration = 0, a.actualStartTime = -1), a.flags = e.flags & br, a.childLanes = e.childLanes, a.lanes = e.lanes, a.child = e.child, a.memoizedProps = e.memoizedProps, a.memoizedState = e.memoizedState, a.updateQueue = e.updateQueue;
      var l = e.dependencies;
      switch (a.dependencies = l === null ? null : {
        lanes: l.lanes,
        firstContext: l.firstContext
      }, a.sibling = e.sibling, a.index = e.index, a.ref = e.ref, a.selfBaseDuration = e.selfBaseDuration, a.treeBaseDuration = e.treeBaseDuration, a._debugNeedsRemount = e._debugNeedsRemount, a.tag) {
        case D:
        case E:
        case ze:
          a.type = yd(e.type);
          break;
        case R:
          a.type = cS(e.type);
          break;
        case Se:
          a.type = fS(e.type);
          break;
      }
      return a;
    }
    function FM(e, t) {
      e.flags &= br | fn;
      var a = e.alternate;
      if (a === null)
        e.childLanes = fe, e.lanes = t, e.child = null, e.subtreeFlags = st, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = a.childLanes, e.lanes = a.lanes, e.child = a.child, e.subtreeFlags = st, e.deletions = null, e.memoizedProps = a.memoizedProps, e.memoizedState = a.memoizedState, e.updateQueue = a.updateQueue, e.type = a.type;
        var l = a.dependencies;
        e.dependencies = l === null ? null : {
          lanes: l.lanes,
          firstContext: l.firstContext
        }, e.selfBaseDuration = a.selfBaseDuration, e.treeBaseDuration = a.treeBaseDuration;
      }
      return e;
    }
    function PM(e, t, a) {
      var l;
      return e === Cm ? (l = nt, t === !0 && (l |= Pn, l |= Yi)) : l = ct, _i && (l |= Wt), Sa(N, null, null, l);
    }
    function mS(e, t, a, l, c, p) {
      var g = D, b = e;
      if (typeof e == "function")
        vS(e) ? (g = R, b = cS(b)) : b = yd(b);
      else if (typeof e == "string")
        g = F;
      else
        e:
          switch (e) {
            case Ei:
              return fs(a.children, c, p, t);
            case Ga:
              g = X, c |= Pn, (c & nt) !== ct && (c |= Yi);
              break;
            case U:
              return HM(a, c, p, t);
            case zt:
              return IM(a, c, p, t);
            case Pt:
              return BM(a, c, p, t);
            case hn:
              return LC(a, c, p, t);
            case Lr:
            case Zn:
            case Ca:
            case vn:
            case pn:
            default: {
              if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                  case me:
                    g = te;
                    break e;
                  case Ne:
                    g = se;
                    break e;
                  case je:
                    g = Se, b = fS(b);
                    break e;
                  case Dt:
                    g = Oe;
                    break e;
                  case ot:
                    g = it, b = null;
                    break e;
                }
              var C = "";
              {
                (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (C += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var O = l ? xt(l) : null;
                O && (C += `

Check the render method of \`` + O + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + C));
            }
          }
      var L = Sa(g, a, t, c);
      return L.elementType = e, L.type = b, L.lanes = p, L._debugOwner = l, L;
    }
    function yS(e, t, a) {
      var l = null;
      l = e._owner;
      var c = e.type, p = e.key, g = e.props, b = mS(c, p, g, l, t, a);
      return b._debugSource = e._source, b._debugOwner = e._owner, b;
    }
    function fs(e, t, a, l) {
      var c = Sa(ce, e, l, t);
      return c.lanes = a, c;
    }
    function HM(e, t, a, l) {
      typeof e.id != "string" && v('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var c = Sa(Ce, e, l, t | Wt);
      return c.elementType = U, c.lanes = a, c.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, c;
    }
    function IM(e, t, a, l) {
      var c = Sa(Y, e, l, t);
      return c.elementType = zt, c.lanes = a, c;
    }
    function BM(e, t, a, l) {
      var c = Sa(ne, e, l, t);
      return c.elementType = Pt, c.lanes = a, c;
    }
    function LC(e, t, a, l) {
      var c = Sa(de, e, l, t);
      c.elementType = hn, c.lanes = a;
      var p = {
        isHidden: !1
      };
      return c.stateNode = p, c;
    }
    function gS(e, t, a) {
      var l = Sa($, e, null, t);
      return l.lanes = a, l;
    }
    function VM() {
      var e = Sa(F, null, null, ct);
      return e.elementType = "DELETED", e;
    }
    function $M(e) {
      var t = Sa(he, null, null, ct);
      return t.stateNode = e, t;
    }
    function SS(e, t, a) {
      var l = e.children !== null ? e.children : [], c = Sa(M, l, e.key, t);
      return c.lanes = a, c.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, c;
    }
    function zC(e, t) {
      return e === null && (e = Sa(D, null, null, ct)), e.tag = t.tag, e.key = t.key, e.elementType = t.elementType, e.type = t.type, e.stateNode = t.stateNode, e.return = t.return, e.child = t.child, e.sibling = t.sibling, e.index = t.index, e.ref = t.ref, e.pendingProps = t.pendingProps, e.memoizedProps = t.memoizedProps, e.updateQueue = t.updateQueue, e.memoizedState = t.memoizedState, e.dependencies = t.dependencies, e.mode = t.mode, e.flags = t.flags, e.subtreeFlags = t.subtreeFlags, e.deletions = t.deletions, e.lanes = t.lanes, e.childLanes = t.childLanes, e.alternate = t.alternate, e.actualDuration = t.actualDuration, e.actualStartTime = t.actualStartTime, e.selfBaseDuration = t.selfBaseDuration, e.treeBaseDuration = t.treeBaseDuration, e._debugSource = t._debugSource, e._debugOwner = t._debugOwner, e._debugNeedsRemount = t._debugNeedsRemount, e._debugHookTypes = t._debugHookTypes, e;
    }
    function YM(e, t, a, l, c) {
      this.tag = t, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = e0, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Qn, this.eventTimes = ic(fe), this.expirationTimes = ic(yn), this.pendingLanes = fe, this.suspendedLanes = fe, this.pingedLanes = fe, this.expiredLanes = fe, this.mutableReadLanes = fe, this.finishedLanes = fe, this.entangledLanes = fe, this.entanglements = ic(fe), this.identifierPrefix = l, this.onRecoverableError = c, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var p = this.pendingUpdatersLaneMap = [], g = 0; g < Wn; g++)
          p.push(/* @__PURE__ */ new Set());
      }
      switch (t) {
        case Cm:
          this._debugRootType = a ? "hydrateRoot()" : "createRoot()";
          break;
        case Ju:
          this._debugRootType = a ? "hydrate()" : "render()";
          break;
      }
    }
    function AC(e, t, a, l, c, p, g, b, C, O) {
      var L = new YM(e, t, a, b, C), B = PM(t, p);
      L.current = B, B.stateNode = L;
      {
        var H = {
          element: l,
          isDehydrated: a,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        B.memoizedState = H;
      }
      return R0(B), L;
    }
    var xS = "18.2.0";
    function WM(e, t, a) {
      var l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return rr(l), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: ei,
        key: l == null ? null : "" + l,
        children: e,
        containerInfo: t,
        implementation: a
      };
    }
    var bS, ES;
    bS = !1, ES = {};
    function jC(e) {
      if (!e)
        return ga;
      var t = Da(e), a = D_(t);
      if (t.tag === R) {
        var l = t.type;
        if (ro(l))
          return ub(t, l, a);
      }
      return a;
    }
    function QM(e, t) {
      {
        var a = Da(e);
        if (a === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var l = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + l);
        }
        var c = Qd(a);
        if (c === null)
          return null;
        if (c.mode & Pn) {
          var p = xt(a) || "Component";
          if (!ES[p]) {
            ES[p] = !0;
            var g = On;
            try {
              Mn(c), a.mode & Pn ? v("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t, t, p) : v("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t, t, p);
            } finally {
              g ? Mn(g) : Sn();
            }
          }
        }
        return c.stateNode;
      }
    }
    function UC(e, t, a, l, c, p, g, b) {
      var C = !1, O = null;
      return AC(e, t, C, O, a, l, c, p, g);
    }
    function FC(e, t, a, l, c, p, g, b, C, O) {
      var L = !0, B = AC(a, l, L, e, c, p, g, b, C);
      B.context = jC(null);
      var H = B.current, J = Ni(), Z = ss(H), le = Zo(J, Z);
      return le.callback = t ?? null, ts(H, le, Z), eM(B, Z, J), B;
    }
    function xh(e, t, a, l) {
      cl(t, e);
      var c = t.current, p = Ni(), g = ss(c);
      np(g);
      var b = jC(a);
      t.context === null ? t.context = b : t.pendingContext = b, ri && On !== null && !bS && (bS = !0, v(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, xt(On) || "Unknown"));
      var C = Zo(p, g);
      C.payload = {
        element: e
      }, l = l === void 0 ? null : l, l !== null && (typeof l != "function" && v("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", l), C.callback = l);
      var O = ts(c, C, g);
      return O !== null && (Or(O, c, g, p), jm(O, c, g)), g;
    }
    function Ry(e) {
      var t = e.current;
      if (!t.child)
        return null;
      switch (t.child.tag) {
        case F:
          return t.child.stateNode;
        default:
          return t.child.stateNode;
      }
    }
    function qM(e) {
      switch (e.tag) {
        case N: {
          var t = e.stateNode;
          if (Cf(t)) {
            var a = bg(t);
            iM(t, a);
          }
          break;
        }
        case Y: {
          ru(function() {
            var c = Zi(e, dt);
            if (c !== null) {
              var p = Ni();
              Or(c, e, dt, p);
            }
          });
          var l = dt;
          CS(e, l);
          break;
        }
      }
    }
    function PC(e, t) {
      var a = e.memoizedState;
      a !== null && a.dehydrated !== null && (a.retryLane = Av(a.retryLane, t));
    }
    function CS(e, t) {
      PC(e, t);
      var a = e.alternate;
      a && PC(a, t);
    }
    function GM(e) {
      if (e.tag === Y) {
        var t = Po, a = Zi(e, t);
        if (a !== null) {
          var l = Ni();
          Or(a, e, t, l);
        }
        CS(e, t);
      }
    }
    function XM(e) {
      if (e.tag === Y) {
        var t = ss(e), a = Zi(e, t);
        if (a !== null) {
          var l = Ni();
          Or(a, e, t, l);
        }
        CS(e, t);
      }
    }
    function HC(e) {
      var t = Gd(e);
      return t === null ? null : t.stateNode;
    }
    var IC = function(e) {
      return null;
    };
    function KM(e) {
      return IC(e);
    }
    var BC = function(e) {
      return !1;
    };
    function JM(e) {
      return BC(e);
    }
    var VC = null, $C = null, YC = null, WC = null, QC = null, qC = null, GC = null, XC = null, KC = null;
    {
      var JC = function(e, t, a) {
        var l = t[a], c = $t(e) ? e.slice() : Mt({}, e);
        return a + 1 === t.length ? ($t(c) ? c.splice(l, 1) : delete c[l], c) : (c[l] = JC(e[l], t, a + 1), c);
      }, ZC = function(e, t) {
        return JC(e, t, 0);
      }, ew = function(e, t, a, l) {
        var c = t[l], p = $t(e) ? e.slice() : Mt({}, e);
        if (l + 1 === t.length) {
          var g = a[l];
          p[g] = p[c], $t(p) ? p.splice(c, 1) : delete p[c];
        } else
          p[c] = ew(
            // $FlowFixMe number or string is fine here
            e[c],
            t,
            a,
            l + 1
          );
        return p;
      }, tw = function(e, t, a) {
        if (t.length !== a.length) {
          S("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var l = 0; l < a.length - 1; l++)
            if (t[l] !== a[l]) {
              S("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return ew(e, t, a, 0);
      }, nw = function(e, t, a, l) {
        if (a >= t.length)
          return l;
        var c = t[a], p = $t(e) ? e.slice() : Mt({}, e);
        return p[c] = nw(e[c], t, a + 1, l), p;
      }, rw = function(e, t, a) {
        return nw(e, t, 0, a);
      }, wS = function(e, t) {
        for (var a = e.memoizedState; a !== null && t > 0; )
          a = a.next, t--;
        return a;
      };
      VC = function(e, t, a, l) {
        var c = wS(e, t);
        if (c !== null) {
          var p = rw(c.memoizedState, a, l);
          c.memoizedState = p, c.baseState = p, e.memoizedProps = Mt({}, e.memoizedProps);
          var g = Zi(e, dt);
          g !== null && Or(g, e, dt, yn);
        }
      }, $C = function(e, t, a) {
        var l = wS(e, t);
        if (l !== null) {
          var c = ZC(l.memoizedState, a);
          l.memoizedState = c, l.baseState = c, e.memoizedProps = Mt({}, e.memoizedProps);
          var p = Zi(e, dt);
          p !== null && Or(p, e, dt, yn);
        }
      }, YC = function(e, t, a, l) {
        var c = wS(e, t);
        if (c !== null) {
          var p = tw(c.memoizedState, a, l);
          c.memoizedState = p, c.baseState = p, e.memoizedProps = Mt({}, e.memoizedProps);
          var g = Zi(e, dt);
          g !== null && Or(g, e, dt, yn);
        }
      }, WC = function(e, t, a) {
        e.pendingProps = rw(e.memoizedProps, t, a), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var l = Zi(e, dt);
        l !== null && Or(l, e, dt, yn);
      }, QC = function(e, t) {
        e.pendingProps = ZC(e.memoizedProps, t), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var a = Zi(e, dt);
        a !== null && Or(a, e, dt, yn);
      }, qC = function(e, t, a) {
        e.pendingProps = tw(e.memoizedProps, t, a), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var l = Zi(e, dt);
        l !== null && Or(l, e, dt, yn);
      }, GC = function(e) {
        var t = Zi(e, dt);
        t !== null && Or(t, e, dt, yn);
      }, XC = function(e) {
        IC = e;
      }, KC = function(e) {
        BC = e;
      };
    }
    function ZM(e) {
      var t = Qd(e);
      return t === null ? null : t.stateNode;
    }
    function eN(e) {
      return null;
    }
    function tN() {
      return On;
    }
    function nN(e) {
      var t = e.findFiberByHostInstance, a = f.ReactCurrentDispatcher;
      return xv({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: VC,
        overrideHookStateDeletePath: $C,
        overrideHookStateRenamePath: YC,
        overrideProps: WC,
        overridePropsDeletePath: QC,
        overridePropsRenamePath: qC,
        setErrorHandler: XC,
        setSuspenseHandler: KC,
        scheduleUpdate: GC,
        currentDispatcherRef: a,
        findHostInstanceByFiber: ZM,
        findFiberByHostInstance: t || eN,
        // React Refresh
        findHostInstancesForRefresh: NM,
        scheduleRefresh: OM,
        scheduleRoot: MM,
        setRefreshHandler: DM,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: tN,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: xS
      });
    }
    var iw = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function kS(e) {
      this._internalRoot = e;
    }
    _y.prototype.render = kS.prototype.render = function(e) {
      var t = this._internalRoot;
      if (t === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? v("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Dy(arguments[1]) ? v("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && v("You passed a second argument to root.render(...) but it only accepts one argument.");
        var a = t.containerInfo;
        if (a.nodeType !== Fn) {
          var l = HC(t.current);
          l && l.parentNode !== a && v("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      xh(e, t, null, null);
    }, _y.prototype.unmount = kS.prototype.unmount = function() {
      typeof arguments[0] == "function" && v("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        mC() && v("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), ru(function() {
          xh(null, e, null, null);
        }), rb(t);
      }
    };
    function rN(e, t) {
      if (!Dy(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      aw(e);
      var a = !1, l = !1, c = "", p = iw;
      t != null && (t.hydrate ? S("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof t == "object" && t !== null && t.$$typeof === Zr && v(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), t.unstable_strictMode === !0 && (a = !0), t.identifierPrefix !== void 0 && (c = t.identifierPrefix), t.onRecoverableError !== void 0 && (p = t.onRecoverableError), t.transitionCallbacks !== void 0 && t.transitionCallbacks);
      var g = UC(e, Cm, null, a, l, c, p);
      mm(g.current, e);
      var b = e.nodeType === Fn ? e.parentNode : e;
      return _p(b), new kS(g);
    }
    function _y(e) {
      this._internalRoot = e;
    }
    function iN(e) {
      e && Rg(e);
    }
    _y.prototype.unstable_scheduleHydration = iN;
    function aN(e, t, a) {
      if (!Dy(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      aw(e), t === void 0 && v("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var l = a ?? null, c = a != null && a.hydratedSources || null, p = !1, g = !1, b = "", C = iw;
      a != null && (a.unstable_strictMode === !0 && (p = !0), a.identifierPrefix !== void 0 && (b = a.identifierPrefix), a.onRecoverableError !== void 0 && (C = a.onRecoverableError));
      var O = FC(t, null, e, Cm, l, p, g, b, C);
      if (mm(O.current, e), _p(e), c)
        for (var L = 0; L < c.length; L++) {
          var B = c[L];
          pD(O, B);
        }
      return new _y(O);
    }
    function Dy(e) {
      return !!(e && (e.nodeType === ai || e.nodeType === Ci || e.nodeType === Od || !A));
    }
    function bh(e) {
      return !!(e && (e.nodeType === ai || e.nodeType === Ci || e.nodeType === Od || e.nodeType === Fn && e.nodeValue === " react-mount-point-unstable "));
    }
    function aw(e) {
      e.nodeType === ai && e.tagName && e.tagName.toUpperCase() === "BODY" && v("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Pp(e) && (e._reactRootContainer ? v("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : v("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var lN = f.ReactCurrentOwner, lw;
    lw = function(e) {
      if (e._reactRootContainer && e.nodeType !== Fn) {
        var t = HC(e._reactRootContainer.current);
        t && t.parentNode !== e && v("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var a = !!e._reactRootContainer, l = TS(e), c = !!(l && Xu(l));
      c && !a && v("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === ai && e.tagName && e.tagName.toUpperCase() === "BODY" && v("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function TS(e) {
      return e ? e.nodeType === Ci ? e.documentElement : e.firstChild : null;
    }
    function ow() {
    }
    function oN(e, t, a, l, c) {
      if (c) {
        if (typeof l == "function") {
          var p = l;
          l = function() {
            var H = Ry(g);
            p.call(H);
          };
        }
        var g = FC(
          t,
          l,
          e,
          Ju,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          ow
        );
        e._reactRootContainer = g, mm(g.current, e);
        var b = e.nodeType === Fn ? e.parentNode : e;
        return _p(b), ru(), g;
      } else {
        for (var C; C = e.lastChild; )
          e.removeChild(C);
        if (typeof l == "function") {
          var O = l;
          l = function() {
            var H = Ry(L);
            O.call(H);
          };
        }
        var L = UC(
          e,
          Ju,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          ow
        );
        e._reactRootContainer = L, mm(L.current, e);
        var B = e.nodeType === Fn ? e.parentNode : e;
        return _p(B), ru(function() {
          xh(t, L, a, l);
        }), L;
      }
    }
    function uN(e, t) {
      e !== null && typeof e != "function" && v("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t, e);
    }
    function Oy(e, t, a, l, c) {
      lw(a), uN(c === void 0 ? null : c, "render");
      var p = a._reactRootContainer, g;
      if (!p)
        g = oN(a, t, e, c, l);
      else {
        if (g = p, typeof c == "function") {
          var b = c;
          c = function() {
            var C = Ry(g);
            b.call(C);
          };
        }
        xh(t, g, e, c);
      }
      return Ry(g);
    }
    function sN(e) {
      {
        var t = lN.current;
        if (t !== null && t.stateNode !== null) {
          var a = t.stateNode._warnedAboutRefsInRender;
          a || v("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Vt(t.type) || "A component"), t.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === ai ? e : QM(e, "findDOMNode");
    }
    function cN(e, t, a) {
      if (v("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !bh(t))
        throw new Error("Target container is not a DOM element.");
      {
        var l = Pp(t) && t._reactRootContainer === void 0;
        l && v("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return Oy(null, e, t, !0, a);
    }
    function fN(e, t, a) {
      if (v("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !bh(t))
        throw new Error("Target container is not a DOM element.");
      {
        var l = Pp(t) && t._reactRootContainer === void 0;
        l && v("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return Oy(null, e, t, !1, a);
    }
    function dN(e, t, a, l) {
      if (v("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !bh(a))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !xu(e))
        throw new Error("parentComponent must be a valid React Component");
      return Oy(e, t, a, !1, l);
    }
    function pN(e) {
      if (!bh(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var t = Pp(e) && e._reactRootContainer === void 0;
        t && v("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var a = TS(e), l = a && !Xu(a);
          l && v("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return ru(function() {
          Oy(null, null, e, !1, function() {
            e._reactRootContainer = null, rb(e);
          });
        }), !0;
      } else {
        {
          var c = TS(e), p = !!(c && Xu(c)), g = e.nodeType === ai && bh(e.parentNode) && !!e.parentNode._reactRootContainer;
          p && v("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", g ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    ju(qM), kg(GM), kf(XM), Fv(Qi), Pv(jr), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && v("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Fd(mR), Qc(rS, aM, ru);
    function hN(e, t) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Dy(t))
        throw new Error("Target container is not a DOM element.");
      return WM(e, t, null, a);
    }
    function vN(e, t, a, l) {
      return dN(e, t, a, l);
    }
    var RS = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Xu, qf, ym, Su, Ro, rS]
    };
    function mN(e, t) {
      return RS.usingClientEntryPoint || v('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), rN(e, t);
    }
    function yN(e, t, a) {
      return RS.usingClientEntryPoint || v('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), aN(e, t, a);
    }
    function gN(e) {
      return mC() && v("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), ru(e);
    }
    var SN = nN({
      findFiberByHostInstance: gc,
      bundleType: 1,
      version: xS,
      rendererPackageName: "react-dom"
    });
    if (!SN && kn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var uw = window.location.protocol;
      /^(https?|file):$/.test(uw) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (uw === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ia.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = RS, ia.createPortal = hN, ia.createRoot = mN, ia.findDOMNode = sN, ia.flushSync = gN, ia.hydrate = cN, ia.hydrateRoot = yN, ia.render = fN, ia.unmountComponentAtNode = pN, ia.unstable_batchedUpdates = rS, ia.unstable_renderSubtreeIntoContainer = vN, ia.version = xS, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(), ia;
}
var Nk = {};
function Lk() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (Nk.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Lk);
    } catch (r) {
      console.error(r);
    }
  }
}
Nk.NODE_ENV === "production" ? (Lk(), WS.exports = MN()) : WS.exports = NN();
var LN = WS.exports, zN = {}, kh = LN;
if (zN.NODE_ENV === "production")
  Oh.createRoot = kh.createRoot, Oh.hydrateRoot = kh.hydrateRoot;
else {
  var Ny = kh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  Oh.createRoot = function(r, o) {
    Ny.usingClientEntryPoint = !0;
    try {
      return kh.createRoot(r, o);
    } finally {
      Ny.usingClientEntryPoint = !1;
    }
  }, Oh.hydrateRoot = function(r, o, s) {
    Ny.usingClientEntryPoint = !0;
    try {
      return kh.hydrateRoot(r, o, s);
    } finally {
      Ny.usingClientEntryPoint = !1;
    }
  };
}
function AN(r, o) {
  const s = o || {};
  return (r[r.length - 1] === "" ? [...r, ""] : r).join(
    (s.padRight ? " " : "") + "," + (s.padLeft === !1 ? "" : " ")
  ).trim();
}
const jN = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, UN = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, FN = {};
function Sw(r, o) {
  return ((o || FN).jsx ? UN : jN).test(r);
}
const PN = /[ \t\n\f\r]/g;
function HN(r) {
  return typeof r == "object" ? r.type === "text" ? xw(r.value) : !1 : xw(r);
}
function xw(r) {
  return r.replace(PN, "") === "";
}
class Fh {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(o, s, f) {
    this.property = o, this.normal = s, f && (this.space = f);
  }
}
Fh.prototype.property = {};
Fh.prototype.normal = {};
Fh.prototype.space = null;
function zk(r, o) {
  const s = {}, f = {};
  let h = -1;
  for (; ++h < r.length; )
    Object.assign(s, r[h].property), Object.assign(f, r[h].normal);
  return new Fh(s, f, o);
}
function QS(r) {
  return r.toLowerCase();
}
class Qa {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(o, s) {
    this.property = o, this.attribute = s;
  }
}
Qa.prototype.space = null;
Qa.prototype.boolean = !1;
Qa.prototype.booleanish = !1;
Qa.prototype.overloadedBoolean = !1;
Qa.prototype.number = !1;
Qa.prototype.commaSeparated = !1;
Qa.prototype.spaceSeparated = !1;
Qa.prototype.commaOrSpaceSeparated = !1;
Qa.prototype.mustUseProperty = !1;
Qa.prototype.defined = !1;
let IN = 0;
const Lt = Uc(), gr = Uc(), Ak = Uc(), Re = Uc(), Rn = Uc(), xd = Uc(), ba = Uc();
function Uc() {
  return 2 ** ++IN;
}
const qS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Lt,
  booleanish: gr,
  commaOrSpaceSeparated: ba,
  commaSeparated: xd,
  number: Re,
  overloadedBoolean: Ak,
  spaceSeparated: Rn
}, Symbol.toStringTag, { value: "Module" })), OS = Object.keys(qS);
class ox extends Qa {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(o, s, f, h) {
    let y = -1;
    if (super(o, s), bw(this, "space", h), typeof f == "number")
      for (; ++y < OS.length; ) {
        const S = OS[y];
        bw(this, OS[y], (f & qS[S]) === qS[S]);
      }
  }
}
ox.prototype.defined = !0;
function bw(r, o, s) {
  s && (r[o] = s);
}
const BN = {}.hasOwnProperty;
function wd(r) {
  const o = {}, s = {};
  let f;
  for (f in r.properties)
    if (BN.call(r.properties, f)) {
      const h = r.properties[f], y = new ox(
        f,
        r.transform(r.attributes || {}, f),
        h,
        r.space
      );
      r.mustUseProperty && r.mustUseProperty.includes(f) && (y.mustUseProperty = !0), o[f] = y, s[QS(f)] = f, s[QS(y.attribute)] = f;
    }
  return new Fh(o, s, r.space);
}
const jk = wd({
  space: "xlink",
  transform(r, o) {
    return "xlink:" + o.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Uk = wd({
  space: "xml",
  transform(r, o) {
    return "xml:" + o.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Fk(r, o) {
  return o in r ? r[o] : o;
}
function Pk(r, o) {
  return Fk(r, o.toLowerCase());
}
const Hk = wd({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Pk,
  properties: { xmlns: null, xmlnsXLink: null }
}), Ik = wd({
  transform(r, o) {
    return o === "role" ? o : "aria-" + o.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: gr,
    ariaAutoComplete: null,
    ariaBusy: gr,
    ariaChecked: gr,
    ariaColCount: Re,
    ariaColIndex: Re,
    ariaColSpan: Re,
    ariaControls: Rn,
    ariaCurrent: null,
    ariaDescribedBy: Rn,
    ariaDetails: null,
    ariaDisabled: gr,
    ariaDropEffect: Rn,
    ariaErrorMessage: null,
    ariaExpanded: gr,
    ariaFlowTo: Rn,
    ariaGrabbed: gr,
    ariaHasPopup: null,
    ariaHidden: gr,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Rn,
    ariaLevel: Re,
    ariaLive: null,
    ariaModal: gr,
    ariaMultiLine: gr,
    ariaMultiSelectable: gr,
    ariaOrientation: null,
    ariaOwns: Rn,
    ariaPlaceholder: null,
    ariaPosInSet: Re,
    ariaPressed: gr,
    ariaReadOnly: gr,
    ariaRelevant: null,
    ariaRequired: gr,
    ariaRoleDescription: Rn,
    ariaRowCount: Re,
    ariaRowIndex: Re,
    ariaRowSpan: Re,
    ariaSelected: gr,
    ariaSetSize: Re,
    ariaSort: null,
    ariaValueMax: Re,
    ariaValueMin: Re,
    ariaValueNow: Re,
    ariaValueText: null,
    role: null
  }
}), VN = wd({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Pk,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: xd,
    acceptCharset: Rn,
    accessKey: Rn,
    action: null,
    allow: null,
    allowFullScreen: Lt,
    allowPaymentRequest: Lt,
    allowUserMedia: Lt,
    alt: null,
    as: null,
    async: Lt,
    autoCapitalize: null,
    autoComplete: Rn,
    autoFocus: Lt,
    autoPlay: Lt,
    blocking: Rn,
    capture: null,
    charSet: null,
    checked: Lt,
    cite: null,
    className: Rn,
    cols: Re,
    colSpan: null,
    content: null,
    contentEditable: gr,
    controls: Lt,
    controlsList: Rn,
    coords: Re | xd,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Lt,
    defer: Lt,
    dir: null,
    dirName: null,
    disabled: Lt,
    download: Ak,
    draggable: gr,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Lt,
    formTarget: null,
    headers: Rn,
    height: Re,
    hidden: Lt,
    high: Re,
    href: null,
    hrefLang: null,
    htmlFor: Rn,
    httpEquiv: Rn,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Lt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Lt,
    itemId: null,
    itemProp: Rn,
    itemRef: Rn,
    itemScope: Lt,
    itemType: Rn,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Lt,
    low: Re,
    manifest: null,
    max: null,
    maxLength: Re,
    media: null,
    method: null,
    min: null,
    minLength: Re,
    multiple: Lt,
    muted: Lt,
    name: null,
    nonce: null,
    noModule: Lt,
    noValidate: Lt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Lt,
    optimum: Re,
    pattern: null,
    ping: Rn,
    placeholder: null,
    playsInline: Lt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Lt,
    referrerPolicy: null,
    rel: Rn,
    required: Lt,
    reversed: Lt,
    rows: Re,
    rowSpan: Re,
    sandbox: Rn,
    scope: null,
    scoped: Lt,
    seamless: Lt,
    selected: Lt,
    shadowRootClonable: Lt,
    shadowRootDelegatesFocus: Lt,
    shadowRootMode: null,
    shape: null,
    size: Re,
    sizes: null,
    slot: null,
    span: Re,
    spellCheck: gr,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Re,
    step: null,
    style: null,
    tabIndex: Re,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Lt,
    useMap: null,
    value: gr,
    width: Re,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Rn,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Re,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Re,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Lt,
    // Lists. Use CSS to reduce space between items instead
    declare: Lt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Re,
    // `<img>` and `<object>`
    leftMargin: Re,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Re,
    // `<body>`
    marginWidth: Re,
    // `<body>`
    noResize: Lt,
    // `<frame>`
    noHref: Lt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Lt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Lt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Re,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: gr,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Re,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Re,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Lt,
    disableRemotePlayback: Lt,
    prefix: null,
    property: null,
    results: Re,
    security: null,
    unselectable: null
  }
}), $N = wd({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Fk,
  properties: {
    about: ba,
    accentHeight: Re,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Re,
    amplitude: Re,
    arabicForm: null,
    ascent: Re,
    attributeName: null,
    attributeType: null,
    azimuth: Re,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Re,
    by: null,
    calcMode: null,
    capHeight: Re,
    className: Rn,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Re,
    diffuseConstant: Re,
    direction: null,
    display: null,
    dur: null,
    divisor: Re,
    dominantBaseline: null,
    download: Lt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Re,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Re,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Re,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: xd,
    g2: xd,
    glyphName: xd,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Re,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Re,
    horizOriginX: Re,
    horizOriginY: Re,
    id: null,
    ideographic: Re,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Re,
    k: Re,
    k1: Re,
    k2: Re,
    k3: Re,
    k4: Re,
    kernelMatrix: ba,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Re,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Re,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Re,
    overlineThickness: Re,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Re,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Rn,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Re,
    pointsAtY: Re,
    pointsAtZ: Re,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: ba,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: ba,
    rev: ba,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: ba,
    requiredFeatures: ba,
    requiredFonts: ba,
    requiredFormats: ba,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Re,
    specularExponent: Re,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Re,
    strikethroughThickness: Re,
    string: null,
    stroke: null,
    strokeDashArray: ba,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Re,
    strokeOpacity: Re,
    strokeWidth: null,
    style: null,
    surfaceScale: Re,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: ba,
    tabIndex: Re,
    tableValues: null,
    target: null,
    targetX: Re,
    targetY: Re,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: ba,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Re,
    underlineThickness: Re,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Re,
    values: null,
    vAlphabetic: Re,
    vMathematical: Re,
    vectorEffect: null,
    vHanging: Re,
    vIdeographic: Re,
    version: null,
    vertAdvY: Re,
    vertOriginX: Re,
    vertOriginY: Re,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Re,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), YN = /^data[-\w.:]+$/i, Ew = /-[a-z]/g, WN = /[A-Z]/g;
function QN(r, o) {
  const s = QS(o);
  let f = o, h = Qa;
  if (s in r.normal)
    return r.property[r.normal[s]];
  if (s.length > 4 && s.slice(0, 4) === "data" && YN.test(o)) {
    if (o.charAt(4) === "-") {
      const y = o.slice(5).replace(Ew, GN);
      f = "data" + y.charAt(0).toUpperCase() + y.slice(1);
    } else {
      const y = o.slice(4);
      if (!Ew.test(y)) {
        let S = y.replace(WN, qN);
        S.charAt(0) !== "-" && (S = "-" + S), o = "data" + S;
      }
    }
    h = ox;
  }
  return new h(f, o);
}
function qN(r) {
  return "-" + r.toLowerCase();
}
function GN(r) {
  return r.charAt(1).toUpperCase();
}
const XN = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, KN = zk([Uk, jk, Hk, Ik, VN], "html"), ux = zk([Uk, jk, Hk, Ik, $N], "svg");
function JN(r) {
  return r.join(" ").trim();
}
var Bk = {}, Cw = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, ZN = /\n/g, e3 = /^\s*/, t3 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, n3 = /^:\s*/, r3 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, i3 = /^[;\s]*/, a3 = /^\s+|\s+$/g, l3 = `
`, ww = "/", kw = "*", zc = "", o3 = "comment", u3 = "declaration", s3 = function(r, o) {
  if (typeof r != "string")
    throw new TypeError("First argument must be a string");
  if (!r)
    return [];
  o = o || {};
  var s = 1, f = 1;
  function h(F) {
    var $ = F.match(ZN);
    $ && (s += $.length);
    var ce = F.lastIndexOf(l3);
    f = ~ce ? F.length - ce : f + F.length;
  }
  function y() {
    var F = { line: s, column: f };
    return function($) {
      return $.position = new S(F), E(), $;
    };
  }
  function S(F) {
    this.start = F, this.end = { line: s, column: f }, this.source = o.source;
  }
  S.prototype.content = r;
  function v(F) {
    var $ = new Error(
      o.source + ":" + s + ":" + f + ": " + F
    );
    if ($.reason = F, $.filename = o.source, $.line = s, $.column = f, $.source = r, !o.silent)
      throw $;
  }
  function w(F) {
    var $ = F.exec(r);
    if ($) {
      var ce = $[0];
      return h(ce), r = r.slice(ce.length), $;
    }
  }
  function E() {
    w(e3);
  }
  function R(F) {
    var $;
    for (F = F || []; $ = D(); )
      $ !== !1 && F.push($);
    return F;
  }
  function D() {
    var F = y();
    if (!(ww != r.charAt(0) || kw != r.charAt(1))) {
      for (var $ = 2; zc != r.charAt($) && (kw != r.charAt($) || ww != r.charAt($ + 1)); )
        ++$;
      if ($ += 2, zc === r.charAt($ - 1))
        return v("End of comment missing");
      var ce = r.slice(2, $ - 2);
      return f += 2, h(ce), r = r.slice($), f += 2, F({
        type: o3,
        comment: ce
      });
    }
  }
  function N() {
    var F = y(), $ = w(t3);
    if ($) {
      if (D(), !w(n3))
        return v("property missing ':'");
      var ce = w(r3), X = F({
        type: u3,
        property: Tw($[0].replace(Cw, zc)),
        value: ce ? Tw(ce[0].replace(Cw, zc)) : zc
      });
      return w(i3), X;
    }
  }
  function M() {
    var F = [];
    R(F);
    for (var $; $ = N(); )
      $ !== !1 && (F.push($), R(F));
    return F;
  }
  return E(), M();
};
function Tw(r) {
  return r ? r.replace(a3, zc) : zc;
}
var c3 = sw && sw.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Bk, "__esModule", { value: !0 });
var f3 = c3(s3);
function d3(r, o) {
  var s = null;
  if (!r || typeof r != "string")
    return s;
  var f = (0, f3.default)(r), h = typeof o == "function";
  return f.forEach(function(y) {
    if (y.type === "declaration") {
      var S = y.property, v = y.value;
      h ? o(S, v, y) : v && (s = s || {}, s[S] = v);
    }
  }), s;
}
var Rw = Bk.default = d3;
const p3 = Rw.default || Rw, Vk = $k("end"), sx = $k("start");
function $k(r) {
  return o;
  function o(s) {
    const f = s && s.position && s.position[r] || {};
    if (typeof f.line == "number" && f.line > 0 && typeof f.column == "number" && f.column > 0)
      return {
        line: f.line,
        column: f.column,
        offset: typeof f.offset == "number" && f.offset > -1 ? f.offset : void 0
      };
  }
}
function h3(r) {
  const o = sx(r), s = Vk(r);
  if (o && s)
    return { start: o, end: s };
}
function Nh(r) {
  return !r || typeof r != "object" ? "" : "position" in r || "type" in r ? _w(r.position) : "start" in r || "end" in r ? _w(r) : "line" in r || "column" in r ? GS(r) : "";
}
function GS(r) {
  return Dw(r && r.line) + ":" + Dw(r && r.column);
}
function _w(r) {
  return GS(r && r.start) + "-" + GS(r && r.end);
}
function Dw(r) {
  return r && typeof r == "number" ? r : 1;
}
class bi extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(o, s, f) {
    super(), typeof s == "string" && (f = s, s = void 0);
    let h = "", y = {}, S = !1;
    if (s && ("line" in s && "column" in s ? y = { place: s } : "start" in s && "end" in s ? y = { place: s } : "type" in s ? y = {
      ancestors: [s],
      place: s.position
    } : y = { ...s }), typeof o == "string" ? h = o : !y.cause && o && (S = !0, h = o.message, y.cause = o), !y.ruleId && !y.source && typeof f == "string") {
      const w = f.indexOf(":");
      w === -1 ? y.ruleId = f : (y.source = f.slice(0, w), y.ruleId = f.slice(w + 1));
    }
    if (!y.place && y.ancestors && y.ancestors) {
      const w = y.ancestors[y.ancestors.length - 1];
      w && (y.place = w.position);
    }
    const v = y.place && "start" in y.place ? y.place.start : y.place;
    this.ancestors = y.ancestors || void 0, this.cause = y.cause || void 0, this.column = v ? v.column : void 0, this.fatal = void 0, this.file, this.message = h, this.line = v ? v.line : void 0, this.name = Nh(y.place) || "1:1", this.place = y.place || void 0, this.reason = this.message, this.ruleId = y.ruleId || void 0, this.source = y.source || void 0, this.stack = S && y.cause && typeof y.cause.stack == "string" ? y.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
bi.prototype.file = "";
bi.prototype.name = "";
bi.prototype.reason = "";
bi.prototype.message = "";
bi.prototype.stack = "";
bi.prototype.column = void 0;
bi.prototype.line = void 0;
bi.prototype.ancestors = void 0;
bi.prototype.cause = void 0;
bi.prototype.fatal = void 0;
bi.prototype.place = void 0;
bi.prototype.ruleId = void 0;
bi.prototype.source = void 0;
const cx = {}.hasOwnProperty, v3 = /* @__PURE__ */ new Map(), m3 = /[A-Z]/g, y3 = /-([a-z])/g, g3 = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), S3 = /* @__PURE__ */ new Set(["td", "th"]), Yk = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function x3(r, o) {
  if (!o || o.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const s = o.filePath || void 0;
  let f;
  if (o.development) {
    if (typeof o.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    f = _3(s, o.jsxDEV);
  } else {
    if (typeof o.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof o.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    f = R3(s, o.jsx, o.jsxs);
  }
  const h = {
    Fragment: o.Fragment,
    ancestors: [],
    components: o.components || {},
    create: f,
    elementAttributeNameCase: o.elementAttributeNameCase || "react",
    evaluater: o.createEvaluater ? o.createEvaluater() : void 0,
    filePath: s,
    ignoreInvalidStyle: o.ignoreInvalidStyle || !1,
    passKeys: o.passKeys !== !1,
    passNode: o.passNode || !1,
    schema: o.space === "svg" ? ux : KN,
    stylePropertyNameCase: o.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: o.tableCellAlignToStyle !== !1
  }, y = Wk(h, r, void 0);
  return y && typeof y != "string" ? y : h.create(
    r,
    h.Fragment,
    { children: y || void 0 },
    void 0
  );
}
function Wk(r, o, s) {
  if (o.type === "element")
    return b3(r, o, s);
  if (o.type === "mdxFlowExpression" || o.type === "mdxTextExpression")
    return E3(r, o);
  if (o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement")
    return w3(r, o, s);
  if (o.type === "mdxjsEsm")
    return C3(r, o);
  if (o.type === "root")
    return k3(r, o, s);
  if (o.type === "text")
    return T3(r, o);
}
function b3(r, o, s) {
  const f = r.schema;
  let h = f;
  o.tagName.toLowerCase() === "svg" && f.space === "html" && (h = ux, r.schema = h), r.ancestors.push(o);
  const y = qk(r, o.tagName, !1), S = D3(r, o);
  let v = dx(r, o);
  return g3.has(o.tagName) && (v = v.filter(function(w) {
    return typeof w == "string" ? !HN(w) : !0;
  })), Qk(r, S, y, o), fx(S, v), r.ancestors.pop(), r.schema = f, r.create(o, y, S, s);
}
function E3(r, o) {
  if (o.data && o.data.estree && r.evaluater) {
    const f = o.data.estree.body[0];
    return f.type, /** @type {Child | undefined} */
    r.evaluater.evaluateExpression(f.expression);
  }
  zh(r, o.position);
}
function C3(r, o) {
  if (o.data && o.data.estree && r.evaluater)
    return (
      /** @type {Child | undefined} */
      r.evaluater.evaluateProgram(o.data.estree)
    );
  zh(r, o.position);
}
function w3(r, o, s) {
  const f = r.schema;
  let h = f;
  o.name === "svg" && f.space === "html" && (h = ux, r.schema = h), r.ancestors.push(o);
  const y = o.name === null ? r.Fragment : qk(r, o.name, !0), S = O3(r, o), v = dx(r, o);
  return Qk(r, S, y, o), fx(S, v), r.ancestors.pop(), r.schema = f, r.create(o, y, S, s);
}
function k3(r, o, s) {
  const f = {};
  return fx(f, dx(r, o)), r.create(o, r.Fragment, f, s);
}
function T3(r, o) {
  return o.value;
}
function Qk(r, o, s, f) {
  typeof s != "string" && s !== r.Fragment && r.passNode && (o.node = f);
}
function fx(r, o) {
  if (o.length > 0) {
    const s = o.length > 1 ? o : o[0];
    s && (r.children = s);
  }
}
function R3(r, o, s) {
  return f;
  function f(h, y, S, v) {
    const E = Array.isArray(S.children) ? s : o;
    return v ? E(y, S, v) : E(y, S);
  }
}
function _3(r, o) {
  return s;
  function s(f, h, y, S) {
    const v = Array.isArray(y.children), w = sx(f);
    return o(
      h,
      y,
      S,
      v,
      {
        columnNumber: w ? w.column - 1 : void 0,
        fileName: r,
        lineNumber: w ? w.line : void 0
      },
      void 0
    );
  }
}
function D3(r, o) {
  const s = {};
  let f, h;
  for (h in o.properties)
    if (h !== "children" && cx.call(o.properties, h)) {
      const y = M3(r, h, o.properties[h]);
      if (y) {
        const [S, v] = y;
        r.tableCellAlignToStyle && S === "align" && typeof v == "string" && S3.has(o.tagName) ? f = v : s[S] = v;
      }
    }
  if (f) {
    const y = (
      /** @type {Style} */
      s.style || (s.style = {})
    );
    y[r.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = f;
  }
  return s;
}
function O3(r, o) {
  const s = {};
  for (const f of o.attributes)
    if (f.type === "mdxJsxExpressionAttribute")
      if (f.data && f.data.estree && r.evaluater) {
        const y = f.data.estree.body[0];
        y.type;
        const S = y.expression;
        S.type;
        const v = S.properties[0];
        v.type, Object.assign(
          s,
          r.evaluater.evaluateExpression(v.argument)
        );
      } else
        zh(r, o.position);
    else {
      const h = f.name;
      let y;
      if (f.value && typeof f.value == "object")
        if (f.value.data && f.value.data.estree && r.evaluater) {
          const v = f.value.data.estree.body[0];
          v.type, y = r.evaluater.evaluateExpression(v.expression);
        } else
          zh(r, o.position);
      else
        y = f.value === null ? !0 : f.value;
      s[h] = /** @type {Props[keyof Props]} */
      y;
    }
  return s;
}
function dx(r, o) {
  const s = [];
  let f = -1;
  const h = r.passKeys ? /* @__PURE__ */ new Map() : v3;
  for (; ++f < o.children.length; ) {
    const y = o.children[f];
    let S;
    if (r.passKeys) {
      const w = y.type === "element" ? y.tagName : y.type === "mdxJsxFlowElement" || y.type === "mdxJsxTextElement" ? y.name : void 0;
      if (w) {
        const E = h.get(w) || 0;
        S = w + "-" + E, h.set(w, E + 1);
      }
    }
    const v = Wk(r, y, S);
    v !== void 0 && s.push(v);
  }
  return s;
}
function M3(r, o, s) {
  const f = QN(r.schema, o);
  if (!(s == null || typeof s == "number" && Number.isNaN(s))) {
    if (Array.isArray(s) && (s = f.commaSeparated ? AN(s) : JN(s)), f.property === "style") {
      let h = typeof s == "object" ? s : N3(r, String(s));
      return r.stylePropertyNameCase === "css" && (h = L3(h)), ["style", h];
    }
    return [
      r.elementAttributeNameCase === "react" && f.space ? XN[f.property] || f.property : f.attribute,
      s
    ];
  }
}
function N3(r, o) {
  const s = {};
  try {
    p3(o, f);
  } catch (h) {
    if (!r.ignoreInvalidStyle) {
      const y = (
        /** @type {Error} */
        h
      ), S = new bi("Cannot parse `style` attribute", {
        ancestors: r.ancestors,
        cause: y,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw S.file = r.filePath || void 0, S.url = Yk + "#cannot-parse-style-attribute", S;
    }
  }
  return s;
  function f(h, y) {
    let S = h;
    S.slice(0, 2) !== "--" && (S.slice(0, 4) === "-ms-" && (S = "ms-" + S.slice(4)), S = S.replace(y3, A3)), s[S] = y;
  }
}
function qk(r, o, s) {
  let f;
  if (!s)
    f = { type: "Literal", value: o };
  else if (o.includes(".")) {
    const h = o.split(".");
    let y = -1, S;
    for (; ++y < h.length; ) {
      const v = Sw(h[y]) ? { type: "Identifier", name: h[y] } : { type: "Literal", value: h[y] };
      S = S ? {
        type: "MemberExpression",
        object: S,
        property: v,
        computed: !!(y && v.type === "Literal"),
        optional: !1
      } : v;
    }
    f = S;
  } else
    f = Sw(o) && !/^[a-z]/.test(o) ? { type: "Identifier", name: o } : { type: "Literal", value: o };
  if (f.type === "Literal") {
    const h = (
      /** @type {keyof JSX.IntrinsicElements} */
      f.value
    );
    return cx.call(r.components, h) ? r.components[h] : h;
  }
  if (r.evaluater)
    return r.evaluater.evaluateExpression(f);
  zh(r);
}
function zh(r, o) {
  const s = new bi(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: r.ancestors,
      place: o,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw s.file = r.filePath || void 0, s.url = Yk + "#cannot-handle-mdx-estrees-without-createevaluater", s;
}
function L3(r) {
  const o = {};
  let s;
  for (s in r)
    cx.call(r, s) && (o[z3(s)] = r[s]);
  return o;
}
function z3(r) {
  let o = r.replace(m3, j3);
  return o.slice(0, 3) === "ms-" && (o = "-" + o), o;
}
function A3(r, o) {
  return o.toUpperCase();
}
function j3(r) {
  return "-" + r.toLowerCase();
}
const MS = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, U3 = {};
function F3(r, o) {
  const s = o || U3, f = typeof s.includeImageAlt == "boolean" ? s.includeImageAlt : !0, h = typeof s.includeHtml == "boolean" ? s.includeHtml : !0;
  return Gk(r, f, h);
}
function Gk(r, o, s) {
  if (P3(r)) {
    if ("value" in r)
      return r.type === "html" && !s ? "" : r.value;
    if (o && "alt" in r && r.alt)
      return r.alt;
    if ("children" in r)
      return Ow(r.children, o, s);
  }
  return Array.isArray(r) ? Ow(r, o, s) : "";
}
function Ow(r, o, s) {
  const f = [];
  let h = -1;
  for (; ++h < r.length; )
    f[h] = Gk(r[h], o, s);
  return f.join("");
}
function P3(r) {
  return !!(r && typeof r == "object");
}
const Mw = document.createElement("i");
function px(r) {
  const o = "&" + r + ";";
  Mw.innerHTML = o;
  const s = Mw.textContent;
  return s.charCodeAt(s.length - 1) === 59 && r !== "semi" || s === o ? !1 : s;
}
function lu(r, o, s, f) {
  const h = r.length;
  let y = 0, S;
  if (o < 0 ? o = -o > h ? 0 : h + o : o = o > h ? h : o, s = s > 0 ? s : 0, f.length < 1e4)
    S = Array.from(f), S.unshift(o, s), r.splice(...S);
  else
    for (s && r.splice(o, s); y < f.length; )
      S = f.slice(y, y + 1e4), S.unshift(o, 0), r.splice(...S), y += 1e4, o += 1e4;
}
function Wa(r, o) {
  return r.length > 0 ? (lu(r, r.length, 0, o), r) : o;
}
const Nw = {}.hasOwnProperty;
function H3(r) {
  const o = {};
  let s = -1;
  for (; ++s < r.length; )
    I3(o, r[s]);
  return o;
}
function I3(r, o) {
  let s;
  for (s in o) {
    const h = (Nw.call(r, s) ? r[s] : void 0) || (r[s] = {}), y = o[s];
    let S;
    if (y)
      for (S in y) {
        Nw.call(h, S) || (h[S] = []);
        const v = y[S];
        B3(
          // @ts-expect-error Looks like a list.
          h[S],
          Array.isArray(v) ? v : v ? [v] : []
        );
      }
  }
}
function B3(r, o) {
  let s = -1;
  const f = [];
  for (; ++s < o.length; )
    (o[s].add === "after" ? r : f).push(o[s]);
  lu(r, 0, 0, f);
}
function Xk(r, o) {
  const s = Number.parseInt(r, o);
  return (
    // C0 except for HT, LF, FF, CR, space.
    s < 9 || s === 11 || s > 13 && s < 32 || // Control character (DEL) of C0, and C1 controls.
    s > 126 && s < 160 || // Lone high surrogates and low surrogates.
    s > 55295 && s < 57344 || // Noncharacters.
    s > 64975 && s < 65008 || /* eslint-disable no-bitwise */
    (s & 65535) === 65535 || (s & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    s > 1114111 ? "" : String.fromCodePoint(s)
  );
}
function bd(r) {
  return r.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const ho = hs(/[A-Za-z]/), Ea = hs(/[\dA-Za-z]/), V3 = hs(/[#-'*+\--9=?A-Z^-~]/);
function XS(r) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    r !== null && (r < 32 || r === 127)
  );
}
const KS = hs(/\d/), $3 = hs(/[\dA-Fa-f]/), Y3 = hs(/[!-/:-@[-`{-~]/);
function Tt(r) {
  return r !== null && r < -2;
}
function oa(r) {
  return r !== null && (r < 0 || r === 32);
}
function ln(r) {
  return r === -2 || r === -1 || r === 32;
}
const W3 = hs(new RegExp("\\p{P}|\\p{S}", "u")), Q3 = hs(/\s/);
function hs(r) {
  return o;
  function o(s) {
    return s !== null && s > -1 && r.test(String.fromCharCode(s));
  }
}
function kd(r) {
  const o = [];
  let s = -1, f = 0, h = 0;
  for (; ++s < r.length; ) {
    const y = r.charCodeAt(s);
    let S = "";
    if (y === 37 && Ea(r.charCodeAt(s + 1)) && Ea(r.charCodeAt(s + 2)))
      h = 2;
    else if (y < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(y)) || (S = String.fromCharCode(y));
    else if (y > 55295 && y < 57344) {
      const v = r.charCodeAt(s + 1);
      y < 56320 && v > 56319 && v < 57344 ? (S = String.fromCharCode(y, v), h = 1) : S = "";
    } else
      S = String.fromCharCode(y);
    S && (o.push(r.slice(f, s), encodeURIComponent(S)), f = s + h + 1, S = ""), h && (s += h, h = 0);
  }
  return o.join("") + r.slice(f);
}
function _n(r, o, s, f) {
  const h = f ? f - 1 : Number.POSITIVE_INFINITY;
  let y = 0;
  return S;
  function S(w) {
    return ln(w) ? (r.enter(s), v(w)) : o(w);
  }
  function v(w) {
    return ln(w) && y++ < h ? (r.consume(w), v) : (r.exit(s), o(w));
  }
}
const q3 = {
  tokenize: G3
};
function G3(r) {
  const o = r.attempt(
    this.parser.constructs.contentInitial,
    f,
    h
  );
  let s;
  return o;
  function f(v) {
    if (v === null) {
      r.consume(v);
      return;
    }
    return r.enter("lineEnding"), r.consume(v), r.exit("lineEnding"), _n(r, o, "linePrefix");
  }
  function h(v) {
    return r.enter("paragraph"), y(v);
  }
  function y(v) {
    const w = r.enter("chunkText", {
      contentType: "text",
      previous: s
    });
    return s && (s.next = w), s = w, S(v);
  }
  function S(v) {
    if (v === null) {
      r.exit("chunkText"), r.exit("paragraph"), r.consume(v);
      return;
    }
    return Tt(v) ? (r.consume(v), r.exit("chunkText"), y) : (r.consume(v), S);
  }
}
const X3 = {
  tokenize: K3
}, Lw = {
  tokenize: J3
};
function K3(r) {
  const o = this, s = [];
  let f = 0, h, y, S;
  return v;
  function v(te) {
    if (f < s.length) {
      const Se = s[f];
      return o.containerState = Se[1], r.attempt(
        Se[0].continuation,
        w,
        E
      )(te);
    }
    return E(te);
  }
  function w(te) {
    if (f++, o.containerState._closeFlow) {
      o.containerState._closeFlow = void 0, h && se();
      const Se = o.events.length;
      let Ce = Se, Y;
      for (; Ce--; )
        if (o.events[Ce][0] === "exit" && o.events[Ce][1].type === "chunkFlow") {
          Y = o.events[Ce][1].end;
          break;
        }
      X(f);
      let Oe = Se;
      for (; Oe < o.events.length; )
        o.events[Oe][1].end = Object.assign({}, Y), Oe++;
      return lu(
        o.events,
        Ce + 1,
        0,
        o.events.slice(Se)
      ), o.events.length = Oe, E(te);
    }
    return v(te);
  }
  function E(te) {
    if (f === s.length) {
      if (!h)
        return N(te);
      if (h.currentConstruct && h.currentConstruct.concrete)
        return F(te);
      o.interrupt = !!(h.currentConstruct && !h._gfmTableDynamicInterruptHack);
    }
    return o.containerState = {}, r.check(
      Lw,
      R,
      D
    )(te);
  }
  function R(te) {
    return h && se(), X(f), N(te);
  }
  function D(te) {
    return o.parser.lazy[o.now().line] = f !== s.length, S = o.now().offset, F(te);
  }
  function N(te) {
    return o.containerState = {}, r.attempt(
      Lw,
      M,
      F
    )(te);
  }
  function M(te) {
    return f++, s.push([o.currentConstruct, o.containerState]), N(te);
  }
  function F(te) {
    if (te === null) {
      h && se(), X(0), r.consume(te);
      return;
    }
    return h = h || o.parser.flow(o.now()), r.enter("chunkFlow", {
      contentType: "flow",
      previous: y,
      _tokenizer: h
    }), $(te);
  }
  function $(te) {
    if (te === null) {
      ce(r.exit("chunkFlow"), !0), X(0), r.consume(te);
      return;
    }
    return Tt(te) ? (r.consume(te), ce(r.exit("chunkFlow")), f = 0, o.interrupt = void 0, v) : (r.consume(te), $);
  }
  function ce(te, Se) {
    const Ce = o.sliceStream(te);
    if (Se && Ce.push(null), te.previous = y, y && (y.next = te), y = te, h.defineSkip(te.start), h.write(Ce), o.parser.lazy[te.start.line]) {
      let Y = h.events.length;
      for (; Y--; )
        if (
          // The token starts before the line ending
          h.events[Y][1].start.offset < S && // and either is not ended yet
          (!h.events[Y][1].end || // or ends after it.
          h.events[Y][1].end.offset > S)
        )
          return;
      const Oe = o.events.length;
      let ze = Oe, it, lt;
      for (; ze--; )
        if (o.events[ze][0] === "exit" && o.events[ze][1].type === "chunkFlow") {
          if (it) {
            lt = o.events[ze][1].end;
            break;
          }
          it = !0;
        }
      for (X(f), Y = Oe; Y < o.events.length; )
        o.events[Y][1].end = Object.assign({}, lt), Y++;
      lu(
        o.events,
        ze + 1,
        0,
        o.events.slice(Oe)
      ), o.events.length = Y;
    }
  }
  function X(te) {
    let Se = s.length;
    for (; Se-- > te; ) {
      const Ce = s[Se];
      o.containerState = Ce[1], Ce[0].exit.call(o, r);
    }
    s.length = te;
  }
  function se() {
    h.write([null]), y = void 0, h = void 0, o.containerState._closeFlow = void 0;
  }
}
function J3(r, o, s) {
  return _n(
    r,
    r.attempt(this.parser.constructs.document, o, s),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function zw(r) {
  if (r === null || oa(r) || Q3(r))
    return 1;
  if (W3(r))
    return 2;
}
function hx(r, o, s) {
  const f = [];
  let h = -1;
  for (; ++h < r.length; ) {
    const y = r[h].resolveAll;
    y && !f.includes(y) && (o = y(o, s), f.push(y));
  }
  return o;
}
const JS = {
  name: "attention",
  tokenize: e4,
  resolveAll: Z3
};
function Z3(r, o) {
  let s = -1, f, h, y, S, v, w, E, R;
  for (; ++s < r.length; )
    if (r[s][0] === "enter" && r[s][1].type === "attentionSequence" && r[s][1]._close) {
      for (f = s; f--; )
        if (r[f][0] === "exit" && r[f][1].type === "attentionSequence" && r[f][1]._open && // If the markers are the same:
        o.sliceSerialize(r[f][1]).charCodeAt(0) === o.sliceSerialize(r[s][1]).charCodeAt(0)) {
          if ((r[f][1]._close || r[s][1]._open) && (r[s][1].end.offset - r[s][1].start.offset) % 3 && !((r[f][1].end.offset - r[f][1].start.offset + r[s][1].end.offset - r[s][1].start.offset) % 3))
            continue;
          w = r[f][1].end.offset - r[f][1].start.offset > 1 && r[s][1].end.offset - r[s][1].start.offset > 1 ? 2 : 1;
          const D = Object.assign({}, r[f][1].end), N = Object.assign({}, r[s][1].start);
          Aw(D, -w), Aw(N, w), S = {
            type: w > 1 ? "strongSequence" : "emphasisSequence",
            start: D,
            end: Object.assign({}, r[f][1].end)
          }, v = {
            type: w > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, r[s][1].start),
            end: N
          }, y = {
            type: w > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, r[f][1].end),
            end: Object.assign({}, r[s][1].start)
          }, h = {
            type: w > 1 ? "strong" : "emphasis",
            start: Object.assign({}, S.start),
            end: Object.assign({}, v.end)
          }, r[f][1].end = Object.assign({}, S.start), r[s][1].start = Object.assign({}, v.end), E = [], r[f][1].end.offset - r[f][1].start.offset && (E = Wa(E, [["enter", r[f][1], o], ["exit", r[f][1], o]])), E = Wa(E, [["enter", h, o], ["enter", S, o], ["exit", S, o], ["enter", y, o]]), E = Wa(E, hx(o.parser.constructs.insideSpan.null, r.slice(f + 1, s), o)), E = Wa(E, [["exit", y, o], ["enter", v, o], ["exit", v, o], ["exit", h, o]]), r[s][1].end.offset - r[s][1].start.offset ? (R = 2, E = Wa(E, [["enter", r[s][1], o], ["exit", r[s][1], o]])) : R = 0, lu(r, f - 1, s - f + 3, E), s = f + E.length - R - 2;
          break;
        }
    }
  for (s = -1; ++s < r.length; )
    r[s][1].type === "attentionSequence" && (r[s][1].type = "data");
  return r;
}
function e4(r, o) {
  const s = this.parser.constructs.attentionMarkers.null, f = this.previous, h = zw(f);
  let y;
  return S;
  function S(w) {
    return y = w, r.enter("attentionSequence"), v(w);
  }
  function v(w) {
    if (w === y)
      return r.consume(w), v;
    const E = r.exit("attentionSequence"), R = zw(w), D = !R || R === 2 && h || s.includes(w), N = !h || h === 2 && R || s.includes(f);
    return E._open = !!(y === 42 ? D : D && (h || !N)), E._close = !!(y === 42 ? N : N && (R || !D)), o(w);
  }
}
function Aw(r, o) {
  r.column += o, r.offset += o, r._bufferIndex += o;
}
const t4 = {
  name: "autolink",
  tokenize: n4
};
function n4(r, o, s) {
  let f = 0;
  return h;
  function h(M) {
    return r.enter("autolink"), r.enter("autolinkMarker"), r.consume(M), r.exit("autolinkMarker"), r.enter("autolinkProtocol"), y;
  }
  function y(M) {
    return ho(M) ? (r.consume(M), S) : M === 64 ? s(M) : E(M);
  }
  function S(M) {
    return M === 43 || M === 45 || M === 46 || Ea(M) ? (f = 1, v(M)) : E(M);
  }
  function v(M) {
    return M === 58 ? (r.consume(M), f = 0, w) : (M === 43 || M === 45 || M === 46 || Ea(M)) && f++ < 32 ? (r.consume(M), v) : (f = 0, E(M));
  }
  function w(M) {
    return M === 62 ? (r.exit("autolinkProtocol"), r.enter("autolinkMarker"), r.consume(M), r.exit("autolinkMarker"), r.exit("autolink"), o) : M === null || M === 32 || M === 60 || XS(M) ? s(M) : (r.consume(M), w);
  }
  function E(M) {
    return M === 64 ? (r.consume(M), R) : V3(M) ? (r.consume(M), E) : s(M);
  }
  function R(M) {
    return Ea(M) ? D(M) : s(M);
  }
  function D(M) {
    return M === 46 ? (r.consume(M), f = 0, R) : M === 62 ? (r.exit("autolinkProtocol").type = "autolinkEmail", r.enter("autolinkMarker"), r.consume(M), r.exit("autolinkMarker"), r.exit("autolink"), o) : N(M);
  }
  function N(M) {
    if ((M === 45 || Ea(M)) && f++ < 63) {
      const F = M === 45 ? N : D;
      return r.consume(M), F;
    }
    return s(M);
  }
}
const Jy = {
  tokenize: r4,
  partial: !0
};
function r4(r, o, s) {
  return f;
  function f(y) {
    return ln(y) ? _n(r, h, "linePrefix")(y) : h(y);
  }
  function h(y) {
    return y === null || Tt(y) ? o(y) : s(y);
  }
}
const Kk = {
  name: "blockQuote",
  tokenize: i4,
  continuation: {
    tokenize: a4
  },
  exit: l4
};
function i4(r, o, s) {
  const f = this;
  return h;
  function h(S) {
    if (S === 62) {
      const v = f.containerState;
      return v.open || (r.enter("blockQuote", {
        _container: !0
      }), v.open = !0), r.enter("blockQuotePrefix"), r.enter("blockQuoteMarker"), r.consume(S), r.exit("blockQuoteMarker"), y;
    }
    return s(S);
  }
  function y(S) {
    return ln(S) ? (r.enter("blockQuotePrefixWhitespace"), r.consume(S), r.exit("blockQuotePrefixWhitespace"), r.exit("blockQuotePrefix"), o) : (r.exit("blockQuotePrefix"), o(S));
  }
}
function a4(r, o, s) {
  const f = this;
  return h;
  function h(S) {
    return ln(S) ? _n(r, y, "linePrefix", f.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(S) : y(S);
  }
  function y(S) {
    return r.attempt(Kk, o, s)(S);
  }
}
function l4(r) {
  r.exit("blockQuote");
}
const Jk = {
  name: "characterEscape",
  tokenize: o4
};
function o4(r, o, s) {
  return f;
  function f(y) {
    return r.enter("characterEscape"), r.enter("escapeMarker"), r.consume(y), r.exit("escapeMarker"), h;
  }
  function h(y) {
    return Y3(y) ? (r.enter("characterEscapeValue"), r.consume(y), r.exit("characterEscapeValue"), r.exit("characterEscape"), o) : s(y);
  }
}
const Zk = {
  name: "characterReference",
  tokenize: u4
};
function u4(r, o, s) {
  const f = this;
  let h = 0, y, S;
  return v;
  function v(D) {
    return r.enter("characterReference"), r.enter("characterReferenceMarker"), r.consume(D), r.exit("characterReferenceMarker"), w;
  }
  function w(D) {
    return D === 35 ? (r.enter("characterReferenceMarkerNumeric"), r.consume(D), r.exit("characterReferenceMarkerNumeric"), E) : (r.enter("characterReferenceValue"), y = 31, S = Ea, R(D));
  }
  function E(D) {
    return D === 88 || D === 120 ? (r.enter("characterReferenceMarkerHexadecimal"), r.consume(D), r.exit("characterReferenceMarkerHexadecimal"), r.enter("characterReferenceValue"), y = 6, S = $3, R) : (r.enter("characterReferenceValue"), y = 7, S = KS, R(D));
  }
  function R(D) {
    if (D === 59 && h) {
      const N = r.exit("characterReferenceValue");
      return S === Ea && !px(f.sliceSerialize(N)) ? s(D) : (r.enter("characterReferenceMarker"), r.consume(D), r.exit("characterReferenceMarker"), r.exit("characterReference"), o);
    }
    return S(D) && h++ < y ? (r.consume(D), R) : s(D);
  }
}
const jw = {
  tokenize: c4,
  partial: !0
}, Uw = {
  name: "codeFenced",
  tokenize: s4,
  concrete: !0
};
function s4(r, o, s) {
  const f = this, h = {
    tokenize: Ce,
    partial: !0
  };
  let y = 0, S = 0, v;
  return w;
  function w(Y) {
    return E(Y);
  }
  function E(Y) {
    const Oe = f.events[f.events.length - 1];
    return y = Oe && Oe[1].type === "linePrefix" ? Oe[2].sliceSerialize(Oe[1], !0).length : 0, v = Y, r.enter("codeFenced"), r.enter("codeFencedFence"), r.enter("codeFencedFenceSequence"), R(Y);
  }
  function R(Y) {
    return Y === v ? (S++, r.consume(Y), R) : S < 3 ? s(Y) : (r.exit("codeFencedFenceSequence"), ln(Y) ? _n(r, D, "whitespace")(Y) : D(Y));
  }
  function D(Y) {
    return Y === null || Tt(Y) ? (r.exit("codeFencedFence"), f.interrupt ? o(Y) : r.check(jw, $, Se)(Y)) : (r.enter("codeFencedFenceInfo"), r.enter("chunkString", {
      contentType: "string"
    }), N(Y));
  }
  function N(Y) {
    return Y === null || Tt(Y) ? (r.exit("chunkString"), r.exit("codeFencedFenceInfo"), D(Y)) : ln(Y) ? (r.exit("chunkString"), r.exit("codeFencedFenceInfo"), _n(r, M, "whitespace")(Y)) : Y === 96 && Y === v ? s(Y) : (r.consume(Y), N);
  }
  function M(Y) {
    return Y === null || Tt(Y) ? D(Y) : (r.enter("codeFencedFenceMeta"), r.enter("chunkString", {
      contentType: "string"
    }), F(Y));
  }
  function F(Y) {
    return Y === null || Tt(Y) ? (r.exit("chunkString"), r.exit("codeFencedFenceMeta"), D(Y)) : Y === 96 && Y === v ? s(Y) : (r.consume(Y), F);
  }
  function $(Y) {
    return r.attempt(h, Se, ce)(Y);
  }
  function ce(Y) {
    return r.enter("lineEnding"), r.consume(Y), r.exit("lineEnding"), X;
  }
  function X(Y) {
    return y > 0 && ln(Y) ? _n(r, se, "linePrefix", y + 1)(Y) : se(Y);
  }
  function se(Y) {
    return Y === null || Tt(Y) ? r.check(jw, $, Se)(Y) : (r.enter("codeFlowValue"), te(Y));
  }
  function te(Y) {
    return Y === null || Tt(Y) ? (r.exit("codeFlowValue"), se(Y)) : (r.consume(Y), te);
  }
  function Se(Y) {
    return r.exit("codeFenced"), o(Y);
  }
  function Ce(Y, Oe, ze) {
    let it = 0;
    return lt;
    function lt(ge) {
      return Y.enter("lineEnding"), Y.consume(ge), Y.exit("lineEnding"), he;
    }
    function he(ge) {
      return Y.enter("codeFencedFence"), ln(ge) ? _n(Y, ne, "linePrefix", f.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ge) : ne(ge);
    }
    function ne(ge) {
      return ge === v ? (Y.enter("codeFencedFenceSequence"), we(ge)) : ze(ge);
    }
    function we(ge) {
      return ge === v ? (it++, Y.consume(ge), we) : it >= S ? (Y.exit("codeFencedFenceSequence"), ln(ge) ? _n(Y, de, "whitespace")(ge) : de(ge)) : ze(ge);
    }
    function de(ge) {
      return ge === null || Tt(ge) ? (Y.exit("codeFencedFence"), Oe(ge)) : ze(ge);
    }
  }
}
function c4(r, o, s) {
  const f = this;
  return h;
  function h(S) {
    return S === null ? s(S) : (r.enter("lineEnding"), r.consume(S), r.exit("lineEnding"), y);
  }
  function y(S) {
    return f.parser.lazy[f.now().line] ? s(S) : o(S);
  }
}
const NS = {
  name: "codeIndented",
  tokenize: d4
}, f4 = {
  tokenize: p4,
  partial: !0
};
function d4(r, o, s) {
  const f = this;
  return h;
  function h(E) {
    return r.enter("codeIndented"), _n(r, y, "linePrefix", 5)(E);
  }
  function y(E) {
    const R = f.events[f.events.length - 1];
    return R && R[1].type === "linePrefix" && R[2].sliceSerialize(R[1], !0).length >= 4 ? S(E) : s(E);
  }
  function S(E) {
    return E === null ? w(E) : Tt(E) ? r.attempt(f4, S, w)(E) : (r.enter("codeFlowValue"), v(E));
  }
  function v(E) {
    return E === null || Tt(E) ? (r.exit("codeFlowValue"), S(E)) : (r.consume(E), v);
  }
  function w(E) {
    return r.exit("codeIndented"), o(E);
  }
}
function p4(r, o, s) {
  const f = this;
  return h;
  function h(S) {
    return f.parser.lazy[f.now().line] ? s(S) : Tt(S) ? (r.enter("lineEnding"), r.consume(S), r.exit("lineEnding"), h) : _n(r, y, "linePrefix", 5)(S);
  }
  function y(S) {
    const v = f.events[f.events.length - 1];
    return v && v[1].type === "linePrefix" && v[2].sliceSerialize(v[1], !0).length >= 4 ? o(S) : Tt(S) ? h(S) : s(S);
  }
}
const h4 = {
  name: "codeText",
  tokenize: y4,
  resolve: v4,
  previous: m4
};
function v4(r) {
  let o = r.length - 4, s = 3, f, h;
  if ((r[s][1].type === "lineEnding" || r[s][1].type === "space") && (r[o][1].type === "lineEnding" || r[o][1].type === "space")) {
    for (f = s; ++f < o; )
      if (r[f][1].type === "codeTextData") {
        r[s][1].type = "codeTextPadding", r[o][1].type = "codeTextPadding", s += 2, o -= 2;
        break;
      }
  }
  for (f = s - 1, o++; ++f <= o; )
    h === void 0 ? f !== o && r[f][1].type !== "lineEnding" && (h = f) : (f === o || r[f][1].type === "lineEnding") && (r[h][1].type = "codeTextData", f !== h + 2 && (r[h][1].end = r[f - 1][1].end, r.splice(h + 2, f - h - 2), o -= f - h - 2, f = h + 2), h = void 0);
  return r;
}
function m4(r) {
  return r !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function y4(r, o, s) {
  let f = 0, h, y;
  return S;
  function S(D) {
    return r.enter("codeText"), r.enter("codeTextSequence"), v(D);
  }
  function v(D) {
    return D === 96 ? (r.consume(D), f++, v) : (r.exit("codeTextSequence"), w(D));
  }
  function w(D) {
    return D === null ? s(D) : D === 32 ? (r.enter("space"), r.consume(D), r.exit("space"), w) : D === 96 ? (y = r.enter("codeTextSequence"), h = 0, R(D)) : Tt(D) ? (r.enter("lineEnding"), r.consume(D), r.exit("lineEnding"), w) : (r.enter("codeTextData"), E(D));
  }
  function E(D) {
    return D === null || D === 32 || D === 96 || Tt(D) ? (r.exit("codeTextData"), w(D)) : (r.consume(D), E);
  }
  function R(D) {
    return D === 96 ? (r.consume(D), h++, R) : h === f ? (r.exit("codeTextSequence"), r.exit("codeText"), o(D)) : (y.type = "codeTextData", E(D));
  }
}
class g4 {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(o) {
    this.left = o ? [...o] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(o) {
    if (o < 0 || o >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + o + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return o < this.left.length ? this.left[o] : this.right[this.right.length - o + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(o, s) {
    const f = s ?? Number.POSITIVE_INFINITY;
    return f < this.left.length ? this.left.slice(o, f) : o > this.left.length ? this.right.slice(this.right.length - f + this.left.length, this.right.length - o + this.left.length).reverse() : this.left.slice(o).concat(this.right.slice(this.right.length - f + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(o, s, f) {
    const h = s || 0;
    this.setCursor(Math.trunc(o));
    const y = this.right.splice(this.right.length - h, Number.POSITIVE_INFINITY);
    return f && Th(this.left, f), y.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(o) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(o);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(o) {
    this.setCursor(Number.POSITIVE_INFINITY), Th(this.left, o);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(o) {
    this.setCursor(0), this.right.push(o);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(o) {
    this.setCursor(0), Th(this.right, o.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(o) {
    if (!(o === this.left.length || o > this.left.length && this.right.length === 0 || o < 0 && this.left.length === 0))
      if (o < this.left.length) {
        const s = this.left.splice(o, Number.POSITIVE_INFINITY);
        Th(this.right, s.reverse());
      } else {
        const s = this.right.splice(this.left.length + this.right.length - o, Number.POSITIVE_INFINITY);
        Th(this.left, s.reverse());
      }
  }
}
function Th(r, o) {
  let s = 0;
  if (o.length < 1e4)
    r.push(...o);
  else
    for (; s < o.length; )
      r.push(...o.slice(s, s + 1e4)), s += 1e4;
}
function eT(r) {
  const o = {};
  let s = -1, f, h, y, S, v, w, E;
  const R = new g4(r);
  for (; ++s < R.length; ) {
    for (; s in o; )
      s = o[s];
    if (f = R.get(s), s && f[1].type === "chunkFlow" && R.get(s - 1)[1].type === "listItemPrefix" && (w = f[1]._tokenizer.events, y = 0, y < w.length && w[y][1].type === "lineEndingBlank" && (y += 2), y < w.length && w[y][1].type === "content"))
      for (; ++y < w.length && w[y][1].type !== "content"; )
        w[y][1].type === "chunkText" && (w[y][1]._isInFirstContentOfListItem = !0, y++);
    if (f[0] === "enter")
      f[1].contentType && (Object.assign(o, S4(R, s)), s = o[s], E = !0);
    else if (f[1]._container) {
      for (y = s, h = void 0; y-- && (S = R.get(y), S[1].type === "lineEnding" || S[1].type === "lineEndingBlank"); )
        S[0] === "enter" && (h && (R.get(h)[1].type = "lineEndingBlank"), S[1].type = "lineEnding", h = y);
      h && (f[1].end = Object.assign({}, R.get(h)[1].start), v = R.slice(h, s), v.unshift(f), R.splice(h, s - h + 1, v));
    }
  }
  return lu(r, 0, Number.POSITIVE_INFINITY, R.slice(0)), !E;
}
function S4(r, o) {
  const s = r.get(o)[1], f = r.get(o)[2];
  let h = o - 1;
  const y = [], S = s._tokenizer || f.parser[s.contentType](s.start), v = S.events, w = [], E = {};
  let R, D, N = -1, M = s, F = 0, $ = 0;
  const ce = [$];
  for (; M; ) {
    for (; r.get(++h)[1] !== M; )
      ;
    y.push(h), M._tokenizer || (R = f.sliceStream(M), M.next || R.push(null), D && S.defineSkip(M.start), M._isInFirstContentOfListItem && (S._gfmTasklistFirstContentOfListItem = !0), S.write(R), M._isInFirstContentOfListItem && (S._gfmTasklistFirstContentOfListItem = void 0)), D = M, M = M.next;
  }
  for (M = s; ++N < v.length; )
    // Find a void token that includes a break.
    v[N][0] === "exit" && v[N - 1][0] === "enter" && v[N][1].type === v[N - 1][1].type && v[N][1].start.line !== v[N][1].end.line && ($ = N + 1, ce.push($), M._tokenizer = void 0, M.previous = void 0, M = M.next);
  for (S.events = [], M ? (M._tokenizer = void 0, M.previous = void 0) : ce.pop(), N = ce.length; N--; ) {
    const X = v.slice(ce[N], ce[N + 1]), se = y.pop();
    w.push([se, se + X.length - 1]), r.splice(se, 2, X);
  }
  for (w.reverse(), N = -1; ++N < w.length; )
    E[F + w[N][0]] = F + w[N][1], F += w[N][1] - w[N][0] - 1;
  return E;
}
const x4 = {
  tokenize: C4,
  resolve: E4
}, b4 = {
  tokenize: w4,
  partial: !0
};
function E4(r) {
  return eT(r), r;
}
function C4(r, o) {
  let s;
  return f;
  function f(v) {
    return r.enter("content"), s = r.enter("chunkContent", {
      contentType: "content"
    }), h(v);
  }
  function h(v) {
    return v === null ? y(v) : Tt(v) ? r.check(b4, S, y)(v) : (r.consume(v), h);
  }
  function y(v) {
    return r.exit("chunkContent"), r.exit("content"), o(v);
  }
  function S(v) {
    return r.consume(v), r.exit("chunkContent"), s.next = r.enter("chunkContent", {
      contentType: "content",
      previous: s
    }), s = s.next, h;
  }
}
function w4(r, o, s) {
  const f = this;
  return h;
  function h(S) {
    return r.exit("chunkContent"), r.enter("lineEnding"), r.consume(S), r.exit("lineEnding"), _n(r, y, "linePrefix");
  }
  function y(S) {
    if (S === null || Tt(S))
      return s(S);
    const v = f.events[f.events.length - 1];
    return !f.parser.constructs.disable.null.includes("codeIndented") && v && v[1].type === "linePrefix" && v[2].sliceSerialize(v[1], !0).length >= 4 ? o(S) : r.interrupt(f.parser.constructs.flow, s, o)(S);
  }
}
function tT(r, o, s, f, h, y, S, v, w) {
  const E = w || Number.POSITIVE_INFINITY;
  let R = 0;
  return D;
  function D(X) {
    return X === 60 ? (r.enter(f), r.enter(h), r.enter(y), r.consume(X), r.exit(y), N) : X === null || X === 32 || X === 41 || XS(X) ? s(X) : (r.enter(f), r.enter(S), r.enter(v), r.enter("chunkString", {
      contentType: "string"
    }), $(X));
  }
  function N(X) {
    return X === 62 ? (r.enter(y), r.consume(X), r.exit(y), r.exit(h), r.exit(f), o) : (r.enter(v), r.enter("chunkString", {
      contentType: "string"
    }), M(X));
  }
  function M(X) {
    return X === 62 ? (r.exit("chunkString"), r.exit(v), N(X)) : X === null || X === 60 || Tt(X) ? s(X) : (r.consume(X), X === 92 ? F : M);
  }
  function F(X) {
    return X === 60 || X === 62 || X === 92 ? (r.consume(X), M) : M(X);
  }
  function $(X) {
    return !R && (X === null || X === 41 || oa(X)) ? (r.exit("chunkString"), r.exit(v), r.exit(S), r.exit(f), o(X)) : R < E && X === 40 ? (r.consume(X), R++, $) : X === 41 ? (r.consume(X), R--, $) : X === null || X === 32 || X === 40 || XS(X) ? s(X) : (r.consume(X), X === 92 ? ce : $);
  }
  function ce(X) {
    return X === 40 || X === 41 || X === 92 ? (r.consume(X), $) : $(X);
  }
}
function nT(r, o, s, f, h, y) {
  const S = this;
  let v = 0, w;
  return E;
  function E(M) {
    return r.enter(f), r.enter(h), r.consume(M), r.exit(h), r.enter(y), R;
  }
  function R(M) {
    return v > 999 || M === null || M === 91 || M === 93 && !w || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    M === 94 && !v && "_hiddenFootnoteSupport" in S.parser.constructs ? s(M) : M === 93 ? (r.exit(y), r.enter(h), r.consume(M), r.exit(h), r.exit(f), o) : Tt(M) ? (r.enter("lineEnding"), r.consume(M), r.exit("lineEnding"), R) : (r.enter("chunkString", {
      contentType: "string"
    }), D(M));
  }
  function D(M) {
    return M === null || M === 91 || M === 93 || Tt(M) || v++ > 999 ? (r.exit("chunkString"), R(M)) : (r.consume(M), w || (w = !ln(M)), M === 92 ? N : D);
  }
  function N(M) {
    return M === 91 || M === 92 || M === 93 ? (r.consume(M), v++, D) : D(M);
  }
}
function rT(r, o, s, f, h, y) {
  let S;
  return v;
  function v(N) {
    return N === 34 || N === 39 || N === 40 ? (r.enter(f), r.enter(h), r.consume(N), r.exit(h), S = N === 40 ? 41 : N, w) : s(N);
  }
  function w(N) {
    return N === S ? (r.enter(h), r.consume(N), r.exit(h), r.exit(f), o) : (r.enter(y), E(N));
  }
  function E(N) {
    return N === S ? (r.exit(y), w(S)) : N === null ? s(N) : Tt(N) ? (r.enter("lineEnding"), r.consume(N), r.exit("lineEnding"), _n(r, E, "linePrefix")) : (r.enter("chunkString", {
      contentType: "string"
    }), R(N));
  }
  function R(N) {
    return N === S || N === null || Tt(N) ? (r.exit("chunkString"), E(N)) : (r.consume(N), N === 92 ? D : R);
  }
  function D(N) {
    return N === S || N === 92 ? (r.consume(N), R) : R(N);
  }
}
function Lh(r, o) {
  let s;
  return f;
  function f(h) {
    return Tt(h) ? (r.enter("lineEnding"), r.consume(h), r.exit("lineEnding"), s = !0, f) : ln(h) ? _n(
      r,
      f,
      s ? "linePrefix" : "lineSuffix"
    )(h) : o(h);
  }
}
const k4 = {
  name: "definition",
  tokenize: R4
}, T4 = {
  tokenize: _4,
  partial: !0
};
function R4(r, o, s) {
  const f = this;
  let h;
  return y;
  function y(M) {
    return r.enter("definition"), S(M);
  }
  function S(M) {
    return nT.call(
      f,
      r,
      v,
      // Note: we dont need to reset the way `markdown-rs` does.
      s,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(M);
  }
  function v(M) {
    return h = bd(f.sliceSerialize(f.events[f.events.length - 1][1]).slice(1, -1)), M === 58 ? (r.enter("definitionMarker"), r.consume(M), r.exit("definitionMarker"), w) : s(M);
  }
  function w(M) {
    return oa(M) ? Lh(r, E)(M) : E(M);
  }
  function E(M) {
    return tT(
      r,
      R,
      // Note: we dont need to reset the way `markdown-rs` does.
      s,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(M);
  }
  function R(M) {
    return r.attempt(T4, D, D)(M);
  }
  function D(M) {
    return ln(M) ? _n(r, N, "whitespace")(M) : N(M);
  }
  function N(M) {
    return M === null || Tt(M) ? (r.exit("definition"), f.parser.defined.push(h), o(M)) : s(M);
  }
}
function _4(r, o, s) {
  return f;
  function f(v) {
    return oa(v) ? Lh(r, h)(v) : s(v);
  }
  function h(v) {
    return rT(r, y, s, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(v);
  }
  function y(v) {
    return ln(v) ? _n(r, S, "whitespace")(v) : S(v);
  }
  function S(v) {
    return v === null || Tt(v) ? o(v) : s(v);
  }
}
const D4 = {
  name: "hardBreakEscape",
  tokenize: O4
};
function O4(r, o, s) {
  return f;
  function f(y) {
    return r.enter("hardBreakEscape"), r.consume(y), h;
  }
  function h(y) {
    return Tt(y) ? (r.exit("hardBreakEscape"), o(y)) : s(y);
  }
}
const M4 = {
  name: "headingAtx",
  tokenize: L4,
  resolve: N4
};
function N4(r, o) {
  let s = r.length - 2, f = 3, h, y;
  return r[f][1].type === "whitespace" && (f += 2), s - 2 > f && r[s][1].type === "whitespace" && (s -= 2), r[s][1].type === "atxHeadingSequence" && (f === s - 1 || s - 4 > f && r[s - 2][1].type === "whitespace") && (s -= f + 1 === s ? 2 : 4), s > f && (h = {
    type: "atxHeadingText",
    start: r[f][1].start,
    end: r[s][1].end
  }, y = {
    type: "chunkText",
    start: r[f][1].start,
    end: r[s][1].end,
    contentType: "text"
  }, lu(r, f, s - f + 1, [["enter", h, o], ["enter", y, o], ["exit", y, o], ["exit", h, o]])), r;
}
function L4(r, o, s) {
  let f = 0;
  return h;
  function h(R) {
    return r.enter("atxHeading"), y(R);
  }
  function y(R) {
    return r.enter("atxHeadingSequence"), S(R);
  }
  function S(R) {
    return R === 35 && f++ < 6 ? (r.consume(R), S) : R === null || oa(R) ? (r.exit("atxHeadingSequence"), v(R)) : s(R);
  }
  function v(R) {
    return R === 35 ? (r.enter("atxHeadingSequence"), w(R)) : R === null || Tt(R) ? (r.exit("atxHeading"), o(R)) : ln(R) ? _n(r, v, "whitespace")(R) : (r.enter("atxHeadingText"), E(R));
  }
  function w(R) {
    return R === 35 ? (r.consume(R), w) : (r.exit("atxHeadingSequence"), v(R));
  }
  function E(R) {
    return R === null || R === 35 || oa(R) ? (r.exit("atxHeadingText"), v(R)) : (r.consume(R), E);
  }
}
const z4 = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Fw = ["pre", "script", "style", "textarea"], A4 = {
  name: "htmlFlow",
  tokenize: P4,
  resolveTo: F4,
  concrete: !0
}, j4 = {
  tokenize: I4,
  partial: !0
}, U4 = {
  tokenize: H4,
  partial: !0
};
function F4(r) {
  let o = r.length;
  for (; o-- && !(r[o][0] === "enter" && r[o][1].type === "htmlFlow"); )
    ;
  return o > 1 && r[o - 2][1].type === "linePrefix" && (r[o][1].start = r[o - 2][1].start, r[o + 1][1].start = r[o - 2][1].start, r.splice(o - 2, 2)), r;
}
function P4(r, o, s) {
  const f = this;
  let h, y, S, v, w;
  return E;
  function E(A) {
    return R(A);
  }
  function R(A) {
    return r.enter("htmlFlow"), r.enter("htmlFlowData"), r.consume(A), D;
  }
  function D(A) {
    return A === 33 ? (r.consume(A), N) : A === 47 ? (r.consume(A), y = !0, $) : A === 63 ? (r.consume(A), h = 3, f.interrupt ? o : T) : ho(A) ? (r.consume(A), S = String.fromCharCode(A), ce) : s(A);
  }
  function N(A) {
    return A === 45 ? (r.consume(A), h = 2, M) : A === 91 ? (r.consume(A), h = 5, v = 0, F) : ho(A) ? (r.consume(A), h = 4, f.interrupt ? o : T) : s(A);
  }
  function M(A) {
    return A === 45 ? (r.consume(A), f.interrupt ? o : T) : s(A);
  }
  function F(A) {
    const Ke = "CDATA[";
    return A === Ke.charCodeAt(v++) ? (r.consume(A), v === Ke.length ? f.interrupt ? o : ne : F) : s(A);
  }
  function $(A) {
    return ho(A) ? (r.consume(A), S = String.fromCharCode(A), ce) : s(A);
  }
  function ce(A) {
    if (A === null || A === 47 || A === 62 || oa(A)) {
      const Ke = A === 47, bt = S.toLowerCase();
      return !Ke && !y && Fw.includes(bt) ? (h = 1, f.interrupt ? o(A) : ne(A)) : z4.includes(S.toLowerCase()) ? (h = 6, Ke ? (r.consume(A), X) : f.interrupt ? o(A) : ne(A)) : (h = 7, f.interrupt && !f.parser.lazy[f.now().line] ? s(A) : y ? se(A) : te(A));
    }
    return A === 45 || Ea(A) ? (r.consume(A), S += String.fromCharCode(A), ce) : s(A);
  }
  function X(A) {
    return A === 62 ? (r.consume(A), f.interrupt ? o : ne) : s(A);
  }
  function se(A) {
    return ln(A) ? (r.consume(A), se) : lt(A);
  }
  function te(A) {
    return A === 47 ? (r.consume(A), lt) : A === 58 || A === 95 || ho(A) ? (r.consume(A), Se) : ln(A) ? (r.consume(A), te) : lt(A);
  }
  function Se(A) {
    return A === 45 || A === 46 || A === 58 || A === 95 || Ea(A) ? (r.consume(A), Se) : Ce(A);
  }
  function Ce(A) {
    return A === 61 ? (r.consume(A), Y) : ln(A) ? (r.consume(A), Ce) : te(A);
  }
  function Y(A) {
    return A === null || A === 60 || A === 61 || A === 62 || A === 96 ? s(A) : A === 34 || A === 39 ? (r.consume(A), w = A, Oe) : ln(A) ? (r.consume(A), Y) : ze(A);
  }
  function Oe(A) {
    return A === w ? (r.consume(A), w = null, it) : A === null || Tt(A) ? s(A) : (r.consume(A), Oe);
  }
  function ze(A) {
    return A === null || A === 34 || A === 39 || A === 47 || A === 60 || A === 61 || A === 62 || A === 96 || oa(A) ? Ce(A) : (r.consume(A), ze);
  }
  function it(A) {
    return A === 47 || A === 62 || ln(A) ? te(A) : s(A);
  }
  function lt(A) {
    return A === 62 ? (r.consume(A), he) : s(A);
  }
  function he(A) {
    return A === null || Tt(A) ? ne(A) : ln(A) ? (r.consume(A), he) : s(A);
  }
  function ne(A) {
    return A === 45 && h === 2 ? (r.consume(A), Qe) : A === 60 && h === 1 ? (r.consume(A), Fe) : A === 62 && h === 4 ? (r.consume(A), ue) : A === 63 && h === 3 ? (r.consume(A), T) : A === 93 && h === 5 ? (r.consume(A), _e) : Tt(A) && (h === 6 || h === 7) ? (r.exit("htmlFlowData"), r.check(j4, Ae, we)(A)) : A === null || Tt(A) ? (r.exit("htmlFlowData"), we(A)) : (r.consume(A), ne);
  }
  function we(A) {
    return r.check(U4, de, Ae)(A);
  }
  function de(A) {
    return r.enter("lineEnding"), r.consume(A), r.exit("lineEnding"), ge;
  }
  function ge(A) {
    return A === null || Tt(A) ? we(A) : (r.enter("htmlFlowData"), ne(A));
  }
  function Qe(A) {
    return A === 45 ? (r.consume(A), T) : ne(A);
  }
  function Fe(A) {
    return A === 47 ? (r.consume(A), S = "", ae) : ne(A);
  }
  function ae(A) {
    if (A === 62) {
      const Ke = S.toLowerCase();
      return Fw.includes(Ke) ? (r.consume(A), ue) : ne(A);
    }
    return ho(A) && S.length < 8 ? (r.consume(A), S += String.fromCharCode(A), ae) : ne(A);
  }
  function _e(A) {
    return A === 93 ? (r.consume(A), T) : ne(A);
  }
  function T(A) {
    return A === 62 ? (r.consume(A), ue) : A === 45 && h === 2 ? (r.consume(A), T) : ne(A);
  }
  function ue(A) {
    return A === null || Tt(A) ? (r.exit("htmlFlowData"), Ae(A)) : (r.consume(A), ue);
  }
  function Ae(A) {
    return r.exit("htmlFlow"), o(A);
  }
}
function H4(r, o, s) {
  const f = this;
  return h;
  function h(S) {
    return Tt(S) ? (r.enter("lineEnding"), r.consume(S), r.exit("lineEnding"), y) : s(S);
  }
  function y(S) {
    return f.parser.lazy[f.now().line] ? s(S) : o(S);
  }
}
function I4(r, o, s) {
  return f;
  function f(h) {
    return r.enter("lineEnding"), r.consume(h), r.exit("lineEnding"), r.attempt(Jy, o, s);
  }
}
const B4 = {
  name: "htmlText",
  tokenize: V4
};
function V4(r, o, s) {
  const f = this;
  let h, y, S;
  return v;
  function v(T) {
    return r.enter("htmlText"), r.enter("htmlTextData"), r.consume(T), w;
  }
  function w(T) {
    return T === 33 ? (r.consume(T), E) : T === 47 ? (r.consume(T), Ce) : T === 63 ? (r.consume(T), te) : ho(T) ? (r.consume(T), ze) : s(T);
  }
  function E(T) {
    return T === 45 ? (r.consume(T), R) : T === 91 ? (r.consume(T), y = 0, F) : ho(T) ? (r.consume(T), se) : s(T);
  }
  function R(T) {
    return T === 45 ? (r.consume(T), M) : s(T);
  }
  function D(T) {
    return T === null ? s(T) : T === 45 ? (r.consume(T), N) : Tt(T) ? (S = D, Fe(T)) : (r.consume(T), D);
  }
  function N(T) {
    return T === 45 ? (r.consume(T), M) : D(T);
  }
  function M(T) {
    return T === 62 ? Qe(T) : T === 45 ? N(T) : D(T);
  }
  function F(T) {
    const ue = "CDATA[";
    return T === ue.charCodeAt(y++) ? (r.consume(T), y === ue.length ? $ : F) : s(T);
  }
  function $(T) {
    return T === null ? s(T) : T === 93 ? (r.consume(T), ce) : Tt(T) ? (S = $, Fe(T)) : (r.consume(T), $);
  }
  function ce(T) {
    return T === 93 ? (r.consume(T), X) : $(T);
  }
  function X(T) {
    return T === 62 ? Qe(T) : T === 93 ? (r.consume(T), X) : $(T);
  }
  function se(T) {
    return T === null || T === 62 ? Qe(T) : Tt(T) ? (S = se, Fe(T)) : (r.consume(T), se);
  }
  function te(T) {
    return T === null ? s(T) : T === 63 ? (r.consume(T), Se) : Tt(T) ? (S = te, Fe(T)) : (r.consume(T), te);
  }
  function Se(T) {
    return T === 62 ? Qe(T) : te(T);
  }
  function Ce(T) {
    return ho(T) ? (r.consume(T), Y) : s(T);
  }
  function Y(T) {
    return T === 45 || Ea(T) ? (r.consume(T), Y) : Oe(T);
  }
  function Oe(T) {
    return Tt(T) ? (S = Oe, Fe(T)) : ln(T) ? (r.consume(T), Oe) : Qe(T);
  }
  function ze(T) {
    return T === 45 || Ea(T) ? (r.consume(T), ze) : T === 47 || T === 62 || oa(T) ? it(T) : s(T);
  }
  function it(T) {
    return T === 47 ? (r.consume(T), Qe) : T === 58 || T === 95 || ho(T) ? (r.consume(T), lt) : Tt(T) ? (S = it, Fe(T)) : ln(T) ? (r.consume(T), it) : Qe(T);
  }
  function lt(T) {
    return T === 45 || T === 46 || T === 58 || T === 95 || Ea(T) ? (r.consume(T), lt) : he(T);
  }
  function he(T) {
    return T === 61 ? (r.consume(T), ne) : Tt(T) ? (S = he, Fe(T)) : ln(T) ? (r.consume(T), he) : it(T);
  }
  function ne(T) {
    return T === null || T === 60 || T === 61 || T === 62 || T === 96 ? s(T) : T === 34 || T === 39 ? (r.consume(T), h = T, we) : Tt(T) ? (S = ne, Fe(T)) : ln(T) ? (r.consume(T), ne) : (r.consume(T), de);
  }
  function we(T) {
    return T === h ? (r.consume(T), h = void 0, ge) : T === null ? s(T) : Tt(T) ? (S = we, Fe(T)) : (r.consume(T), we);
  }
  function de(T) {
    return T === null || T === 34 || T === 39 || T === 60 || T === 61 || T === 96 ? s(T) : T === 47 || T === 62 || oa(T) ? it(T) : (r.consume(T), de);
  }
  function ge(T) {
    return T === 47 || T === 62 || oa(T) ? it(T) : s(T);
  }
  function Qe(T) {
    return T === 62 ? (r.consume(T), r.exit("htmlTextData"), r.exit("htmlText"), o) : s(T);
  }
  function Fe(T) {
    return r.exit("htmlTextData"), r.enter("lineEnding"), r.consume(T), r.exit("lineEnding"), ae;
  }
  function ae(T) {
    return ln(T) ? _n(r, _e, "linePrefix", f.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(T) : _e(T);
  }
  function _e(T) {
    return r.enter("htmlTextData"), S(T);
  }
}
const vx = {
  name: "labelEnd",
  tokenize: G4,
  resolveTo: q4,
  resolveAll: Q4
}, $4 = {
  tokenize: X4
}, Y4 = {
  tokenize: K4
}, W4 = {
  tokenize: J4
};
function Q4(r) {
  let o = -1;
  for (; ++o < r.length; ) {
    const s = r[o][1];
    (s.type === "labelImage" || s.type === "labelLink" || s.type === "labelEnd") && (r.splice(o + 1, s.type === "labelImage" ? 4 : 2), s.type = "data", o++);
  }
  return r;
}
function q4(r, o) {
  let s = r.length, f = 0, h, y, S, v;
  for (; s--; )
    if (h = r[s][1], y) {
      if (h.type === "link" || h.type === "labelLink" && h._inactive)
        break;
      r[s][0] === "enter" && h.type === "labelLink" && (h._inactive = !0);
    } else if (S) {
      if (r[s][0] === "enter" && (h.type === "labelImage" || h.type === "labelLink") && !h._balanced && (y = s, h.type !== "labelLink")) {
        f = 2;
        break;
      }
    } else
      h.type === "labelEnd" && (S = s);
  const w = {
    type: r[y][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, r[y][1].start),
    end: Object.assign({}, r[r.length - 1][1].end)
  }, E = {
    type: "label",
    start: Object.assign({}, r[y][1].start),
    end: Object.assign({}, r[S][1].end)
  }, R = {
    type: "labelText",
    start: Object.assign({}, r[y + f + 2][1].end),
    end: Object.assign({}, r[S - 2][1].start)
  };
  return v = [["enter", w, o], ["enter", E, o]], v = Wa(v, r.slice(y + 1, y + f + 3)), v = Wa(v, [["enter", R, o]]), v = Wa(v, hx(o.parser.constructs.insideSpan.null, r.slice(y + f + 4, S - 3), o)), v = Wa(v, [["exit", R, o], r[S - 2], r[S - 1], ["exit", E, o]]), v = Wa(v, r.slice(S + 1)), v = Wa(v, [["exit", w, o]]), lu(r, y, r.length, v), r;
}
function G4(r, o, s) {
  const f = this;
  let h = f.events.length, y, S;
  for (; h--; )
    if ((f.events[h][1].type === "labelImage" || f.events[h][1].type === "labelLink") && !f.events[h][1]._balanced) {
      y = f.events[h][1];
      break;
    }
  return v;
  function v(N) {
    return y ? y._inactive ? D(N) : (S = f.parser.defined.includes(bd(f.sliceSerialize({
      start: y.end,
      end: f.now()
    }))), r.enter("labelEnd"), r.enter("labelMarker"), r.consume(N), r.exit("labelMarker"), r.exit("labelEnd"), w) : s(N);
  }
  function w(N) {
    return N === 40 ? r.attempt($4, R, S ? R : D)(N) : N === 91 ? r.attempt(Y4, R, S ? E : D)(N) : S ? R(N) : D(N);
  }
  function E(N) {
    return r.attempt(W4, R, D)(N);
  }
  function R(N) {
    return o(N);
  }
  function D(N) {
    return y._balanced = !0, s(N);
  }
}
function X4(r, o, s) {
  return f;
  function f(D) {
    return r.enter("resource"), r.enter("resourceMarker"), r.consume(D), r.exit("resourceMarker"), h;
  }
  function h(D) {
    return oa(D) ? Lh(r, y)(D) : y(D);
  }
  function y(D) {
    return D === 41 ? R(D) : tT(r, S, v, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(D);
  }
  function S(D) {
    return oa(D) ? Lh(r, w)(D) : R(D);
  }
  function v(D) {
    return s(D);
  }
  function w(D) {
    return D === 34 || D === 39 || D === 40 ? rT(r, E, s, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(D) : R(D);
  }
  function E(D) {
    return oa(D) ? Lh(r, R)(D) : R(D);
  }
  function R(D) {
    return D === 41 ? (r.enter("resourceMarker"), r.consume(D), r.exit("resourceMarker"), r.exit("resource"), o) : s(D);
  }
}
function K4(r, o, s) {
  const f = this;
  return h;
  function h(v) {
    return nT.call(f, r, y, S, "reference", "referenceMarker", "referenceString")(v);
  }
  function y(v) {
    return f.parser.defined.includes(bd(f.sliceSerialize(f.events[f.events.length - 1][1]).slice(1, -1))) ? o(v) : s(v);
  }
  function S(v) {
    return s(v);
  }
}
function J4(r, o, s) {
  return f;
  function f(y) {
    return r.enter("reference"), r.enter("referenceMarker"), r.consume(y), r.exit("referenceMarker"), h;
  }
  function h(y) {
    return y === 93 ? (r.enter("referenceMarker"), r.consume(y), r.exit("referenceMarker"), r.exit("reference"), o) : s(y);
  }
}
const Z4 = {
  name: "labelStartImage",
  tokenize: eL,
  resolveAll: vx.resolveAll
};
function eL(r, o, s) {
  const f = this;
  return h;
  function h(v) {
    return r.enter("labelImage"), r.enter("labelImageMarker"), r.consume(v), r.exit("labelImageMarker"), y;
  }
  function y(v) {
    return v === 91 ? (r.enter("labelMarker"), r.consume(v), r.exit("labelMarker"), r.exit("labelImage"), S) : s(v);
  }
  function S(v) {
    return v === 94 && "_hiddenFootnoteSupport" in f.parser.constructs ? s(v) : o(v);
  }
}
const tL = {
  name: "labelStartLink",
  tokenize: nL,
  resolveAll: vx.resolveAll
};
function nL(r, o, s) {
  const f = this;
  return h;
  function h(S) {
    return r.enter("labelLink"), r.enter("labelMarker"), r.consume(S), r.exit("labelMarker"), r.exit("labelLink"), y;
  }
  function y(S) {
    return S === 94 && "_hiddenFootnoteSupport" in f.parser.constructs ? s(S) : o(S);
  }
}
const LS = {
  name: "lineEnding",
  tokenize: rL
};
function rL(r, o) {
  return s;
  function s(f) {
    return r.enter("lineEnding"), r.consume(f), r.exit("lineEnding"), _n(r, o, "linePrefix");
  }
}
const Hy = {
  name: "thematicBreak",
  tokenize: iL
};
function iL(r, o, s) {
  let f = 0, h;
  return y;
  function y(E) {
    return r.enter("thematicBreak"), S(E);
  }
  function S(E) {
    return h = E, v(E);
  }
  function v(E) {
    return E === h ? (r.enter("thematicBreakSequence"), w(E)) : f >= 3 && (E === null || Tt(E)) ? (r.exit("thematicBreak"), o(E)) : s(E);
  }
  function w(E) {
    return E === h ? (r.consume(E), f++, w) : (r.exit("thematicBreakSequence"), ln(E) ? _n(r, v, "whitespace")(E) : v(E));
  }
}
const aa = {
  name: "list",
  tokenize: oL,
  continuation: {
    tokenize: uL
  },
  exit: cL
}, aL = {
  tokenize: fL,
  partial: !0
}, lL = {
  tokenize: sL,
  partial: !0
};
function oL(r, o, s) {
  const f = this, h = f.events[f.events.length - 1];
  let y = h && h[1].type === "linePrefix" ? h[2].sliceSerialize(h[1], !0).length : 0, S = 0;
  return v;
  function v(M) {
    const F = f.containerState.type || (M === 42 || M === 43 || M === 45 ? "listUnordered" : "listOrdered");
    if (F === "listUnordered" ? !f.containerState.marker || M === f.containerState.marker : KS(M)) {
      if (f.containerState.type || (f.containerState.type = F, r.enter(F, {
        _container: !0
      })), F === "listUnordered")
        return r.enter("listItemPrefix"), M === 42 || M === 45 ? r.check(Hy, s, E)(M) : E(M);
      if (!f.interrupt || M === 49)
        return r.enter("listItemPrefix"), r.enter("listItemValue"), w(M);
    }
    return s(M);
  }
  function w(M) {
    return KS(M) && ++S < 10 ? (r.consume(M), w) : (!f.interrupt || S < 2) && (f.containerState.marker ? M === f.containerState.marker : M === 41 || M === 46) ? (r.exit("listItemValue"), E(M)) : s(M);
  }
  function E(M) {
    return r.enter("listItemMarker"), r.consume(M), r.exit("listItemMarker"), f.containerState.marker = f.containerState.marker || M, r.check(
      Jy,
      // Cant be empty when interrupting.
      f.interrupt ? s : R,
      r.attempt(aL, N, D)
    );
  }
  function R(M) {
    return f.containerState.initialBlankLine = !0, y++, N(M);
  }
  function D(M) {
    return ln(M) ? (r.enter("listItemPrefixWhitespace"), r.consume(M), r.exit("listItemPrefixWhitespace"), N) : s(M);
  }
  function N(M) {
    return f.containerState.size = y + f.sliceSerialize(r.exit("listItemPrefix"), !0).length, o(M);
  }
}
function uL(r, o, s) {
  const f = this;
  return f.containerState._closeFlow = void 0, r.check(Jy, h, y);
  function h(v) {
    return f.containerState.furtherBlankLines = f.containerState.furtherBlankLines || f.containerState.initialBlankLine, _n(r, o, "listItemIndent", f.containerState.size + 1)(v);
  }
  function y(v) {
    return f.containerState.furtherBlankLines || !ln(v) ? (f.containerState.furtherBlankLines = void 0, f.containerState.initialBlankLine = void 0, S(v)) : (f.containerState.furtherBlankLines = void 0, f.containerState.initialBlankLine = void 0, r.attempt(lL, o, S)(v));
  }
  function S(v) {
    return f.containerState._closeFlow = !0, f.interrupt = void 0, _n(r, r.attempt(aa, o, s), "linePrefix", f.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(v);
  }
}
function sL(r, o, s) {
  const f = this;
  return _n(r, h, "listItemIndent", f.containerState.size + 1);
  function h(y) {
    const S = f.events[f.events.length - 1];
    return S && S[1].type === "listItemIndent" && S[2].sliceSerialize(S[1], !0).length === f.containerState.size ? o(y) : s(y);
  }
}
function cL(r) {
  r.exit(this.containerState.type);
}
function fL(r, o, s) {
  const f = this;
  return _n(r, h, "listItemPrefixWhitespace", f.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function h(y) {
    const S = f.events[f.events.length - 1];
    return !ln(y) && S && S[1].type === "listItemPrefixWhitespace" ? o(y) : s(y);
  }
}
const Pw = {
  name: "setextUnderline",
  tokenize: pL,
  resolveTo: dL
};
function dL(r, o) {
  let s = r.length, f, h, y;
  for (; s--; )
    if (r[s][0] === "enter") {
      if (r[s][1].type === "content") {
        f = s;
        break;
      }
      r[s][1].type === "paragraph" && (h = s);
    } else
      r[s][1].type === "content" && r.splice(s, 1), !y && r[s][1].type === "definition" && (y = s);
  const S = {
    type: "setextHeading",
    start: Object.assign({}, r[h][1].start),
    end: Object.assign({}, r[r.length - 1][1].end)
  };
  return r[h][1].type = "setextHeadingText", y ? (r.splice(h, 0, ["enter", S, o]), r.splice(y + 1, 0, ["exit", r[f][1], o]), r[f][1].end = Object.assign({}, r[y][1].end)) : r[f][1] = S, r.push(["exit", S, o]), r;
}
function pL(r, o, s) {
  const f = this;
  let h;
  return y;
  function y(E) {
    let R = f.events.length, D;
    for (; R--; )
      if (f.events[R][1].type !== "lineEnding" && f.events[R][1].type !== "linePrefix" && f.events[R][1].type !== "content") {
        D = f.events[R][1].type === "paragraph";
        break;
      }
    return !f.parser.lazy[f.now().line] && (f.interrupt || D) ? (r.enter("setextHeadingLine"), h = E, S(E)) : s(E);
  }
  function S(E) {
    return r.enter("setextHeadingLineSequence"), v(E);
  }
  function v(E) {
    return E === h ? (r.consume(E), v) : (r.exit("setextHeadingLineSequence"), ln(E) ? _n(r, w, "lineSuffix")(E) : w(E));
  }
  function w(E) {
    return E === null || Tt(E) ? (r.exit("setextHeadingLine"), o(E)) : s(E);
  }
}
const hL = {
  tokenize: vL
};
function vL(r) {
  const o = this, s = r.attempt(
    // Try to parse a blank line.
    Jy,
    f,
    // Try to parse initial flow (essentially, only code).
    r.attempt(
      this.parser.constructs.flowInitial,
      h,
      _n(
        r,
        r.attempt(
          this.parser.constructs.flow,
          h,
          r.attempt(x4, h)
        ),
        "linePrefix"
      )
    )
  );
  return s;
  function f(y) {
    if (y === null) {
      r.consume(y);
      return;
    }
    return r.enter("lineEndingBlank"), r.consume(y), r.exit("lineEndingBlank"), o.currentConstruct = void 0, s;
  }
  function h(y) {
    if (y === null) {
      r.consume(y);
      return;
    }
    return r.enter("lineEnding"), r.consume(y), r.exit("lineEnding"), o.currentConstruct = void 0, s;
  }
}
const mL = {
  resolveAll: aT()
}, yL = iT("string"), gL = iT("text");
function iT(r) {
  return {
    tokenize: o,
    resolveAll: aT(
      r === "text" ? SL : void 0
    )
  };
  function o(s) {
    const f = this, h = this.parser.constructs[r], y = s.attempt(h, S, v);
    return S;
    function S(R) {
      return E(R) ? y(R) : v(R);
    }
    function v(R) {
      if (R === null) {
        s.consume(R);
        return;
      }
      return s.enter("data"), s.consume(R), w;
    }
    function w(R) {
      return E(R) ? (s.exit("data"), y(R)) : (s.consume(R), w);
    }
    function E(R) {
      if (R === null)
        return !0;
      const D = h[R];
      let N = -1;
      if (D)
        for (; ++N < D.length; ) {
          const M = D[N];
          if (!M.previous || M.previous.call(f, f.previous))
            return !0;
        }
      return !1;
    }
  }
}
function aT(r) {
  return o;
  function o(s, f) {
    let h = -1, y;
    for (; ++h <= s.length; )
      y === void 0 ? s[h] && s[h][1].type === "data" && (y = h, h++) : (!s[h] || s[h][1].type !== "data") && (h !== y + 2 && (s[y][1].end = s[h - 1][1].end, s.splice(y + 2, h - y - 2), h = y + 2), y = void 0);
    return r ? r(s, f) : s;
  }
}
function SL(r, o) {
  let s = 0;
  for (; ++s <= r.length; )
    if ((s === r.length || r[s][1].type === "lineEnding") && r[s - 1][1].type === "data") {
      const f = r[s - 1][1], h = o.sliceStream(f);
      let y = h.length, S = -1, v = 0, w;
      for (; y--; ) {
        const E = h[y];
        if (typeof E == "string") {
          for (S = E.length; E.charCodeAt(S - 1) === 32; )
            v++, S--;
          if (S)
            break;
          S = -1;
        } else if (E === -2)
          w = !0, v++;
        else if (E !== -1) {
          y++;
          break;
        }
      }
      if (v) {
        const E = {
          type: s === r.length || w || v < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: f.end.line,
            column: f.end.column - v,
            offset: f.end.offset - v,
            _index: f.start._index + y,
            _bufferIndex: y ? S : f.start._bufferIndex + S
          },
          end: Object.assign({}, f.end)
        };
        f.end = Object.assign({}, E.start), f.start.offset === f.end.offset ? Object.assign(f, E) : (r.splice(
          s,
          0,
          ["enter", E, o],
          ["exit", E, o]
        ), s += 2);
      }
      s++;
    }
  return r;
}
function xL(r, o, s) {
  let f = Object.assign(
    s ? Object.assign({}, s) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const h = {}, y = [];
  let S = [], v = [];
  const w = {
    consume: se,
    enter: te,
    exit: Se,
    attempt: Oe(Ce),
    check: Oe(Y),
    interrupt: Oe(Y, {
      interrupt: !0
    })
  }, E = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: r,
    sliceStream: M,
    sliceSerialize: N,
    now: F,
    defineSkip: $,
    write: D
  };
  let R = o.tokenize.call(E, w);
  return o.resolveAll && y.push(o), E;
  function D(he) {
    return S = Wa(S, he), ce(), S[S.length - 1] !== null ? [] : (ze(o, 0), E.events = hx(y, E.events, E), E.events);
  }
  function N(he, ne) {
    return EL(M(he), ne);
  }
  function M(he) {
    return bL(S, he);
  }
  function F() {
    const { line: he, column: ne, offset: we, _index: de, _bufferIndex: ge } = f;
    return {
      line: he,
      column: ne,
      offset: we,
      _index: de,
      _bufferIndex: ge
    };
  }
  function $(he) {
    h[he.line] = he.column, lt();
  }
  function ce() {
    let he;
    for (; f._index < S.length; ) {
      const ne = S[f._index];
      if (typeof ne == "string")
        for (he = f._index, f._bufferIndex < 0 && (f._bufferIndex = 0); f._index === he && f._bufferIndex < ne.length; )
          X(ne.charCodeAt(f._bufferIndex));
      else
        X(ne);
    }
  }
  function X(he) {
    R = R(he);
  }
  function se(he) {
    Tt(he) ? (f.line++, f.column = 1, f.offset += he === -3 ? 2 : 1, lt()) : he !== -1 && (f.column++, f.offset++), f._bufferIndex < 0 ? f._index++ : (f._bufferIndex++, f._bufferIndex === S[f._index].length && (f._bufferIndex = -1, f._index++)), E.previous = he;
  }
  function te(he, ne) {
    const we = ne || {};
    return we.type = he, we.start = F(), E.events.push(["enter", we, E]), v.push(we), we;
  }
  function Se(he) {
    const ne = v.pop();
    return ne.end = F(), E.events.push(["exit", ne, E]), ne;
  }
  function Ce(he, ne) {
    ze(he, ne.from);
  }
  function Y(he, ne) {
    ne.restore();
  }
  function Oe(he, ne) {
    return we;
    function we(de, ge, Qe) {
      let Fe, ae, _e, T;
      return Array.isArray(de) ? Ae(de) : "tokenize" in de ? (
        // @ts-expect-error Looks like a construct.
        Ae([de])
      ) : ue(de);
      function ue(at) {
        return _t;
        function _t(mt) {
          const Qt = mt !== null && at[mt], wn = mt !== null && at.null, An = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Qt) ? Qt : Qt ? [Qt] : [],
            ...Array.isArray(wn) ? wn : wn ? [wn] : []
          ];
          return Ae(An)(mt);
        }
      }
      function Ae(at) {
        return Fe = at, ae = 0, at.length === 0 ? Qe : A(at[ae]);
      }
      function A(at) {
        return _t;
        function _t(mt) {
          return T = it(), _e = at, at.partial || (E.currentConstruct = at), at.name && E.parser.constructs.disable.null.includes(at.name) ? bt() : at.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            ne ? Object.assign(Object.create(E), ne) : E,
            w,
            Ke,
            bt
          )(mt);
        }
      }
      function Ke(at) {
        return he(_e, T), ge;
      }
      function bt(at) {
        return T.restore(), ++ae < Fe.length ? A(Fe[ae]) : Qe;
      }
    }
  }
  function ze(he, ne) {
    he.resolveAll && !y.includes(he) && y.push(he), he.resolve && lu(
      E.events,
      ne,
      E.events.length - ne,
      he.resolve(E.events.slice(ne), E)
    ), he.resolveTo && (E.events = he.resolveTo(E.events, E));
  }
  function it() {
    const he = F(), ne = E.previous, we = E.currentConstruct, de = E.events.length, ge = Array.from(v);
    return {
      restore: Qe,
      from: de
    };
    function Qe() {
      f = he, E.previous = ne, E.currentConstruct = we, E.events.length = de, v = ge, lt();
    }
  }
  function lt() {
    f.line in h && f.column < 2 && (f.column = h[f.line], f.offset += h[f.line] - 1);
  }
}
function bL(r, o) {
  const s = o.start._index, f = o.start._bufferIndex, h = o.end._index, y = o.end._bufferIndex;
  let S;
  if (s === h)
    S = [r[s].slice(f, y)];
  else {
    if (S = r.slice(s, h), f > -1) {
      const v = S[0];
      typeof v == "string" ? S[0] = v.slice(f) : S.shift();
    }
    y > 0 && S.push(r[h].slice(0, y));
  }
  return S;
}
function EL(r, o) {
  let s = -1;
  const f = [];
  let h;
  for (; ++s < r.length; ) {
    const y = r[s];
    let S;
    if (typeof y == "string")
      S = y;
    else
      switch (y) {
        case -5: {
          S = "\r";
          break;
        }
        case -4: {
          S = `
`;
          break;
        }
        case -3: {
          S = `\r
`;
          break;
        }
        case -2: {
          S = o ? " " : "	";
          break;
        }
        case -1: {
          if (!o && h)
            continue;
          S = " ";
          break;
        }
        default:
          S = String.fromCharCode(y);
      }
    h = y === -2, f.push(S);
  }
  return f.join("");
}
const CL = {
  42: aa,
  43: aa,
  45: aa,
  48: aa,
  49: aa,
  50: aa,
  51: aa,
  52: aa,
  53: aa,
  54: aa,
  55: aa,
  56: aa,
  57: aa,
  62: Kk
}, wL = {
  91: k4
}, kL = {
  [-2]: NS,
  [-1]: NS,
  32: NS
}, TL = {
  35: M4,
  42: Hy,
  45: [Pw, Hy],
  60: A4,
  61: Pw,
  95: Hy,
  96: Uw,
  126: Uw
}, RL = {
  38: Zk,
  92: Jk
}, _L = {
  [-5]: LS,
  [-4]: LS,
  [-3]: LS,
  33: Z4,
  38: Zk,
  42: JS,
  60: [t4, B4],
  91: tL,
  92: [D4, Jk],
  93: vx,
  95: JS,
  96: h4
}, DL = {
  null: [JS, mL]
}, OL = {
  null: [42, 95]
}, ML = {
  null: []
}, NL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: OL,
  contentInitial: wL,
  disable: ML,
  document: CL,
  flow: TL,
  flowInitial: kL,
  insideSpan: DL,
  string: RL,
  text: _L
}, Symbol.toStringTag, { value: "Module" }));
function LL(r) {
  const s = (
    /** @type {FullNormalizedExtension} */
    H3([NL, ...(r || {}).extensions || []])
  ), f = {
    defined: [],
    lazy: {},
    constructs: s,
    content: h(q3),
    document: h(X3),
    flow: h(hL),
    string: h(yL),
    text: h(gL)
  };
  return f;
  function h(y) {
    return S;
    function S(v) {
      return xL(f, y, v);
    }
  }
}
function zL(r) {
  for (; !eT(r); )
    ;
  return r;
}
const Hw = /[\0\t\n\r]/g;
function AL() {
  let r = 1, o = "", s = !0, f;
  return h;
  function h(y, S, v) {
    const w = [];
    let E, R, D, N, M;
    for (y = o + (typeof y == "string" ? y.toString() : new TextDecoder(S || void 0).decode(y)), D = 0, o = "", s && (y.charCodeAt(0) === 65279 && D++, s = void 0); D < y.length; ) {
      if (Hw.lastIndex = D, E = Hw.exec(y), N = E && E.index !== void 0 ? E.index : y.length, M = y.charCodeAt(N), !E) {
        o = y.slice(D);
        break;
      }
      if (M === 10 && D === N && f)
        w.push(-3), f = void 0;
      else
        switch (f && (w.push(-5), f = void 0), D < N && (w.push(y.slice(D, N)), r += N - D), M) {
          case 0: {
            w.push(65533), r++;
            break;
          }
          case 9: {
            for (R = Math.ceil(r / 4) * 4, w.push(-2); r++ < R; )
              w.push(-1);
            break;
          }
          case 10: {
            w.push(-4), r = 1;
            break;
          }
          default:
            f = !0, r = 1;
        }
      D = N + 1;
    }
    return v && (f && w.push(-5), o && w.push(o), w.push(null)), w;
  }
}
const jL = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function UL(r) {
  return r.replace(jL, FL);
}
function FL(r, o, s) {
  if (o)
    return o;
  if (s.charCodeAt(0) === 35) {
    const h = s.charCodeAt(1), y = h === 120 || h === 88;
    return Xk(s.slice(y ? 2 : 1), y ? 16 : 10);
  }
  return px(s) || r;
}
const lT = {}.hasOwnProperty;
function PL(r, o, s) {
  return typeof o != "string" && (s = o, o = void 0), HL(s)(zL(LL(s).document().write(AL()(r, o, !0))));
}
function HL(r) {
  const o = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: y(cr),
      autolinkProtocol: it,
      autolinkEmail: it,
      atxHeading: y(Jn),
      blockQuote: y(wn),
      characterEscape: it,
      characterReference: it,
      codeFenced: y(An),
      codeFencedFenceInfo: S,
      codeFencedFenceMeta: S,
      codeIndented: y(An, S),
      codeText: y(Mr, S),
      codeTextData: it,
      data: it,
      codeFlowValue: it,
      definition: y(sr),
      definitionDestinationString: S,
      definitionLabelString: S,
      definitionTitleString: S,
      emphasis: y(kn),
      hardBreakEscape: y(jn),
      hardBreakTrailing: y(jn),
      htmlFlow: y(Dn, S),
      htmlFlowData: it,
      htmlText: y(Dn, S),
      htmlTextData: it,
      image: y(Un),
      label: S,
      link: y(cr),
      listItem: y($n),
      listItemValue: N,
      listOrdered: y(rr, D),
      listUnordered: y(rr),
      paragraph: y(Fr),
      reference: A,
      referenceString: S,
      resourceDestinationString: S,
      resourceTitleString: S,
      setextHeading: y(Jn),
      strong: y(Pr),
      thematicBreak: y(Hr)
    },
    exit: {
      atxHeading: w(),
      atxHeadingSequence: Ce,
      autolink: w(),
      autolinkEmail: Qt,
      autolinkProtocol: mt,
      blockQuote: w(),
      characterEscapeValue: lt,
      characterReferenceMarkerHexadecimal: bt,
      characterReferenceMarkerNumeric: bt,
      characterReferenceValue: at,
      characterReference: _t,
      codeFenced: w(ce),
      codeFencedFence: $,
      codeFencedFenceInfo: M,
      codeFencedFenceMeta: F,
      codeFlowValue: lt,
      codeIndented: w(X),
      codeText: w(ge),
      codeTextData: lt,
      data: lt,
      definition: w(),
      definitionDestinationString: Se,
      definitionLabelString: se,
      definitionTitleString: te,
      emphasis: w(),
      hardBreakEscape: w(ne),
      hardBreakTrailing: w(ne),
      htmlFlow: w(we),
      htmlFlowData: lt,
      htmlText: w(de),
      htmlTextData: lt,
      image: w(Fe),
      label: _e,
      labelText: ae,
      lineEnding: he,
      link: w(Qe),
      listItem: w(),
      listOrdered: w(),
      listUnordered: w(),
      paragraph: w(),
      referenceString: Ke,
      resourceDestinationString: T,
      resourceTitleString: ue,
      resource: Ae,
      setextHeading: w(ze),
      setextHeadingLineSequence: Oe,
      setextHeadingText: Y,
      strong: w(),
      thematicBreak: w()
    }
  };
  oT(o, (r || {}).mdastExtensions || []);
  const s = {};
  return f;
  function f(re) {
    let Ee = {
      type: "root",
      children: []
    };
    const $e = {
      stack: [Ee],
      tokenStack: [],
      config: o,
      enter: v,
      exit: E,
      buffer: S,
      resume: R,
      data: s
    }, yt = [];
    let Ot = -1;
    for (; ++Ot < re.length; )
      if (re[Ot][1].type === "listOrdered" || re[Ot][1].type === "listUnordered")
        if (re[Ot][0] === "enter")
          yt.push(Ot);
        else {
          const gn = yt.pop();
          Ot = h(re, gn, Ot);
        }
    for (Ot = -1; ++Ot < re.length; ) {
      const gn = o[re[Ot][0]];
      lT.call(gn, re[Ot][1].type) && gn[re[Ot][1].type].call(Object.assign({
        sliceSerialize: re[Ot][2].sliceSerialize
      }, $e), re[Ot][1]);
    }
    if ($e.tokenStack.length > 0) {
      const gn = $e.tokenStack[$e.tokenStack.length - 1];
      (gn[1] || Iw).call($e, void 0, gn[0]);
    }
    for (Ee.position = {
      start: ds(re.length > 0 ? re[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: ds(re.length > 0 ? re[re.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Ot = -1; ++Ot < o.transforms.length; )
      Ee = o.transforms[Ot](Ee) || Ee;
    return Ee;
  }
  function h(re, Ee, $e) {
    let yt = Ee - 1, Ot = -1, gn = !1, De, Ye, St, Ut;
    for (; ++yt <= $e; ) {
      const Et = re[yt];
      switch (Et[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Et[0] === "enter" ? Ot++ : Ot--, Ut = void 0;
          break;
        }
        case "lineEndingBlank": {
          Et[0] === "enter" && (De && !Ut && !Ot && !St && (St = yt), Ut = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Ut = void 0;
      }
      if (!Ot && Et[0] === "enter" && Et[1].type === "listItemPrefix" || Ot === -1 && Et[0] === "exit" && (Et[1].type === "listUnordered" || Et[1].type === "listOrdered")) {
        if (De) {
          let on = yt;
          for (Ye = void 0; on--; ) {
            const Yt = re[on];
            if (Yt[1].type === "lineEnding" || Yt[1].type === "lineEndingBlank") {
              if (Yt[0] === "exit")
                continue;
              Ye && (re[Ye][1].type = "lineEndingBlank", gn = !0), Yt[1].type = "lineEnding", Ye = on;
            } else if (!(Yt[1].type === "linePrefix" || Yt[1].type === "blockQuotePrefix" || Yt[1].type === "blockQuotePrefixWhitespace" || Yt[1].type === "blockQuoteMarker" || Yt[1].type === "listItemIndent"))
              break;
          }
          St && (!Ye || St < Ye) && (De._spread = !0), De.end = Object.assign({}, Ye ? re[Ye][1].start : Et[1].end), re.splice(Ye || yt, 0, ["exit", De, Et[2]]), yt++, $e++;
        }
        if (Et[1].type === "listItemPrefix") {
          const on = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Et[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          De = on, re.splice(yt, 0, ["enter", on, Et[2]]), yt++, $e++, St = void 0, Ut = !0;
        }
      }
    }
    return re[Ee][1]._spread = gn, $e;
  }
  function y(re, Ee) {
    return $e;
    function $e(yt) {
      v.call(this, re(yt), yt), Ee && Ee.call(this, yt);
    }
  }
  function S() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function v(re, Ee, $e) {
    this.stack[this.stack.length - 1].children.push(re), this.stack.push(re), this.tokenStack.push([Ee, $e]), re.position = {
      start: ds(Ee.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function w(re) {
    return Ee;
    function Ee($e) {
      re && re.call(this, $e), E.call(this, $e);
    }
  }
  function E(re, Ee) {
    const $e = this.stack.pop(), yt = this.tokenStack.pop();
    if (yt)
      yt[0].type !== re.type && (Ee ? Ee.call(this, re, yt[0]) : (yt[1] || Iw).call(this, re, yt[0]));
    else
      throw new Error("Cannot close `" + re.type + "` (" + Nh({
        start: re.start,
        end: re.end
      }) + "): its not open");
    $e.position.end = ds(re.end);
  }
  function R() {
    return F3(this.stack.pop());
  }
  function D() {
    this.data.expectingFirstListItemValue = !0;
  }
  function N(re) {
    if (this.data.expectingFirstListItemValue) {
      const Ee = this.stack[this.stack.length - 2];
      Ee.start = Number.parseInt(this.sliceSerialize(re), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function M() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.lang = re;
  }
  function F() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.meta = re;
  }
  function $() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function ce() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.value = re.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function X() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.value = re.replace(/(\r?\n|\r)$/g, "");
  }
  function se(re) {
    const Ee = this.resume(), $e = this.stack[this.stack.length - 1];
    $e.label = Ee, $e.identifier = bd(this.sliceSerialize(re)).toLowerCase();
  }
  function te() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.title = re;
  }
  function Se() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.url = re;
  }
  function Ce(re) {
    const Ee = this.stack[this.stack.length - 1];
    if (!Ee.depth) {
      const $e = this.sliceSerialize(re).length;
      Ee.depth = $e;
    }
  }
  function Y() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function Oe(re) {
    const Ee = this.stack[this.stack.length - 1];
    Ee.depth = this.sliceSerialize(re).codePointAt(0) === 61 ? 1 : 2;
  }
  function ze() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function it(re) {
    const $e = this.stack[this.stack.length - 1].children;
    let yt = $e[$e.length - 1];
    (!yt || yt.type !== "text") && (yt = fr(), yt.position = {
      start: ds(re.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, $e.push(yt)), this.stack.push(yt);
  }
  function lt(re) {
    const Ee = this.stack.pop();
    Ee.value += this.sliceSerialize(re), Ee.position.end = ds(re.end);
  }
  function he(re) {
    const Ee = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const $e = Ee.children[Ee.children.length - 1];
      $e.position.end = ds(re.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && o.canContainEols.includes(Ee.type) && (it.call(this, re), lt.call(this, re));
  }
  function ne() {
    this.data.atHardBreak = !0;
  }
  function we() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.value = re;
  }
  function de() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.value = re;
  }
  function ge() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.value = re;
  }
  function Qe() {
    const re = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Ee = this.data.referenceType || "shortcut";
      re.type += "Reference", re.referenceType = Ee, delete re.url, delete re.title;
    } else
      delete re.identifier, delete re.label;
    this.data.referenceType = void 0;
  }
  function Fe() {
    const re = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Ee = this.data.referenceType || "shortcut";
      re.type += "Reference", re.referenceType = Ee, delete re.url, delete re.title;
    } else
      delete re.identifier, delete re.label;
    this.data.referenceType = void 0;
  }
  function ae(re) {
    const Ee = this.sliceSerialize(re), $e = this.stack[this.stack.length - 2];
    $e.label = UL(Ee), $e.identifier = bd(Ee).toLowerCase();
  }
  function _e() {
    const re = this.stack[this.stack.length - 1], Ee = this.resume(), $e = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, $e.type === "link") {
      const yt = re.children;
      $e.children = yt;
    } else
      $e.alt = Ee;
  }
  function T() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.url = re;
  }
  function ue() {
    const re = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.title = re;
  }
  function Ae() {
    this.data.inReference = void 0;
  }
  function A() {
    this.data.referenceType = "collapsed";
  }
  function Ke(re) {
    const Ee = this.resume(), $e = this.stack[this.stack.length - 1];
    $e.label = Ee, $e.identifier = bd(this.sliceSerialize(re)).toLowerCase(), this.data.referenceType = "full";
  }
  function bt(re) {
    this.data.characterReferenceType = re.type;
  }
  function at(re) {
    const Ee = this.sliceSerialize(re), $e = this.data.characterReferenceType;
    let yt;
    $e ? (yt = Xk(Ee, $e === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : yt = px(Ee);
    const Ot = this.stack[this.stack.length - 1];
    Ot.value += yt;
  }
  function _t(re) {
    const Ee = this.stack.pop();
    Ee.position.end = ds(re.end);
  }
  function mt(re) {
    lt.call(this, re);
    const Ee = this.stack[this.stack.length - 1];
    Ee.url = this.sliceSerialize(re);
  }
  function Qt(re) {
    lt.call(this, re);
    const Ee = this.stack[this.stack.length - 1];
    Ee.url = "mailto:" + this.sliceSerialize(re);
  }
  function wn() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function An() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Mr() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function sr() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function kn() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Jn() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function jn() {
    return {
      type: "break"
    };
  }
  function Dn() {
    return {
      type: "html",
      value: ""
    };
  }
  function Un() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function cr() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function rr(re) {
    return {
      type: "list",
      ordered: re.type === "listOrdered",
      start: null,
      spread: re._spread,
      children: []
    };
  }
  function $n(re) {
    return {
      type: "listItem",
      spread: re._spread,
      checked: null,
      children: []
    };
  }
  function Fr() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Pr() {
    return {
      type: "strong",
      children: []
    };
  }
  function fr() {
    return {
      type: "text",
      value: ""
    };
  }
  function Hr() {
    return {
      type: "thematicBreak"
    };
  }
}
function ds(r) {
  return {
    line: r.line,
    column: r.column,
    offset: r.offset
  };
}
function oT(r, o) {
  let s = -1;
  for (; ++s < o.length; ) {
    const f = o[s];
    Array.isArray(f) ? oT(r, f) : IL(r, f);
  }
}
function IL(r, o) {
  let s;
  for (s in o)
    if (lT.call(o, s))
      switch (s) {
        case "canContainEols": {
          const f = o[s];
          f && r[s].push(...f);
          break;
        }
        case "transforms": {
          const f = o[s];
          f && r[s].push(...f);
          break;
        }
        case "enter":
        case "exit": {
          const f = o[s];
          f && Object.assign(r[s], f);
          break;
        }
      }
}
function Iw(r, o) {
  throw r ? new Error("Cannot close `" + r.type + "` (" + Nh({
    start: r.start,
    end: r.end
  }) + "): a different token (`" + o.type + "`, " + Nh({
    start: o.start,
    end: o.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + o.type + "`, " + Nh({
    start: o.start,
    end: o.end
  }) + ") is still open");
}
function BL(r) {
  const o = this;
  o.parser = s;
  function s(f) {
    return PL(f, {
      ...o.data("settings"),
      ...r,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: o.data("micromarkExtensions") || [],
      mdastExtensions: o.data("fromMarkdownExtensions") || []
    });
  }
}
function VL(r, o) {
  const s = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: r.wrap(r.all(o), !0)
  };
  return r.patch(o, s), r.applyData(o, s);
}
function $L(r, o) {
  const s = { type: "element", tagName: "br", properties: {}, children: [] };
  return r.patch(o, s), [r.applyData(o, s), { type: "text", value: `
` }];
}
function YL(r, o) {
  const s = o.value ? o.value + `
` : "", f = {};
  o.lang && (f.className = ["language-" + o.lang]);
  let h = {
    type: "element",
    tagName: "code",
    properties: f,
    children: [{ type: "text", value: s }]
  };
  return o.meta && (h.data = { meta: o.meta }), r.patch(o, h), h = r.applyData(o, h), h = { type: "element", tagName: "pre", properties: {}, children: [h] }, r.patch(o, h), h;
}
function WL(r, o) {
  const s = {
    type: "element",
    tagName: "del",
    properties: {},
    children: r.all(o)
  };
  return r.patch(o, s), r.applyData(o, s);
}
function QL(r, o) {
  const s = {
    type: "element",
    tagName: "em",
    properties: {},
    children: r.all(o)
  };
  return r.patch(o, s), r.applyData(o, s);
}
function qL(r, o) {
  const s = typeof r.options.clobberPrefix == "string" ? r.options.clobberPrefix : "user-content-", f = String(o.identifier).toUpperCase(), h = kd(f.toLowerCase()), y = r.footnoteOrder.indexOf(f);
  let S, v = r.footnoteCounts.get(f);
  v === void 0 ? (v = 0, r.footnoteOrder.push(f), S = r.footnoteOrder.length) : S = y + 1, v += 1, r.footnoteCounts.set(f, v);
  const w = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + s + "fn-" + h,
      id: s + "fnref-" + h + (v > 1 ? "-" + v : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(S) }]
  };
  r.patch(o, w);
  const E = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [w]
  };
  return r.patch(o, E), r.applyData(o, E);
}
function GL(r, o) {
  const s = {
    type: "element",
    tagName: "h" + o.depth,
    properties: {},
    children: r.all(o)
  };
  return r.patch(o, s), r.applyData(o, s);
}
function XL(r, o) {
  if (r.options.allowDangerousHtml) {
    const s = { type: "raw", value: o.value };
    return r.patch(o, s), r.applyData(o, s);
  }
}
function uT(r, o) {
  const s = o.referenceType;
  let f = "]";
  if (s === "collapsed" ? f += "[]" : s === "full" && (f += "[" + (o.label || o.identifier) + "]"), o.type === "imageReference")
    return [{ type: "text", value: "![" + o.alt + f }];
  const h = r.all(o), y = h[0];
  y && y.type === "text" ? y.value = "[" + y.value : h.unshift({ type: "text", value: "[" });
  const S = h[h.length - 1];
  return S && S.type === "text" ? S.value += f : h.push({ type: "text", value: f }), h;
}
function KL(r, o) {
  const s = String(o.identifier).toUpperCase(), f = r.definitionById.get(s);
  if (!f)
    return uT(r, o);
  const h = { src: kd(f.url || ""), alt: o.alt };
  f.title !== null && f.title !== void 0 && (h.title = f.title);
  const y = { type: "element", tagName: "img", properties: h, children: [] };
  return r.patch(o, y), r.applyData(o, y);
}
function JL(r, o) {
  const s = { src: kd(o.url) };
  o.alt !== null && o.alt !== void 0 && (s.alt = o.alt), o.title !== null && o.title !== void 0 && (s.title = o.title);
  const f = { type: "element", tagName: "img", properties: s, children: [] };
  return r.patch(o, f), r.applyData(o, f);
}
function ZL(r, o) {
  const s = { type: "text", value: o.value.replace(/\r?\n|\r/g, " ") };
  r.patch(o, s);
  const f = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [s]
  };
  return r.patch(o, f), r.applyData(o, f);
}
function e8(r, o) {
  const s = String(o.identifier).toUpperCase(), f = r.definitionById.get(s);
  if (!f)
    return uT(r, o);
  const h = { href: kd(f.url || "") };
  f.title !== null && f.title !== void 0 && (h.title = f.title);
  const y = {
    type: "element",
    tagName: "a",
    properties: h,
    children: r.all(o)
  };
  return r.patch(o, y), r.applyData(o, y);
}
function t8(r, o) {
  const s = { href: kd(o.url) };
  o.title !== null && o.title !== void 0 && (s.title = o.title);
  const f = {
    type: "element",
    tagName: "a",
    properties: s,
    children: r.all(o)
  };
  return r.patch(o, f), r.applyData(o, f);
}
function n8(r, o, s) {
  const f = r.all(o), h = s ? r8(s) : sT(o), y = {}, S = [];
  if (typeof o.checked == "boolean") {
    const R = f[0];
    let D;
    R && R.type === "element" && R.tagName === "p" ? D = R : (D = { type: "element", tagName: "p", properties: {}, children: [] }, f.unshift(D)), D.children.length > 0 && D.children.unshift({ type: "text", value: " " }), D.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: o.checked, disabled: !0 },
      children: []
    }), y.className = ["task-list-item"];
  }
  let v = -1;
  for (; ++v < f.length; ) {
    const R = f[v];
    (h || v !== 0 || R.type !== "element" || R.tagName !== "p") && S.push({ type: "text", value: `
` }), R.type === "element" && R.tagName === "p" && !h ? S.push(...R.children) : S.push(R);
  }
  const w = f[f.length - 1];
  w && (h || w.type !== "element" || w.tagName !== "p") && S.push({ type: "text", value: `
` });
  const E = { type: "element", tagName: "li", properties: y, children: S };
  return r.patch(o, E), r.applyData(o, E);
}
function r8(r) {
  let o = !1;
  if (r.type === "list") {
    o = r.spread || !1;
    const s = r.children;
    let f = -1;
    for (; !o && ++f < s.length; )
      o = sT(s[f]);
  }
  return o;
}
function sT(r) {
  const o = r.spread;
  return o ?? r.children.length > 1;
}
function i8(r, o) {
  const s = {}, f = r.all(o);
  let h = -1;
  for (typeof o.start == "number" && o.start !== 1 && (s.start = o.start); ++h < f.length; ) {
    const S = f[h];
    if (S.type === "element" && S.tagName === "li" && S.properties && Array.isArray(S.properties.className) && S.properties.className.includes("task-list-item")) {
      s.className = ["contains-task-list"];
      break;
    }
  }
  const y = {
    type: "element",
    tagName: o.ordered ? "ol" : "ul",
    properties: s,
    children: r.wrap(f, !0)
  };
  return r.patch(o, y), r.applyData(o, y);
}
function a8(r, o) {
  const s = {
    type: "element",
    tagName: "p",
    properties: {},
    children: r.all(o)
  };
  return r.patch(o, s), r.applyData(o, s);
}
function l8(r, o) {
  const s = { type: "root", children: r.wrap(r.all(o)) };
  return r.patch(o, s), r.applyData(o, s);
}
function o8(r, o) {
  const s = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: r.all(o)
  };
  return r.patch(o, s), r.applyData(o, s);
}
function u8(r, o) {
  const s = r.all(o), f = s.shift(), h = [];
  if (f) {
    const S = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: r.wrap([f], !0)
    };
    r.patch(o.children[0], S), h.push(S);
  }
  if (s.length > 0) {
    const S = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: r.wrap(s, !0)
    }, v = sx(o.children[1]), w = Vk(o.children[o.children.length - 1]);
    v && w && (S.position = { start: v, end: w }), h.push(S);
  }
  const y = {
    type: "element",
    tagName: "table",
    properties: {},
    children: r.wrap(h, !0)
  };
  return r.patch(o, y), r.applyData(o, y);
}
function s8(r, o, s) {
  const f = s ? s.children : void 0, y = (f ? f.indexOf(o) : 1) === 0 ? "th" : "td", S = s && s.type === "table" ? s.align : void 0, v = S ? S.length : o.children.length;
  let w = -1;
  const E = [];
  for (; ++w < v; ) {
    const D = o.children[w], N = {}, M = S ? S[w] : void 0;
    M && (N.align = M);
    let F = { type: "element", tagName: y, properties: N, children: [] };
    D && (F.children = r.all(D), r.patch(D, F), F = r.applyData(D, F)), E.push(F);
  }
  const R = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: r.wrap(E, !0)
  };
  return r.patch(o, R), r.applyData(o, R);
}
function c8(r, o) {
  const s = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: r.all(o)
  };
  return r.patch(o, s), r.applyData(o, s);
}
const Bw = 9, Vw = 32;
function f8(r) {
  const o = String(r), s = /\r?\n|\r/g;
  let f = s.exec(o), h = 0;
  const y = [];
  for (; f; )
    y.push(
      $w(o.slice(h, f.index), h > 0, !0),
      f[0]
    ), h = f.index + f[0].length, f = s.exec(o);
  return y.push($w(o.slice(h), h > 0, !1)), y.join("");
}
function $w(r, o, s) {
  let f = 0, h = r.length;
  if (o) {
    let y = r.codePointAt(f);
    for (; y === Bw || y === Vw; )
      f++, y = r.codePointAt(f);
  }
  if (s) {
    let y = r.codePointAt(h - 1);
    for (; y === Bw || y === Vw; )
      h--, y = r.codePointAt(h - 1);
  }
  return h > f ? r.slice(f, h) : "";
}
function d8(r, o) {
  const s = { type: "text", value: f8(String(o.value)) };
  return r.patch(o, s), r.applyData(o, s);
}
function p8(r, o) {
  const s = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return r.patch(o, s), r.applyData(o, s);
}
const h8 = {
  blockquote: VL,
  break: $L,
  code: YL,
  delete: WL,
  emphasis: QL,
  footnoteReference: qL,
  heading: GL,
  html: XL,
  imageReference: KL,
  image: JL,
  inlineCode: ZL,
  linkReference: e8,
  link: t8,
  listItem: n8,
  list: i8,
  paragraph: a8,
  // @ts-expect-error: root is different, but hard to type.
  root: l8,
  strong: o8,
  table: u8,
  tableCell: c8,
  tableRow: s8,
  text: d8,
  thematicBreak: p8,
  toml: Ly,
  yaml: Ly,
  definition: Ly,
  footnoteDefinition: Ly
};
function Ly() {
}
const cT = -1, Zy = 0, Vy = 1, $y = 2, mx = 3, yx = 4, gx = 5, Sx = 6, fT = 7, dT = 8, Yw = typeof self == "object" ? self : globalThis, v8 = (r, o) => {
  const s = (h, y) => (r.set(y, h), h), f = (h) => {
    if (r.has(h))
      return r.get(h);
    const [y, S] = o[h];
    switch (y) {
      case Zy:
      case cT:
        return s(S, h);
      case Vy: {
        const v = s([], h);
        for (const w of S)
          v.push(f(w));
        return v;
      }
      case $y: {
        const v = s({}, h);
        for (const [w, E] of S)
          v[f(w)] = f(E);
        return v;
      }
      case mx:
        return s(new Date(S), h);
      case yx: {
        const { source: v, flags: w } = S;
        return s(new RegExp(v, w), h);
      }
      case gx: {
        const v = s(/* @__PURE__ */ new Map(), h);
        for (const [w, E] of S)
          v.set(f(w), f(E));
        return v;
      }
      case Sx: {
        const v = s(/* @__PURE__ */ new Set(), h);
        for (const w of S)
          v.add(f(w));
        return v;
      }
      case fT: {
        const { name: v, message: w } = S;
        return s(new Yw[v](w), h);
      }
      case dT:
        return s(BigInt(S), h);
      case "BigInt":
        return s(Object(BigInt(S)), h);
    }
    return s(new Yw[y](S), h);
  };
  return f;
}, Ww = (r) => v8(/* @__PURE__ */ new Map(), r)(0), Sd = "", { toString: m8 } = {}, { keys: y8 } = Object, Rh = (r) => {
  const o = typeof r;
  if (o !== "object" || !r)
    return [Zy, o];
  const s = m8.call(r).slice(8, -1);
  switch (s) {
    case "Array":
      return [Vy, Sd];
    case "Object":
      return [$y, Sd];
    case "Date":
      return [mx, Sd];
    case "RegExp":
      return [yx, Sd];
    case "Map":
      return [gx, Sd];
    case "Set":
      return [Sx, Sd];
  }
  return s.includes("Array") ? [Vy, s] : s.includes("Error") ? [fT, s] : [$y, s];
}, zy = ([r, o]) => r === Zy && (o === "function" || o === "symbol"), g8 = (r, o, s, f) => {
  const h = (S, v) => {
    const w = f.push(S) - 1;
    return s.set(v, w), w;
  }, y = (S) => {
    if (s.has(S))
      return s.get(S);
    let [v, w] = Rh(S);
    switch (v) {
      case Zy: {
        let R = S;
        switch (w) {
          case "bigint":
            v = dT, R = S.toString();
            break;
          case "function":
          case "symbol":
            if (r)
              throw new TypeError("unable to serialize " + w);
            R = null;
            break;
          case "undefined":
            return h([cT], S);
        }
        return h([v, R], S);
      }
      case Vy: {
        if (w)
          return h([w, [...S]], S);
        const R = [], D = h([v, R], S);
        for (const N of S)
          R.push(y(N));
        return D;
      }
      case $y: {
        if (w)
          switch (w) {
            case "BigInt":
              return h([w, S.toString()], S);
            case "Boolean":
            case "Number":
            case "String":
              return h([w, S.valueOf()], S);
          }
        if (o && "toJSON" in S)
          return y(S.toJSON());
        const R = [], D = h([v, R], S);
        for (const N of y8(S))
          (r || !zy(Rh(S[N]))) && R.push([y(N), y(S[N])]);
        return D;
      }
      case mx:
        return h([v, S.toISOString()], S);
      case yx: {
        const { source: R, flags: D } = S;
        return h([v, { source: R, flags: D }], S);
      }
      case gx: {
        const R = [], D = h([v, R], S);
        for (const [N, M] of S)
          (r || !(zy(Rh(N)) || zy(Rh(M)))) && R.push([y(N), y(M)]);
        return D;
      }
      case Sx: {
        const R = [], D = h([v, R], S);
        for (const N of S)
          (r || !zy(Rh(N))) && R.push(y(N));
        return D;
      }
    }
    const { message: E } = S;
    return h([v, { name: w, message: E }], S);
  };
  return y;
}, Qw = (r, { json: o, lossy: s } = {}) => {
  const f = [];
  return g8(!(o || s), !!o, /* @__PURE__ */ new Map(), f)(r), f;
}, Yy = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (r, o) => o && ("json" in o || "lossy" in o) ? Ww(Qw(r, o)) : structuredClone(r)
) : (r, o) => Ww(Qw(r, o));
function S8(r, o) {
  const s = [{ type: "text", value: "" }];
  return o > 1 && s.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(o) }]
  }), s;
}
function x8(r, o) {
  return "Back to reference " + (r + 1) + (o > 1 ? "-" + o : "");
}
function b8(r) {
  const o = typeof r.options.clobberPrefix == "string" ? r.options.clobberPrefix : "user-content-", s = r.options.footnoteBackContent || S8, f = r.options.footnoteBackLabel || x8, h = r.options.footnoteLabel || "Footnotes", y = r.options.footnoteLabelTagName || "h2", S = r.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, v = [];
  let w = -1;
  for (; ++w < r.footnoteOrder.length; ) {
    const E = r.footnoteById.get(r.footnoteOrder[w]);
    if (!E)
      continue;
    const R = r.all(E), D = String(E.identifier).toUpperCase(), N = kd(D.toLowerCase());
    let M = 0;
    const F = [], $ = r.footnoteCounts.get(D);
    for (; $ !== void 0 && ++M <= $; ) {
      F.length > 0 && F.push({ type: "text", value: " " });
      let se = typeof s == "string" ? s : s(w, M);
      typeof se == "string" && (se = { type: "text", value: se }), F.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + o + "fnref-" + N + (M > 1 ? "-" + M : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof f == "string" ? f : f(w, M),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(se) ? se : [se]
      });
    }
    const ce = R[R.length - 1];
    if (ce && ce.type === "element" && ce.tagName === "p") {
      const se = ce.children[ce.children.length - 1];
      se && se.type === "text" ? se.value += " " : ce.children.push({ type: "text", value: " " }), ce.children.push(...F);
    } else
      R.push(...F);
    const X = {
      type: "element",
      tagName: "li",
      properties: { id: o + "fn-" + N },
      children: r.wrap(R, !0)
    };
    r.patch(E, X), v.push(X);
  }
  if (v.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: y,
          properties: {
            ...Yy(S),
            id: "footnote-label"
          },
          children: [{ type: "text", value: h }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: r.wrap(v, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const pT = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(r) {
    if (r == null)
      return k8;
    if (typeof r == "function")
      return eg(r);
    if (typeof r == "object")
      return Array.isArray(r) ? E8(r) : C8(r);
    if (typeof r == "string")
      return w8(r);
    throw new Error("Expected function, string, or object as test");
  }
);
function E8(r) {
  const o = [];
  let s = -1;
  for (; ++s < r.length; )
    o[s] = pT(r[s]);
  return eg(f);
  function f(...h) {
    let y = -1;
    for (; ++y < o.length; )
      if (o[y].apply(this, h))
        return !0;
    return !1;
  }
}
function C8(r) {
  const o = (
    /** @type {Record<string, unknown>} */
    r
  );
  return eg(s);
  function s(f) {
    const h = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      f
    );
    let y;
    for (y in r)
      if (h[y] !== o[y])
        return !1;
    return !0;
  }
}
function w8(r) {
  return eg(o);
  function o(s) {
    return s && s.type === r;
  }
}
function eg(r) {
  return o;
  function o(s, f, h) {
    return !!(T8(s) && r.call(
      this,
      s,
      typeof f == "number" ? f : void 0,
      h || void 0
    ));
  }
}
function k8() {
  return !0;
}
function T8(r) {
  return r !== null && typeof r == "object" && "type" in r;
}
const hT = [], R8 = !0, qw = !1, _8 = "skip";
function D8(r, o, s, f) {
  let h;
  typeof o == "function" && typeof s != "function" ? (f = s, s = o) : h = o;
  const y = pT(h), S = f ? -1 : 1;
  v(r, void 0, [])();
  function v(w, E, R) {
    const D = (
      /** @type {Record<string, unknown>} */
      w && typeof w == "object" ? w : {}
    );
    if (typeof D.type == "string") {
      const M = (
        // `hast`
        typeof D.tagName == "string" ? D.tagName : (
          // `xast`
          typeof D.name == "string" ? D.name : void 0
        )
      );
      Object.defineProperty(N, "name", {
        value: "node (" + (w.type + (M ? "<" + M + ">" : "")) + ")"
      });
    }
    return N;
    function N() {
      let M = hT, F, $, ce;
      if ((!o || y(w, E, R[R.length - 1] || void 0)) && (M = O8(s(w, R)), M[0] === qw))
        return M;
      if ("children" in w && w.children) {
        const X = (
          /** @type {UnistParent} */
          w
        );
        if (X.children && M[0] !== _8)
          for ($ = (f ? X.children.length : -1) + S, ce = R.concat(X); $ > -1 && $ < X.children.length; ) {
            const se = X.children[$];
            if (F = v(se, $, ce)(), F[0] === qw)
              return F;
            $ = typeof F[1] == "number" ? F[1] : $ + S;
          }
      }
      return M;
    }
  }
}
function O8(r) {
  return Array.isArray(r) ? r : typeof r == "number" ? [R8, r] : r == null ? hT : [r];
}
function vT(r, o, s, f) {
  let h, y, S;
  typeof o == "function" && typeof s != "function" ? (y = void 0, S = o, h = s) : (y = o, S = s, h = f), D8(r, y, v, h);
  function v(w, E) {
    const R = E[E.length - 1], D = R ? R.children.indexOf(w) : void 0;
    return S(w, D, R);
  }
}
const ZS = {}.hasOwnProperty, M8 = {};
function N8(r, o) {
  const s = o || M8, f = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), S = { ...h8, ...s.handlers }, v = {
    all: E,
    applyData: z8,
    definitionById: f,
    footnoteById: h,
    footnoteCounts: y,
    footnoteOrder: [],
    handlers: S,
    one: w,
    options: s,
    patch: L8,
    wrap: j8
  };
  return vT(r, function(R) {
    if (R.type === "definition" || R.type === "footnoteDefinition") {
      const D = R.type === "definition" ? f : h, N = String(R.identifier).toUpperCase();
      D.has(N) || D.set(N, R);
    }
  }), v;
  function w(R, D) {
    const N = R.type, M = v.handlers[N];
    if (ZS.call(v.handlers, N) && M)
      return M(v, R, D);
    if (v.options.passThrough && v.options.passThrough.includes(N)) {
      if ("children" in R) {
        const { children: $, ...ce } = R, X = Yy(ce);
        return X.children = v.all(R), X;
      }
      return Yy(R);
    }
    return (v.options.unknownHandler || A8)(v, R, D);
  }
  function E(R) {
    const D = [];
    if ("children" in R) {
      const N = R.children;
      let M = -1;
      for (; ++M < N.length; ) {
        const F = v.one(N[M], R);
        if (F) {
          if (M && N[M - 1].type === "break" && (!Array.isArray(F) && F.type === "text" && (F.value = Gw(F.value)), !Array.isArray(F) && F.type === "element")) {
            const $ = F.children[0];
            $ && $.type === "text" && ($.value = Gw($.value));
          }
          Array.isArray(F) ? D.push(...F) : D.push(F);
        }
      }
    }
    return D;
  }
}
function L8(r, o) {
  r.position && (o.position = h3(r));
}
function z8(r, o) {
  let s = o;
  if (r && r.data) {
    const f = r.data.hName, h = r.data.hChildren, y = r.data.hProperties;
    if (typeof f == "string")
      if (s.type === "element")
        s.tagName = f;
      else {
        const S = "children" in s ? s.children : [s];
        s = { type: "element", tagName: f, properties: {}, children: S };
      }
    s.type === "element" && y && Object.assign(s.properties, Yy(y)), "children" in s && s.children && h !== null && h !== void 0 && (s.children = h);
  }
  return s;
}
function A8(r, o) {
  const s = o.data || {}, f = "value" in o && !(ZS.call(s, "hProperties") || ZS.call(s, "hChildren")) ? { type: "text", value: o.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: r.all(o)
  };
  return r.patch(o, f), r.applyData(o, f);
}
function j8(r, o) {
  const s = [];
  let f = -1;
  for (o && s.push({ type: "text", value: `
` }); ++f < r.length; )
    f && s.push({ type: "text", value: `
` }), s.push(r[f]);
  return o && r.length > 0 && s.push({ type: "text", value: `
` }), s;
}
function Gw(r) {
  let o = 0, s = r.charCodeAt(o);
  for (; s === 9 || s === 32; )
    o++, s = r.charCodeAt(o);
  return r.slice(o);
}
function Xw(r, o) {
  const s = N8(r, o), f = s.one(r, void 0), h = b8(s), y = Array.isArray(f) ? { type: "root", children: f } : f || { type: "root", children: [] };
  return h && y.children.push({ type: "text", value: `
` }, h), y;
}
function U8(r, o) {
  return r && "run" in r ? async function(s, f) {
    const h = (
      /** @type {HastRoot} */
      Xw(s, { file: f, ...o })
    );
    await r.run(h, f);
  } : function(s, f) {
    return (
      /** @type {HastRoot} */
      Xw(s, { file: f, ...o || r })
    );
  };
}
function Kw(r) {
  if (r)
    throw r;
}
var Iy = Object.prototype.hasOwnProperty, mT = Object.prototype.toString, Jw = Object.defineProperty, Zw = Object.getOwnPropertyDescriptor, ek = function(o) {
  return typeof Array.isArray == "function" ? Array.isArray(o) : mT.call(o) === "[object Array]";
}, tk = function(o) {
  if (!o || mT.call(o) !== "[object Object]")
    return !1;
  var s = Iy.call(o, "constructor"), f = o.constructor && o.constructor.prototype && Iy.call(o.constructor.prototype, "isPrototypeOf");
  if (o.constructor && !s && !f)
    return !1;
  var h;
  for (h in o)
    ;
  return typeof h > "u" || Iy.call(o, h);
}, nk = function(o, s) {
  Jw && s.name === "__proto__" ? Jw(o, s.name, {
    enumerable: !0,
    configurable: !0,
    value: s.newValue,
    writable: !0
  }) : o[s.name] = s.newValue;
}, rk = function(o, s) {
  if (s === "__proto__")
    if (Iy.call(o, s)) {
      if (Zw)
        return Zw(o, s).value;
    } else
      return;
  return o[s];
}, F8 = function r() {
  var o, s, f, h, y, S, v = arguments[0], w = 1, E = arguments.length, R = !1;
  for (typeof v == "boolean" && (R = v, v = arguments[1] || {}, w = 2), (v == null || typeof v != "object" && typeof v != "function") && (v = {}); w < E; ++w)
    if (o = arguments[w], o != null)
      for (s in o)
        f = rk(v, s), h = rk(o, s), v !== h && (R && h && (tk(h) || (y = ek(h))) ? (y ? (y = !1, S = f && ek(f) ? f : []) : S = f && tk(f) ? f : {}, nk(v, { name: s, newValue: r(R, S, h) })) : typeof h < "u" && nk(v, { name: s, newValue: h }));
  return v;
};
const zS = /* @__PURE__ */ Ok(F8);
function ex(r) {
  if (typeof r != "object" || r === null)
    return !1;
  const o = Object.getPrototypeOf(r);
  return (o === null || o === Object.prototype || Object.getPrototypeOf(o) === null) && !(Symbol.toStringTag in r) && !(Symbol.iterator in r);
}
function P8() {
  const r = [], o = { run: s, use: f };
  return o;
  function s(...h) {
    let y = -1;
    const S = h.pop();
    if (typeof S != "function")
      throw new TypeError("Expected function as last argument, not " + S);
    v(null, ...h);
    function v(w, ...E) {
      const R = r[++y];
      let D = -1;
      if (w) {
        S(w);
        return;
      }
      for (; ++D < h.length; )
        (E[D] === null || E[D] === void 0) && (E[D] = h[D]);
      h = E, R ? H8(R, v)(...E) : S(null, ...E);
    }
  }
  function f(h) {
    if (typeof h != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + h
      );
    return r.push(h), o;
  }
}
function H8(r, o) {
  let s;
  return f;
  function f(...S) {
    const v = r.length > S.length;
    let w;
    v && S.push(h);
    try {
      w = r.apply(this, S);
    } catch (E) {
      const R = (
        /** @type {Error} */
        E
      );
      if (v && s)
        throw R;
      return h(R);
    }
    v || (w && w.then && typeof w.then == "function" ? w.then(y, h) : w instanceof Error ? h(w) : y(w));
  }
  function h(S, ...v) {
    s || (s = !0, o(S, ...v));
  }
  function y(S) {
    h(null, S);
  }
}
const po = { basename: I8, dirname: B8, extname: V8, join: $8, sep: "/" };
function I8(r, o) {
  if (o !== void 0 && typeof o != "string")
    throw new TypeError('"ext" argument must be a string');
  Ph(r);
  let s = 0, f = -1, h = r.length, y;
  if (o === void 0 || o.length === 0 || o.length > r.length) {
    for (; h--; )
      if (r.codePointAt(h) === 47) {
        if (y) {
          s = h + 1;
          break;
        }
      } else
        f < 0 && (y = !0, f = h + 1);
    return f < 0 ? "" : r.slice(s, f);
  }
  if (o === r)
    return "";
  let S = -1, v = o.length - 1;
  for (; h--; )
    if (r.codePointAt(h) === 47) {
      if (y) {
        s = h + 1;
        break;
      }
    } else
      S < 0 && (y = !0, S = h + 1), v > -1 && (r.codePointAt(h) === o.codePointAt(v--) ? v < 0 && (f = h) : (v = -1, f = S));
  return s === f ? f = S : f < 0 && (f = r.length), r.slice(s, f);
}
function B8(r) {
  if (Ph(r), r.length === 0)
    return ".";
  let o = -1, s = r.length, f;
  for (; --s; )
    if (r.codePointAt(s) === 47) {
      if (f) {
        o = s;
        break;
      }
    } else
      f || (f = !0);
  return o < 0 ? r.codePointAt(0) === 47 ? "/" : "." : o === 1 && r.codePointAt(0) === 47 ? "//" : r.slice(0, o);
}
function V8(r) {
  Ph(r);
  let o = r.length, s = -1, f = 0, h = -1, y = 0, S;
  for (; o--; ) {
    const v = r.codePointAt(o);
    if (v === 47) {
      if (S) {
        f = o + 1;
        break;
      }
      continue;
    }
    s < 0 && (S = !0, s = o + 1), v === 46 ? h < 0 ? h = o : y !== 1 && (y = 1) : h > -1 && (y = -1);
  }
  return h < 0 || s < 0 || // We saw a non-dot character immediately before the dot.
  y === 0 || // The (right-most) trimmed path component is exactly `..`.
  y === 1 && h === s - 1 && h === f + 1 ? "" : r.slice(h, s);
}
function $8(...r) {
  let o = -1, s;
  for (; ++o < r.length; )
    Ph(r[o]), r[o] && (s = s === void 0 ? r[o] : s + "/" + r[o]);
  return s === void 0 ? "." : Y8(s);
}
function Y8(r) {
  Ph(r);
  const o = r.codePointAt(0) === 47;
  let s = W8(r, !o);
  return s.length === 0 && !o && (s = "."), s.length > 0 && r.codePointAt(r.length - 1) === 47 && (s += "/"), o ? "/" + s : s;
}
function W8(r, o) {
  let s = "", f = 0, h = -1, y = 0, S = -1, v, w;
  for (; ++S <= r.length; ) {
    if (S < r.length)
      v = r.codePointAt(S);
    else {
      if (v === 47)
        break;
      v = 47;
    }
    if (v === 47) {
      if (!(h === S - 1 || y === 1))
        if (h !== S - 1 && y === 2) {
          if (s.length < 2 || f !== 2 || s.codePointAt(s.length - 1) !== 46 || s.codePointAt(s.length - 2) !== 46) {
            if (s.length > 2) {
              if (w = s.lastIndexOf("/"), w !== s.length - 1) {
                w < 0 ? (s = "", f = 0) : (s = s.slice(0, w), f = s.length - 1 - s.lastIndexOf("/")), h = S, y = 0;
                continue;
              }
            } else if (s.length > 0) {
              s = "", f = 0, h = S, y = 0;
              continue;
            }
          }
          o && (s = s.length > 0 ? s + "/.." : "..", f = 2);
        } else
          s.length > 0 ? s += "/" + r.slice(h + 1, S) : s = r.slice(h + 1, S), f = S - h - 1;
      h = S, y = 0;
    } else
      v === 46 && y > -1 ? y++ : y = -1;
  }
  return s;
}
function Ph(r) {
  if (typeof r != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(r)
    );
}
const Q8 = { cwd: q8 };
function q8() {
  return "/";
}
function tx(r) {
  return !!(r !== null && typeof r == "object" && "href" in r && r.href && "protocol" in r && r.protocol && // @ts-expect-error: indexing is fine.
  r.auth === void 0);
}
function G8(r) {
  if (typeof r == "string")
    r = new URL(r);
  else if (!tx(r)) {
    const o = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + r + "`"
    );
    throw o.code = "ERR_INVALID_ARG_TYPE", o;
  }
  if (r.protocol !== "file:") {
    const o = new TypeError("The URL must be of scheme file");
    throw o.code = "ERR_INVALID_URL_SCHEME", o;
  }
  return X8(r);
}
function X8(r) {
  if (r.hostname !== "") {
    const f = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw f.code = "ERR_INVALID_FILE_URL_HOST", f;
  }
  const o = r.pathname;
  let s = -1;
  for (; ++s < o.length; )
    if (o.codePointAt(s) === 37 && o.codePointAt(s + 1) === 50) {
      const f = o.codePointAt(s + 2);
      if (f === 70 || f === 102) {
        const h = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw h.code = "ERR_INVALID_FILE_URL_PATH", h;
      }
    }
  return decodeURIComponent(o);
}
const AS = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class yT {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(o) {
    let s;
    o ? tx(o) ? s = { path: o } : typeof o == "string" || K8(o) ? s = { value: o } : s = o : s = {}, this.cwd = Q8.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let f = -1;
    for (; ++f < AS.length; ) {
      const y = AS[f];
      y in s && s[y] !== void 0 && s[y] !== null && (this[y] = y === "history" ? [...s[y]] : s[y]);
    }
    let h;
    for (h in s)
      AS.includes(h) || (this[h] = s[h]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? po.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(o) {
    US(o, "basename"), jS(o, "basename"), this.path = po.join(this.dirname || "", o);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? po.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(o) {
    ik(this.basename, "dirname"), this.path = po.join(o || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? po.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(o) {
    if (jS(o, "extname"), ik(this.dirname, "extname"), o) {
      if (o.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (o.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = po.join(this.dirname, this.stem + (o || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(o) {
    tx(o) && (o = G8(o)), US(o, "path"), this.path !== o && this.history.push(o);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? po.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(o) {
    US(o, "stem"), jS(o, "stem"), this.path = po.join(this.dirname || "", o + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(o, s, f) {
    const h = this.message(o, s, f);
    throw h.fatal = !0, h;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(o, s, f) {
    const h = this.message(o, s, f);
    return h.fatal = void 0, h;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(o, s, f) {
    const h = new bi(
      // @ts-expect-error: the overloads are fine.
      o,
      s,
      f
    );
    return this.path && (h.name = this.path + ":" + h.name, h.file = this.path), h.fatal = !1, this.messages.push(h), h;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(o) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(o || void 0).decode(this.value);
  }
}
function jS(r, o) {
  if (r && r.includes(po.sep))
    throw new Error(
      "`" + o + "` cannot be a path: did not expect `" + po.sep + "`"
    );
}
function US(r, o) {
  if (!r)
    throw new Error("`" + o + "` cannot be empty");
}
function ik(r, o) {
  if (!r)
    throw new Error("Setting `" + o + "` requires `path` to be set too");
}
function K8(r) {
  return !!(r && typeof r == "object" && "byteLength" in r && "byteOffset" in r);
}
const J8 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(r) {
    const f = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), h = f[r], y = function() {
      return h.apply(y, arguments);
    };
    Object.setPrototypeOf(y, f);
    const S = Object.getOwnPropertyNames(h);
    for (const v of S) {
      const w = Object.getOwnPropertyDescriptor(h, v);
      w && Object.defineProperty(y, v, w);
    }
    return y;
  }
), Z8 = {}.hasOwnProperty;
class xx extends J8 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = P8();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const o = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new xx()
    );
    let s = -1;
    for (; ++s < this.attachers.length; ) {
      const f = this.attachers[s];
      o.use(...f);
    }
    return o.data(zS(!0, {}, this.namespace)), o;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * >  **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * >  **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(o, s) {
    return typeof o == "string" ? arguments.length === 2 ? (HS("data", this.frozen), this.namespace[o] = s, this) : Z8.call(this.namespace, o) && this.namespace[o] || void 0 : o ? (HS("data", this.frozen), this.namespace = o, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const o = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [s, ...f] = this.attachers[this.freezeIndex];
      if (f[0] === !1)
        continue;
      f[0] === !0 && (f[0] = void 0);
      const h = s.call(o, ...f);
      typeof h == "function" && this.transformers.use(h);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * >  **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(o) {
    this.freeze();
    const s = Ay(o), f = this.parser || this.Parser;
    return FS("parse", f), f(String(s), s);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * >  **Note**: `process` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(o, s) {
    const f = this;
    return this.freeze(), FS("process", this.parser || this.Parser), PS("process", this.compiler || this.Compiler), s ? h(void 0, s) : new Promise(h);
    function h(y, S) {
      const v = Ay(o), w = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        f.parse(v)
      );
      f.run(w, v, function(R, D, N) {
        if (R || !D || !N)
          return E(R);
        const M = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          D
        ), F = f.stringify(M, N);
        n6(F) ? N.value = F : N.result = F, E(
          R,
          /** @type {VFileWithOutput<CompileResult>} */
          N
        );
      });
      function E(R, D) {
        R || !D ? S(R) : y ? y(D) : s(void 0, D);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(o) {
    let s = !1, f;
    return this.freeze(), FS("processSync", this.parser || this.Parser), PS("processSync", this.compiler || this.Compiler), this.process(o, h), lk("processSync", "process", s), f;
    function h(y, S) {
      s = !0, Kw(y), f = S;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * >  **Note**: `run` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(o, s, f) {
    ak(o), this.freeze();
    const h = this.transformers;
    return !f && typeof s == "function" && (f = s, s = void 0), f ? y(void 0, f) : new Promise(y);
    function y(S, v) {
      const w = Ay(s);
      h.run(o, w, E);
      function E(R, D, N) {
        const M = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          D || o
        );
        R ? v(R) : S ? S(M) : f(void 0, M, N);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(o, s) {
    let f = !1, h;
    return this.run(o, s, y), lk("runSync", "run", f), h;
    function y(S, v) {
      Kw(S), h = v, f = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * >  **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(o, s) {
    this.freeze();
    const f = Ay(s), h = this.compiler || this.Compiler;
    return PS("stringify", h), ak(o), h(o, f);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * >  **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(o, ...s) {
    const f = this.attachers, h = this.namespace;
    if (HS("use", this.frozen), o != null)
      if (typeof o == "function")
        w(o, s);
      else if (typeof o == "object")
        Array.isArray(o) ? v(o) : S(o);
      else
        throw new TypeError("Expected usable value, not `" + o + "`");
    return this;
    function y(E) {
      if (typeof E == "function")
        w(E, []);
      else if (typeof E == "object")
        if (Array.isArray(E)) {
          const [R, ...D] = (
            /** @type {PluginTuple<Array<unknown>>} */
            E
          );
          w(R, D);
        } else
          S(E);
      else
        throw new TypeError("Expected usable value, not `" + E + "`");
    }
    function S(E) {
      if (!("plugins" in E) && !("settings" in E))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      v(E.plugins), E.settings && (h.settings = zS(!0, h.settings, E.settings));
    }
    function v(E) {
      let R = -1;
      if (E != null)
        if (Array.isArray(E))
          for (; ++R < E.length; ) {
            const D = E[R];
            y(D);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + E + "`");
    }
    function w(E, R) {
      let D = -1, N = -1;
      for (; ++D < f.length; )
        if (f[D][0] === E) {
          N = D;
          break;
        }
      if (N === -1)
        f.push([E, ...R]);
      else if (R.length > 0) {
        let [M, ...F] = R;
        const $ = f[N][1];
        ex($) && ex(M) && (M = zS(!0, $, M)), f[N] = [E, M, ...F];
      }
    }
  }
}
const e6 = new xx().freeze();
function FS(r, o) {
  if (typeof o != "function")
    throw new TypeError("Cannot `" + r + "` without `parser`");
}
function PS(r, o) {
  if (typeof o != "function")
    throw new TypeError("Cannot `" + r + "` without `compiler`");
}
function HS(r, o) {
  if (o)
    throw new Error(
      "Cannot call `" + r + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function ak(r) {
  if (!ex(r) || typeof r.type != "string")
    throw new TypeError("Expected node, got `" + r + "`");
}
function lk(r, o, s) {
  if (!s)
    throw new Error(
      "`" + r + "` finished async. Use `" + o + "` instead"
    );
}
function Ay(r) {
  return t6(r) ? r : new yT(r);
}
function t6(r) {
  return !!(r && typeof r == "object" && "message" in r && "messages" in r);
}
function n6(r) {
  return typeof r == "string" || r6(r);
}
function r6(r) {
  return !!(r && typeof r == "object" && "byteLength" in r && "byteOffset" in r);
}
const i6 = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", ok = [], uk = { allowDangerousHtml: !0 }, a6 = /^(https?|ircs?|mailto|xmpp)$/i, l6 = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function o6(r) {
  const o = r.allowedElements, s = r.allowElement, f = r.children || "", h = r.className, y = r.components, S = r.disallowedElements, v = r.rehypePlugins || ok, w = r.remarkPlugins || ok, E = r.remarkRehypeOptions ? { ...r.remarkRehypeOptions, ...uk } : uk, R = r.skipHtml, D = r.unwrapDisallowed, N = r.urlTransform || u6, M = e6().use(BL).use(w).use(U8, E).use(v), F = new yT();
  typeof f == "string" && (F.value = f);
  for (const se of l6)
    Object.hasOwn(r, se.from) && ("" + se.from + (se.to ? "use `" + se.to + "` instead" : "remove it") + i6 + se.id, void 0);
  const $ = M.parse(F);
  let ce = M.runSync($, F);
  return h && (ce = {
    type: "element",
    tagName: "div",
    properties: { className: h },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      ce.type === "root" ? ce.children : [ce]
    )
  }), vT(ce, X), x3(ce, {
    Fragment: V.Fragment,
    components: y,
    ignoreInvalidStyle: !0,
    jsx: V.jsx,
    jsxs: V.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function X(se, te, Se) {
    if (se.type === "raw" && Se && typeof te == "number")
      return R ? Se.children.splice(te, 1) : Se.children[te] = { type: "text", value: se.value }, te;
    if (se.type === "element") {
      let Ce;
      for (Ce in MS)
        if (Object.hasOwn(MS, Ce) && Object.hasOwn(se.properties, Ce)) {
          const Y = se.properties[Ce], Oe = MS[Ce];
          (Oe === null || Oe.includes(se.tagName)) && (se.properties[Ce] = N(String(Y || ""), Ce, se));
        }
    }
    if (se.type === "element") {
      let Ce = o ? !o.includes(se.tagName) : S ? S.includes(se.tagName) : !1;
      if (!Ce && s && typeof te == "number" && (Ce = !s(se, te, Se)), Ce && Se && typeof te == "number")
        return D && se.children ? Se.children.splice(te, 1, ...se.children) : Se.children.splice(te, 1), te;
    }
  }
}
function u6(r) {
  const o = r.indexOf(":"), s = r.indexOf("?"), f = r.indexOf("#"), h = r.indexOf("/");
  return (
    // If there is no protocol, its relative.
    o < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    h > -1 && o > h || s > -1 && o > s || f > -1 && o > f || // It is a protocol, it should be allowed.
    a6.test(r.slice(0, o)) ? r : ""
  );
}
function s6({ page: r, setPage: o, max: s }) {
  const f = (h) => {
    o({
      ...r,
      page: h
    });
  };
  return /* @__PURE__ */ V.jsxs("span", { style: { display: "table", marginLeft: "auto", marginRight: "auto" }, children: [
    /* @__PURE__ */ V.jsx(
      "button",
      {
        className: "clear ml",
        onClick: () => f(r.page - 1),
        disabled: r.page === 1,
        children: ""
      }
    ),
    /* @__PURE__ */ V.jsxs("span", { className: "ml mr", children: [
      r.page,
      " of ",
      s
    ] }),
    /* @__PURE__ */ V.jsx(
      "button",
      {
        className: "clear",
        onClick: () => f(r.page + 1),
        disabled: r.page === s,
        children: ""
      }
    )
  ] });
}
const sk = (r) => ({
  start: (r.page - 1) * r.size,
  end: r.page * r.size
});
function c6({
  data: r,
  header: o,
  idVariable: s,
  selected: f = void 0,
  clickRow: h = void 0,
  hoverRow: y = void 0,
  ...S
}) {
  const [v, w] = ut.useState({ page: 1, size: 15 }), [E, R] = ut.useState({ page: 1, size: 1e3 }), [D, N] = ut.useState(""), M = sk(E), F = Object.keys(r), $ = F.slice(M.start, M.end), ce = Math.ceil(F.length / E.size), X = F.filter((de) => typeof r[de][0] == "string"), se = r[F[0]].map((de, ge) => ge), te = se.map(
    (de) => X.map((ge) => r[ge][de]).reduce((ge, Qe) => ge + " " + Qe)
  ), Se = se.filter((de) => te[de].toLowerCase().includes(D.toLowerCase())), Ce = Math.ceil(Se.length / v.size), Y = (de) => /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsxs("b", { children: [
      " ",
      de,
      " "
    ] }),
    /* @__PURE__ */ V.jsx("br", {}),
    /* @__PURE__ */ V.jsx("i", { children: typeof r[de][0] })
  ] }), Oe = [s, ...$.filter((de) => de !== s)], ze = /* @__PURE__ */ V.jsx("thead", { children: /* @__PURE__ */ V.jsx("tr", { children: Oe.map((de, ge) => ge == 0 ? /* @__PURE__ */ V.jsx("th", { className: "results-table__cell", children: Y(de) }, de) : /* @__PURE__ */ V.jsx("td", { className: "results-table__cell", children: Y(de) }, de)) }) }), it = sk(v), lt = Se.slice(it.start, it.end).map((de) => {
    const ge = r[s][de] === f ? "results-table__cell results-table__cell--selected" : "results-table__cell", Qe = [/* @__PURE__ */ V.jsx(
      "th",
      {
        className: ge,
        children: r[s][de]
      },
      s
    )].concat(
      $.filter((Fe) => Fe !== s).map((Fe) => /* @__PURE__ */ V.jsx("td", { className: ge, children: r[Fe][de] }, Fe))
    );
    return /* @__PURE__ */ V.jsx(
      "tr",
      {
        className: "results-table__row",
        onMouseOver: () => y(r[s][de].toString()),
        onMouseLeave: () => y(null),
        onClick: () => h(r[s][de].toString()),
        children: Qe
      },
      de
    );
  }), he = (de) => {
    const ge = de.target.value;
    N(ge), w({ ...v, page: 1 });
  }, ne = (de) => {
    if (de.key === "Enter") {
      const ge = Se[0], Qe = r[s][ge].toString();
      h(Qe);
    }
  }, we = v.size < se.length || ce > 1;
  return /* @__PURE__ */ V.jsxs("div", { style: { overflowX: "hidden" }, ...S, children: [
    we && /* @__PURE__ */ V.jsx("div", { className: "card__header", children: /* @__PURE__ */ V.jsx("div", { className: "card__menu", children: /* @__PURE__ */ V.jsx(
      "input",
      {
        onChange: he,
        placeholder: "Search...",
        onKeyDown: ne,
        style: { display: "inline-block", width: "100%" }
      }
    ) }) }),
    /* @__PURE__ */ V.jsx("div", { className: "table-container", children: /* @__PURE__ */ V.jsxs("table", { className: "results-table", children: [
      o && ze,
      /* @__PURE__ */ V.jsx("tbody", { children: lt })
    ] }) }),
    /* @__PURE__ */ V.jsx(s6, { page: v, setPage: w, max: Ce })
  ] });
}
function f6({ tabs: r }) {
  const [o, s] = ut.useState(Object.keys(r)[0]);
  return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsx("div", { className: "tabmenu", children: Object.keys(r).map((f) => /* @__PURE__ */ V.jsx(
      "a",
      {
        onClick: () => s(f),
        className: `tabmenu__link ${f === o ? "tabmenu__link--active" : ""}`,
        children: f
      },
      f
    )) }),
    r[o]
  ] });
}
function d6({ xScale: r, yScale: o }) {
  const [s, f] = r.range(), [h, y] = o.range(), S = r.ticks(), v = o.ticks(), w = "black";
  return /* @__PURE__ */ V.jsxs("g", { children: [
    /* @__PURE__ */ V.jsx("line", { x1: s, x2: f, y1: h, y2: h, stroke: w }),
    S.map((E) => {
      const R = r(E);
      return /* @__PURE__ */ V.jsxs("g", { children: [
        /* @__PURE__ */ V.jsx("line", { x1: R, x2: R, y1: h, y2: h + 20, stroke: w }),
        /* @__PURE__ */ V.jsx(
          "text",
          {
            x: R,
            y: h + 50,
            fill: w,
            textAnchor: "middle",
            fontSize: 30,
            children: E
          }
        )
      ] }, E);
    }),
    /* @__PURE__ */ V.jsx("line", { x1: s, x2: s, y1: h, y2: y, stroke: w }),
    v.map((E) => {
      const R = o(E);
      return /* @__PURE__ */ V.jsxs("g", { children: [
        /* @__PURE__ */ V.jsx("line", { x1: s, x2: s - 20, y1: R, y2: R, stroke: w }),
        /* @__PURE__ */ V.jsx(
          "text",
          {
            x: s - 50,
            y: R,
            fill: w,
            textAnchor: "middle",
            fontSize: 30,
            children: E
          }
        )
      ] }, E);
    })
  ] });
}
const bx = ut.createContext(null), Ex = ut.createContext(null), p6 = ut.memo(function({ handler: o, onClick: s, onHover: f }) {
  return /* @__PURE__ */ V.jsx("g", { children: o.points.map(({ x: h, y, id: S }, v) => /* @__PURE__ */ V.jsx(
    "circle",
    {
      className: "point",
      onClick: () => s(S),
      onMouseOver: () => f(S),
      cx: h,
      cy: y,
      r: "10"
    },
    v
  )) });
}), h6 = ({ points: r, geom: o, ...s }) => {
  const { setSelected: f, selectedPoint: h } = ut.useContext(bx), { setHover: y, hoverPoint: S } = ut.useContext(Ex);
  if (o === "point")
    return /* @__PURE__ */ V.jsx("g", { children: r.map(({ x: v, y: w, id: E }, R) => /* @__PURE__ */ V.jsx(
      "circle",
      {
        onClick: () => f(E),
        onMouseOver: () => y(E),
        cx: v,
        cy: w,
        ...s
      },
      R
    )) });
  if (o === "range")
    return /* @__PURE__ */ V.jsx("g", { className: "conf", children: r.map(
      ({ low: v, high: w, y: E }, R) => /* @__PURE__ */ V.jsx("line", { x1: v, x2: w, y1: E, y2: E, strokeWidth: "4", ...s })
    ) }, "confidence-interval");
};
function v6({ handler: r, layers: o, onClick: s, onHover: f }) {
  return /* @__PURE__ */ V.jsxs("svg", { width: "100%", viewBox: r.viewBox, children: [
    /* @__PURE__ */ V.jsx(d6, { xScale: r.scale.x, yScale: r.scale.y }),
    /* @__PURE__ */ V.jsxs("g", { onMouseLeave: () => setHover(null), children: [
      /* @__PURE__ */ V.jsx(p6, { handler: r, onClick: s, onHover: f }),
      o && o.map((h) => /* @__PURE__ */ V.jsx(h6, { ...h }))
    ] })
  ] });
}
function By(r, o) {
  return r == null || o == null ? NaN : r < o ? -1 : r > o ? 1 : r >= o ? 0 : NaN;
}
function m6(r, o) {
  return r == null || o == null ? NaN : o < r ? -1 : o > r ? 1 : o >= r ? 0 : NaN;
}
function gT(r) {
  let o, s, f;
  r.length !== 2 ? (o = By, s = (v, w) => By(r(v), w), f = (v, w) => r(v) - w) : (o = r === By || r === m6 ? r : y6, s = r, f = r);
  function h(v, w, E = 0, R = v.length) {
    if (E < R) {
      if (o(w, w) !== 0)
        return R;
      do {
        const D = E + R >>> 1;
        s(v[D], w) < 0 ? E = D + 1 : R = D;
      } while (E < R);
    }
    return E;
  }
  function y(v, w, E = 0, R = v.length) {
    if (E < R) {
      if (o(w, w) !== 0)
        return R;
      do {
        const D = E + R >>> 1;
        s(v[D], w) <= 0 ? E = D + 1 : R = D;
      } while (E < R);
    }
    return E;
  }
  function S(v, w, E = 0, R = v.length) {
    const D = h(v, w, E, R - 1);
    return D > E && f(v[D - 1], w) > -f(v[D], w) ? D - 1 : D;
  }
  return { left: h, center: S, right: y };
}
function y6() {
  return 0;
}
function g6(r) {
  return r === null ? NaN : +r;
}
const S6 = gT(By), x6 = S6.right;
gT(g6).center;
function jy(r, o) {
  let s, f;
  if (o === void 0)
    for (const h of r)
      h != null && (s === void 0 ? h >= h && (s = f = h) : (s > h && (s = h), f < h && (f = h)));
  else {
    let h = -1;
    for (let y of r)
      (y = o(y, ++h, r)) != null && (s === void 0 ? y >= y && (s = f = y) : (s > y && (s = y), f < y && (f = y)));
  }
  return [s, f];
}
class ck extends Map {
  constructor(o, s = C6) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: s } }), o != null)
      for (const [f, h] of o)
        this.set(f, h);
  }
  get(o) {
    return super.get(fk(this, o));
  }
  has(o) {
    return super.has(fk(this, o));
  }
  set(o, s) {
    return super.set(b6(this, o), s);
  }
  delete(o) {
    return super.delete(E6(this, o));
  }
}
function fk({ _intern: r, _key: o }, s) {
  const f = o(s);
  return r.has(f) ? r.get(f) : s;
}
function b6({ _intern: r, _key: o }, s) {
  const f = o(s);
  return r.has(f) ? r.get(f) : (r.set(f, s), s);
}
function E6({ _intern: r, _key: o }, s) {
  const f = o(s);
  return r.has(f) && (s = r.get(f), r.delete(f)), s;
}
function C6(r) {
  return r !== null && typeof r == "object" ? r.valueOf() : r;
}
const w6 = Math.sqrt(50), k6 = Math.sqrt(10), T6 = Math.sqrt(2);
function Wy(r, o, s) {
  const f = (o - r) / Math.max(0, s), h = Math.floor(Math.log10(f)), y = f / Math.pow(10, h), S = y >= w6 ? 10 : y >= k6 ? 5 : y >= T6 ? 2 : 1;
  let v, w, E;
  return h < 0 ? (E = Math.pow(10, -h) / S, v = Math.round(r * E), w = Math.round(o * E), v / E < r && ++v, w / E > o && --w, E = -E) : (E = Math.pow(10, h) * S, v = Math.round(r / E), w = Math.round(o / E), v * E < r && ++v, w * E > o && --w), w < v && 0.5 <= s && s < 2 ? Wy(r, o, s * 2) : [v, w, E];
}
function R6(r, o, s) {
  if (o = +o, r = +r, s = +s, !(s > 0))
    return [];
  if (r === o)
    return [r];
  const f = o < r, [h, y, S] = f ? Wy(o, r, s) : Wy(r, o, s);
  if (!(y >= h))
    return [];
  const v = y - h + 1, w = new Array(v);
  if (f)
    if (S < 0)
      for (let E = 0; E < v; ++E)
        w[E] = (y - E) / -S;
    else
      for (let E = 0; E < v; ++E)
        w[E] = (y - E) * S;
  else if (S < 0)
    for (let E = 0; E < v; ++E)
      w[E] = (h + E) / -S;
  else
    for (let E = 0; E < v; ++E)
      w[E] = (h + E) * S;
  return w;
}
function nx(r, o, s) {
  return o = +o, r = +r, s = +s, Wy(r, o, s)[2];
}
function _6(r, o, s) {
  o = +o, r = +r, s = +s;
  const f = o < r, h = f ? nx(o, r, s) : nx(r, o, s);
  return (f ? -1 : 1) * (h < 0 ? 1 / -h : h);
}
function D6(r, o, s) {
  r = +r, o = +o, s = (h = arguments.length) < 2 ? (o = r, r = 0, 1) : h < 3 ? 1 : +s;
  for (var f = -1, h = Math.max(0, Math.ceil((o - r) / s)) | 0, y = new Array(h); ++f < h; )
    y[f] = r + f * s;
  return y;
}
function Cx(r, o, s) {
  r.prototype = o.prototype = s, s.constructor = r;
}
function ST(r, o) {
  var s = Object.create(r.prototype);
  for (var f in o)
    s[f] = o[f];
  return s;
}
function Hh() {
}
var Ah = 0.7, Qy = 1 / Ah, Ed = "\\s*([+-]?\\d+)\\s*", jh = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", vo = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", O6 = /^#([0-9a-f]{3,8})$/, M6 = new RegExp(`^rgb\\(${Ed},${Ed},${Ed}\\)$`), N6 = new RegExp(`^rgb\\(${vo},${vo},${vo}\\)$`), L6 = new RegExp(`^rgba\\(${Ed},${Ed},${Ed},${jh}\\)$`), z6 = new RegExp(`^rgba\\(${vo},${vo},${vo},${jh}\\)$`), A6 = new RegExp(`^hsl\\(${jh},${vo},${vo}\\)$`), j6 = new RegExp(`^hsla\\(${jh},${vo},${vo},${jh}\\)$`), dk = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Cx(Hh, Uh, {
  copy(r) {
    return Object.assign(new this.constructor(), this, r);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: pk,
  // Deprecated! Use color.formatHex.
  formatHex: pk,
  formatHex8: U6,
  formatHsl: F6,
  formatRgb: hk,
  toString: hk
});
function pk() {
  return this.rgb().formatHex();
}
function U6() {
  return this.rgb().formatHex8();
}
function F6() {
  return xT(this).formatHsl();
}
function hk() {
  return this.rgb().formatRgb();
}
function Uh(r) {
  var o, s;
  return r = (r + "").trim().toLowerCase(), (o = O6.exec(r)) ? (s = o[1].length, o = parseInt(o[1], 16), s === 6 ? vk(o) : s === 3 ? new la(o >> 8 & 15 | o >> 4 & 240, o >> 4 & 15 | o & 240, (o & 15) << 4 | o & 15, 1) : s === 8 ? Uy(o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, (o & 255) / 255) : s === 4 ? Uy(o >> 12 & 15 | o >> 8 & 240, o >> 8 & 15 | o >> 4 & 240, o >> 4 & 15 | o & 240, ((o & 15) << 4 | o & 15) / 255) : null) : (o = M6.exec(r)) ? new la(o[1], o[2], o[3], 1) : (o = N6.exec(r)) ? new la(o[1] * 255 / 100, o[2] * 255 / 100, o[3] * 255 / 100, 1) : (o = L6.exec(r)) ? Uy(o[1], o[2], o[3], o[4]) : (o = z6.exec(r)) ? Uy(o[1] * 255 / 100, o[2] * 255 / 100, o[3] * 255 / 100, o[4]) : (o = A6.exec(r)) ? gk(o[1], o[2] / 100, o[3] / 100, 1) : (o = j6.exec(r)) ? gk(o[1], o[2] / 100, o[3] / 100, o[4]) : dk.hasOwnProperty(r) ? vk(dk[r]) : r === "transparent" ? new la(NaN, NaN, NaN, 0) : null;
}
function vk(r) {
  return new la(r >> 16 & 255, r >> 8 & 255, r & 255, 1);
}
function Uy(r, o, s, f) {
  return f <= 0 && (r = o = s = NaN), new la(r, o, s, f);
}
function P6(r) {
  return r instanceof Hh || (r = Uh(r)), r ? (r = r.rgb(), new la(r.r, r.g, r.b, r.opacity)) : new la();
}
function rx(r, o, s, f) {
  return arguments.length === 1 ? P6(r) : new la(r, o, s, f ?? 1);
}
function la(r, o, s, f) {
  this.r = +r, this.g = +o, this.b = +s, this.opacity = +f;
}
Cx(la, rx, ST(Hh, {
  brighter(r) {
    return r = r == null ? Qy : Math.pow(Qy, r), new la(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? Ah : Math.pow(Ah, r), new la(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new la(jc(this.r), jc(this.g), jc(this.b), qy(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: mk,
  // Deprecated! Use color.formatHex.
  formatHex: mk,
  formatHex8: H6,
  formatRgb: yk,
  toString: yk
}));
function mk() {
  return `#${Ac(this.r)}${Ac(this.g)}${Ac(this.b)}`;
}
function H6() {
  return `#${Ac(this.r)}${Ac(this.g)}${Ac(this.b)}${Ac((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function yk() {
  const r = qy(this.opacity);
  return `${r === 1 ? "rgb(" : "rgba("}${jc(this.r)}, ${jc(this.g)}, ${jc(this.b)}${r === 1 ? ")" : `, ${r})`}`;
}
function qy(r) {
  return isNaN(r) ? 1 : Math.max(0, Math.min(1, r));
}
function jc(r) {
  return Math.max(0, Math.min(255, Math.round(r) || 0));
}
function Ac(r) {
  return r = jc(r), (r < 16 ? "0" : "") + r.toString(16);
}
function gk(r, o, s, f) {
  return f <= 0 ? r = o = s = NaN : s <= 0 || s >= 1 ? r = o = NaN : o <= 0 && (r = NaN), new Rl(r, o, s, f);
}
function xT(r) {
  if (r instanceof Rl)
    return new Rl(r.h, r.s, r.l, r.opacity);
  if (r instanceof Hh || (r = Uh(r)), !r)
    return new Rl();
  if (r instanceof Rl)
    return r;
  r = r.rgb();
  var o = r.r / 255, s = r.g / 255, f = r.b / 255, h = Math.min(o, s, f), y = Math.max(o, s, f), S = NaN, v = y - h, w = (y + h) / 2;
  return v ? (o === y ? S = (s - f) / v + (s < f) * 6 : s === y ? S = (f - o) / v + 2 : S = (o - s) / v + 4, v /= w < 0.5 ? y + h : 2 - y - h, S *= 60) : v = w > 0 && w < 1 ? 0 : S, new Rl(S, v, w, r.opacity);
}
function I6(r, o, s, f) {
  return arguments.length === 1 ? xT(r) : new Rl(r, o, s, f ?? 1);
}
function Rl(r, o, s, f) {
  this.h = +r, this.s = +o, this.l = +s, this.opacity = +f;
}
Cx(Rl, I6, ST(Hh, {
  brighter(r) {
    return r = r == null ? Qy : Math.pow(Qy, r), new Rl(this.h, this.s, this.l * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? Ah : Math.pow(Ah, r), new Rl(this.h, this.s, this.l * r, this.opacity);
  },
  rgb() {
    var r = this.h % 360 + (this.h < 0) * 360, o = isNaN(r) || isNaN(this.s) ? 0 : this.s, s = this.l, f = s + (s < 0.5 ? s : 1 - s) * o, h = 2 * s - f;
    return new la(
      IS(r >= 240 ? r - 240 : r + 120, h, f),
      IS(r, h, f),
      IS(r < 120 ? r + 240 : r - 120, h, f),
      this.opacity
    );
  },
  clamp() {
    return new Rl(Sk(this.h), Fy(this.s), Fy(this.l), qy(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const r = qy(this.opacity);
    return `${r === 1 ? "hsl(" : "hsla("}${Sk(this.h)}, ${Fy(this.s) * 100}%, ${Fy(this.l) * 100}%${r === 1 ? ")" : `, ${r})`}`;
  }
}));
function Sk(r) {
  return r = (r || 0) % 360, r < 0 ? r + 360 : r;
}
function Fy(r) {
  return Math.max(0, Math.min(1, r || 0));
}
function IS(r, o, s) {
  return (r < 60 ? o + (s - o) * r / 60 : r < 180 ? s : r < 240 ? o + (s - o) * (240 - r) / 60 : o) * 255;
}
const wx = (r) => () => r;
function B6(r, o) {
  return function(s) {
    return r + s * o;
  };
}
function V6(r, o, s) {
  return r = Math.pow(r, s), o = Math.pow(o, s) - r, s = 1 / s, function(f) {
    return Math.pow(r + f * o, s);
  };
}
function $6(r) {
  return (r = +r) == 1 ? bT : function(o, s) {
    return s - o ? V6(o, s, r) : wx(isNaN(o) ? s : o);
  };
}
function bT(r, o) {
  var s = o - r;
  return s ? B6(r, s) : wx(isNaN(r) ? o : r);
}
const xk = function r(o) {
  var s = $6(o);
  function f(h, y) {
    var S = s((h = rx(h)).r, (y = rx(y)).r), v = s(h.g, y.g), w = s(h.b, y.b), E = bT(h.opacity, y.opacity);
    return function(R) {
      return h.r = S(R), h.g = v(R), h.b = w(R), h.opacity = E(R), h + "";
    };
  }
  return f.gamma = r, f;
}(1);
function Y6(r, o) {
  o || (o = []);
  var s = r ? Math.min(o.length, r.length) : 0, f = o.slice(), h;
  return function(y) {
    for (h = 0; h < s; ++h)
      f[h] = r[h] * (1 - y) + o[h] * y;
    return f;
  };
}
function W6(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function Q6(r, o) {
  var s = o ? o.length : 0, f = r ? Math.min(s, r.length) : 0, h = new Array(f), y = new Array(s), S;
  for (S = 0; S < f; ++S)
    h[S] = tg(r[S], o[S]);
  for (; S < s; ++S)
    y[S] = o[S];
  return function(v) {
    for (S = 0; S < f; ++S)
      y[S] = h[S](v);
    return y;
  };
}
function q6(r, o) {
  var s = /* @__PURE__ */ new Date();
  return r = +r, o = +o, function(f) {
    return s.setTime(r * (1 - f) + o * f), s;
  };
}
function Gy(r, o) {
  return r = +r, o = +o, function(s) {
    return r * (1 - s) + o * s;
  };
}
function G6(r, o) {
  var s = {}, f = {}, h;
  (r === null || typeof r != "object") && (r = {}), (o === null || typeof o != "object") && (o = {});
  for (h in o)
    h in r ? s[h] = tg(r[h], o[h]) : f[h] = o[h];
  return function(y) {
    for (h in s)
      f[h] = s[h](y);
    return f;
  };
}
var ix = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, BS = new RegExp(ix.source, "g");
function X6(r) {
  return function() {
    return r;
  };
}
function K6(r) {
  return function(o) {
    return r(o) + "";
  };
}
function J6(r, o) {
  var s = ix.lastIndex = BS.lastIndex = 0, f, h, y, S = -1, v = [], w = [];
  for (r = r + "", o = o + ""; (f = ix.exec(r)) && (h = BS.exec(o)); )
    (y = h.index) > s && (y = o.slice(s, y), v[S] ? v[S] += y : v[++S] = y), (f = f[0]) === (h = h[0]) ? v[S] ? v[S] += h : v[++S] = h : (v[++S] = null, w.push({ i: S, x: Gy(f, h) })), s = BS.lastIndex;
  return s < o.length && (y = o.slice(s), v[S] ? v[S] += y : v[++S] = y), v.length < 2 ? w[0] ? K6(w[0].x) : X6(o) : (o = w.length, function(E) {
    for (var R = 0, D; R < o; ++R)
      v[(D = w[R]).i] = D.x(E);
    return v.join("");
  });
}
function tg(r, o) {
  var s = typeof o, f;
  return o == null || s === "boolean" ? wx(o) : (s === "number" ? Gy : s === "string" ? (f = Uh(o)) ? (o = f, xk) : J6 : o instanceof Uh ? xk : o instanceof Date ? q6 : W6(o) ? Y6 : Array.isArray(o) ? Q6 : typeof o.valueOf != "function" && typeof o.toString != "function" || isNaN(o) ? G6 : Gy)(r, o);
}
function ET(r, o) {
  return r = +r, o = +o, function(s) {
    return Math.round(r * (1 - s) + o * s);
  };
}
function Z6(r) {
  return Math.abs(r = Math.round(r)) >= 1e21 ? r.toLocaleString("en").replace(/,/g, "") : r.toString(10);
}
function Xy(r, o) {
  if ((s = (r = o ? r.toExponential(o - 1) : r.toExponential()).indexOf("e")) < 0)
    return null;
  var s, f = r.slice(0, s);
  return [
    f.length > 1 ? f[0] + f.slice(2) : f,
    +r.slice(s + 1)
  ];
}
function Cd(r) {
  return r = Xy(Math.abs(r)), r ? r[1] : NaN;
}
function ez(r, o) {
  return function(s, f) {
    for (var h = s.length, y = [], S = 0, v = r[0], w = 0; h > 0 && v > 0 && (w + v + 1 > f && (v = Math.max(1, f - w)), y.push(s.substring(h -= v, h + v)), !((w += v + 1) > f)); )
      v = r[S = (S + 1) % r.length];
    return y.reverse().join(o);
  };
}
function tz(r) {
  return function(o) {
    return o.replace(/[0-9]/g, function(s) {
      return r[+s];
    });
  };
}
var nz = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Ky(r) {
  if (!(o = nz.exec(r)))
    throw new Error("invalid format: " + r);
  var o;
  return new kx({
    fill: o[1],
    align: o[2],
    sign: o[3],
    symbol: o[4],
    zero: o[5],
    width: o[6],
    comma: o[7],
    precision: o[8] && o[8].slice(1),
    trim: o[9],
    type: o[10]
  });
}
Ky.prototype = kx.prototype;
function kx(r) {
  this.fill = r.fill === void 0 ? " " : r.fill + "", this.align = r.align === void 0 ? ">" : r.align + "", this.sign = r.sign === void 0 ? "-" : r.sign + "", this.symbol = r.symbol === void 0 ? "" : r.symbol + "", this.zero = !!r.zero, this.width = r.width === void 0 ? void 0 : +r.width, this.comma = !!r.comma, this.precision = r.precision === void 0 ? void 0 : +r.precision, this.trim = !!r.trim, this.type = r.type === void 0 ? "" : r.type + "";
}
kx.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function rz(r) {
  e:
    for (var o = r.length, s = 1, f = -1, h; s < o; ++s)
      switch (r[s]) {
        case ".":
          f = h = s;
          break;
        case "0":
          f === 0 && (f = s), h = s;
          break;
        default:
          if (!+r[s])
            break e;
          f > 0 && (f = 0);
          break;
      }
  return f > 0 ? r.slice(0, f) + r.slice(h + 1) : r;
}
var CT;
function iz(r, o) {
  var s = Xy(r, o);
  if (!s)
    return r + "";
  var f = s[0], h = s[1], y = h - (CT = Math.max(-8, Math.min(8, Math.floor(h / 3))) * 3) + 1, S = f.length;
  return y === S ? f : y > S ? f + new Array(y - S + 1).join("0") : y > 0 ? f.slice(0, y) + "." + f.slice(y) : "0." + new Array(1 - y).join("0") + Xy(r, Math.max(0, o + y - 1))[0];
}
function bk(r, o) {
  var s = Xy(r, o);
  if (!s)
    return r + "";
  var f = s[0], h = s[1];
  return h < 0 ? "0." + new Array(-h).join("0") + f : f.length > h + 1 ? f.slice(0, h + 1) + "." + f.slice(h + 1) : f + new Array(h - f.length + 2).join("0");
}
const Ek = {
  "%": (r, o) => (r * 100).toFixed(o),
  b: (r) => Math.round(r).toString(2),
  c: (r) => r + "",
  d: Z6,
  e: (r, o) => r.toExponential(o),
  f: (r, o) => r.toFixed(o),
  g: (r, o) => r.toPrecision(o),
  o: (r) => Math.round(r).toString(8),
  p: (r, o) => bk(r * 100, o),
  r: bk,
  s: iz,
  X: (r) => Math.round(r).toString(16).toUpperCase(),
  x: (r) => Math.round(r).toString(16)
};
function Ck(r) {
  return r;
}
var wk = Array.prototype.map, kk = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function az(r) {
  var o = r.grouping === void 0 || r.thousands === void 0 ? Ck : ez(wk.call(r.grouping, Number), r.thousands + ""), s = r.currency === void 0 ? "" : r.currency[0] + "", f = r.currency === void 0 ? "" : r.currency[1] + "", h = r.decimal === void 0 ? "." : r.decimal + "", y = r.numerals === void 0 ? Ck : tz(wk.call(r.numerals, String)), S = r.percent === void 0 ? "%" : r.percent + "", v = r.minus === void 0 ? "" : r.minus + "", w = r.nan === void 0 ? "NaN" : r.nan + "";
  function E(D) {
    D = Ky(D);
    var N = D.fill, M = D.align, F = D.sign, $ = D.symbol, ce = D.zero, X = D.width, se = D.comma, te = D.precision, Se = D.trim, Ce = D.type;
    Ce === "n" ? (se = !0, Ce = "g") : Ek[Ce] || (te === void 0 && (te = 12), Se = !0, Ce = "g"), (ce || N === "0" && M === "=") && (ce = !0, N = "0", M = "=");
    var Y = $ === "$" ? s : $ === "#" && /[boxX]/.test(Ce) ? "0" + Ce.toLowerCase() : "", Oe = $ === "$" ? f : /[%p]/.test(Ce) ? S : "", ze = Ek[Ce], it = /[defgprs%]/.test(Ce);
    te = te === void 0 ? 6 : /[gprs]/.test(Ce) ? Math.max(1, Math.min(21, te)) : Math.max(0, Math.min(20, te));
    function lt(he) {
      var ne = Y, we = Oe, de, ge, Qe;
      if (Ce === "c")
        we = ze(he) + we, he = "";
      else {
        he = +he;
        var Fe = he < 0 || 1 / he < 0;
        if (he = isNaN(he) ? w : ze(Math.abs(he), te), Se && (he = rz(he)), Fe && +he == 0 && F !== "+" && (Fe = !1), ne = (Fe ? F === "(" ? F : v : F === "-" || F === "(" ? "" : F) + ne, we = (Ce === "s" ? kk[8 + CT / 3] : "") + we + (Fe && F === "(" ? ")" : ""), it) {
          for (de = -1, ge = he.length; ++de < ge; )
            if (Qe = he.charCodeAt(de), 48 > Qe || Qe > 57) {
              we = (Qe === 46 ? h + he.slice(de + 1) : he.slice(de)) + we, he = he.slice(0, de);
              break;
            }
        }
      }
      se && !ce && (he = o(he, 1 / 0));
      var ae = ne.length + he.length + we.length, _e = ae < X ? new Array(X - ae + 1).join(N) : "";
      switch (se && ce && (he = o(_e + he, _e.length ? X - we.length : 1 / 0), _e = ""), M) {
        case "<":
          he = ne + he + we + _e;
          break;
        case "=":
          he = ne + _e + he + we;
          break;
        case "^":
          he = _e.slice(0, ae = _e.length >> 1) + ne + he + we + _e.slice(ae);
          break;
        default:
          he = _e + ne + he + we;
          break;
      }
      return y(he);
    }
    return lt.toString = function() {
      return D + "";
    }, lt;
  }
  function R(D, N) {
    var M = E((D = Ky(D), D.type = "f", D)), F = Math.max(-8, Math.min(8, Math.floor(Cd(N) / 3))) * 3, $ = Math.pow(10, -F), ce = kk[8 + F / 3];
    return function(X) {
      return M($ * X) + ce;
    };
  }
  return {
    format: E,
    formatPrefix: R
  };
}
var Py, wT, kT;
lz({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function lz(r) {
  return Py = az(r), wT = Py.format, kT = Py.formatPrefix, Py;
}
function oz(r) {
  return Math.max(0, -Cd(Math.abs(r)));
}
function uz(r, o) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Cd(o) / 3))) * 3 - Cd(Math.abs(r)));
}
function sz(r, o) {
  return r = Math.abs(r), o = Math.abs(o) - r, Math.max(0, Cd(o) - Cd(r)) + 1;
}
function Tx(r, o) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(r);
      break;
    default:
      this.range(o).domain(r);
      break;
  }
  return this;
}
function cz(r, o) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof r == "function" ? this.interpolator(r) : this.range(r);
      break;
    }
    default: {
      this.domain(r), typeof o == "function" ? this.interpolator(o) : this.range(o);
      break;
    }
  }
  return this;
}
const Tk = Symbol("implicit");
function Rx() {
  var r = new ck(), o = [], s = [], f = Tk;
  function h(y) {
    let S = r.get(y);
    if (S === void 0) {
      if (f !== Tk)
        return f;
      r.set(y, S = o.push(y) - 1);
    }
    return s[S % s.length];
  }
  return h.domain = function(y) {
    if (!arguments.length)
      return o.slice();
    o = [], r = new ck();
    for (const S of y)
      r.has(S) || r.set(S, o.push(S) - 1);
    return h;
  }, h.range = function(y) {
    return arguments.length ? (s = Array.from(y), h) : s.slice();
  }, h.unknown = function(y) {
    return arguments.length ? (f = y, h) : f;
  }, h.copy = function() {
    return Rx(o, s).unknown(f);
  }, Tx.apply(h, arguments), h;
}
function TT() {
  var r = Rx().unknown(void 0), o = r.domain, s = r.range, f = 0, h = 1, y, S, v = !1, w = 0, E = 0, R = 0.5;
  delete r.unknown;
  function D() {
    var N = o().length, M = h < f, F = M ? h : f, $ = M ? f : h;
    y = ($ - F) / Math.max(1, N - w + E * 2), v && (y = Math.floor(y)), F += ($ - F - y * (N - w)) * R, S = y * (1 - w), v && (F = Math.round(F), S = Math.round(S));
    var ce = D6(N).map(function(X) {
      return F + y * X;
    });
    return s(M ? ce.reverse() : ce);
  }
  return r.domain = function(N) {
    return arguments.length ? (o(N), D()) : o();
  }, r.range = function(N) {
    return arguments.length ? ([f, h] = N, f = +f, h = +h, D()) : [f, h];
  }, r.rangeRound = function(N) {
    return [f, h] = N, f = +f, h = +h, v = !0, D();
  }, r.bandwidth = function() {
    return S;
  }, r.step = function() {
    return y;
  }, r.round = function(N) {
    return arguments.length ? (v = !!N, D()) : v;
  }, r.padding = function(N) {
    return arguments.length ? (w = Math.min(1, E = +N), D()) : w;
  }, r.paddingInner = function(N) {
    return arguments.length ? (w = Math.min(1, N), D()) : w;
  }, r.paddingOuter = function(N) {
    return arguments.length ? (E = +N, D()) : E;
  }, r.align = function(N) {
    return arguments.length ? (R = Math.max(0, Math.min(1, N)), D()) : R;
  }, r.copy = function() {
    return TT(o(), [f, h]).round(v).paddingInner(w).paddingOuter(E).align(R);
  }, Tx.apply(D(), arguments);
}
function fz(r) {
  return function() {
    return r;
  };
}
function dz(r) {
  return +r;
}
var Rk = [0, 1];
function ps(r) {
  return r;
}
function ax(r, o) {
  return (o -= r = +r) ? function(s) {
    return (s - r) / o;
  } : fz(isNaN(o) ? NaN : 0.5);
}
function pz(r, o) {
  var s;
  return r > o && (s = r, r = o, o = s), function(f) {
    return Math.max(r, Math.min(o, f));
  };
}
function hz(r, o, s) {
  var f = r[0], h = r[1], y = o[0], S = o[1];
  return h < f ? (f = ax(h, f), y = s(S, y)) : (f = ax(f, h), y = s(y, S)), function(v) {
    return y(f(v));
  };
}
function vz(r, o, s) {
  var f = Math.min(r.length, o.length) - 1, h = new Array(f), y = new Array(f), S = -1;
  for (r[f] < r[0] && (r = r.slice().reverse(), o = o.slice().reverse()); ++S < f; )
    h[S] = ax(r[S], r[S + 1]), y[S] = s(o[S], o[S + 1]);
  return function(v) {
    var w = x6(r, v, 1, f) - 1;
    return y[w](h[w](v));
  };
}
function mz(r, o) {
  return o.domain(r.domain()).range(r.range()).interpolate(r.interpolate()).clamp(r.clamp()).unknown(r.unknown());
}
function yz() {
  var r = Rk, o = Rk, s = tg, f, h, y, S = ps, v, w, E;
  function R() {
    var N = Math.min(r.length, o.length);
    return S !== ps && (S = pz(r[0], r[N - 1])), v = N > 2 ? vz : hz, w = E = null, D;
  }
  function D(N) {
    return N == null || isNaN(N = +N) ? y : (w || (w = v(r.map(f), o, s)))(f(S(N)));
  }
  return D.invert = function(N) {
    return S(h((E || (E = v(o, r.map(f), Gy)))(N)));
  }, D.domain = function(N) {
    return arguments.length ? (r = Array.from(N, dz), R()) : r.slice();
  }, D.range = function(N) {
    return arguments.length ? (o = Array.from(N), R()) : o.slice();
  }, D.rangeRound = function(N) {
    return o = Array.from(N), s = ET, R();
  }, D.clamp = function(N) {
    return arguments.length ? (S = N ? !0 : ps, R()) : S !== ps;
  }, D.interpolate = function(N) {
    return arguments.length ? (s = N, R()) : s;
  }, D.unknown = function(N) {
    return arguments.length ? (y = N, D) : y;
  }, function(N, M) {
    return f = N, h = M, R();
  };
}
function gz() {
  return yz()(ps, ps);
}
function Sz(r, o, s, f) {
  var h = _6(r, o, s), y;
  switch (f = Ky(f ?? ",f"), f.type) {
    case "s": {
      var S = Math.max(Math.abs(r), Math.abs(o));
      return f.precision == null && !isNaN(y = uz(h, S)) && (f.precision = y), kT(f, S);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      f.precision == null && !isNaN(y = sz(h, Math.max(Math.abs(r), Math.abs(o)))) && (f.precision = y - (f.type === "e"));
      break;
    }
    case "f":
    case "%": {
      f.precision == null && !isNaN(y = oz(h)) && (f.precision = y - (f.type === "%") * 2);
      break;
    }
  }
  return wT(f);
}
function RT(r) {
  var o = r.domain;
  return r.ticks = function(s) {
    var f = o();
    return R6(f[0], f[f.length - 1], s ?? 10);
  }, r.tickFormat = function(s, f) {
    var h = o();
    return Sz(h[0], h[h.length - 1], s ?? 10, f);
  }, r.nice = function(s) {
    s == null && (s = 10);
    var f = o(), h = 0, y = f.length - 1, S = f[h], v = f[y], w, E, R = 10;
    for (v < S && (E = S, S = v, v = E, E = h, h = y, y = E); R-- > 0; ) {
      if (E = nx(S, v, s), E === w)
        return f[h] = S, f[y] = v, o(f);
      if (E > 0)
        S = Math.floor(S / E) * E, v = Math.ceil(v / E) * E;
      else if (E < 0)
        S = Math.ceil(S * E) / E, v = Math.floor(v * E) / E;
      else
        break;
      w = E;
    }
    return r;
  }, r;
}
function lx() {
  var r = gz();
  return r.copy = function() {
    return mz(r, lx());
  }, Tx.apply(r, arguments), RT(r);
}
function xz() {
  var r = 0, o = 1, s, f, h, y, S = ps, v = !1, w;
  function E(D) {
    return D == null || isNaN(D = +D) ? w : S(h === 0 ? 0.5 : (D = (y(D) - s) * h, v ? Math.max(0, Math.min(1, D)) : D));
  }
  E.domain = function(D) {
    return arguments.length ? ([r, o] = D, s = y(r = +r), f = y(o = +o), h = s === f ? 0 : 1 / (f - s), E) : [r, o];
  }, E.clamp = function(D) {
    return arguments.length ? (v = !!D, E) : v;
  }, E.interpolator = function(D) {
    return arguments.length ? (S = D, E) : S;
  };
  function R(D) {
    return function(N) {
      var M, F;
      return arguments.length ? ([M, F] = N, S = D(M, F), E) : [S(0), S(1)];
    };
  }
  return E.range = R(tg), E.rangeRound = R(ET), E.unknown = function(D) {
    return arguments.length ? (w = D, E) : w;
  }, function(D) {
    return y = D, s = D(r), f = D(o), h = s === f ? 0 : 1 / (f - s), E;
  };
}
function bz(r, o) {
  return o.domain(r.domain()).interpolator(r.interpolator()).clamp(r.clamp()).unknown(r.unknown());
}
function _T() {
  var r = RT(xz()(ps));
  return r.copy = function() {
    return bz(r, _T());
  }, cz.apply(r, arguments);
}
function Ih(r) {
  for (var o = r.length / 6 | 0, s = new Array(o), f = 0; f < o; )
    s[f] = "#" + r.slice(f * 6, ++f * 6);
  return s;
}
const Ez = Ih("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
function ng(r) {
  var o = r.length;
  return function(s) {
    return r[Math.max(0, Math.min(o - 1, Math.floor(s * o)))];
  };
}
const Cz = ng(Ih("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
ng(Ih("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
ng(Ih("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
ng(Ih("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
function Mh(r, o, s) {
  this.k = r, this.x = o, this.y = s;
}
Mh.prototype = {
  constructor: Mh,
  scale: function(r) {
    return r === 1 ? this : new Mh(this.k * r, this.x, this.y);
  },
  translate: function(r, o) {
    return r === 0 & o === 0 ? this : new Mh(this.k, this.x + this.k * r, this.y + this.k * o);
  },
  apply: function(r) {
    return [r[0] * this.k + this.x, r[1] * this.k + this.y];
  },
  applyX: function(r) {
    return r * this.k + this.x;
  },
  applyY: function(r) {
    return r * this.k + this.y;
  },
  invert: function(r) {
    return [(r[0] - this.x) / this.k, (r[1] - this.y) / this.k];
  },
  invertX: function(r) {
    return (r - this.x) / this.k;
  },
  invertY: function(r) {
    return (r - this.y) / this.k;
  },
  rescaleX: function(r) {
    return r.copy().domain(r.range().map(this.invertX, this).map(r.invert, r));
  },
  rescaleY: function(r) {
    return r.copy().domain(r.range().map(this.invertY, this).map(r.invert, r));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
Mh.prototype;
function wz() {
  return Math.random() * this.bandwidth() - this.bandwidth() / 2;
}
function _k(r) {
  const o = (r[1] - r[0]) * 0.05;
  return [r[0] - o, r[1] + o];
}
function DT(r, o, s = [], f = 580, h = 420, y = 30, S = 50) {
  const v = "0 0 " + f + " " + h, w = r[o.x], E = r[o.y];
  let R = [], D = !1, N;
  o.hasOwnProperty("colour") && typeof r[o.colour][0] == "number" ? (N = _T().domain(jy(r[o.colour])).interpolator(Cz), R = r[o.colour].map((ce) => N(ce)), D = !0) : o.hasOwnProperty("colour") && typeof r[o.colour][0] == "string" && (N = Rx().domain(jy(r[o.colour])).range(Ez), R = r[o.colour].map((ce) => N(ce)), D = !0);
  let M;
  typeof w[0] == "number" ? (M = lx().domain(_k(jy(w))).range([y, f - y]), M.jitter = () => 0) : (M = TT().range([y, f - y]).domain([...new Set(w)]).paddingInner(0.8).paddingOuter(0.5), M.jitter = wz);
  const F = lx().domain(_k(jy(E))).range([h - S, S / 3]);
  return {
    points: r[o.x].map((ce, X) => {
      s.forEach((te) => {
        r[te] || console.error(`Enrichment module: Variable, ${te}, not found in data`);
      });
      let se = {};
      return s.forEach((te) => se[te] = r[te][X]), se.x = M(ce) + M.jitter(), se.y = F(r[o.y][X]), se.id = r[o.id][X], D && (se.colour = R[X]), se;
    }),
    viewBox: v,
    hasColour: D,
    scale: {
      x: M,
      y: F,
      colour: N
    }
  };
}
const Dk = (r, o) => {
  const s = r.clientX - r.target.getBoundingClientRect().left, f = r.clientY - r.target.getBoundingClientRect().top, h = (S) => Math.sqrt(Math.pow(S.x - s, 2) + Math.pow(S.y - f, 2)), y = o.points.filter((S) => h(S) < 10).sort((S, v) => h(S) > h(v));
  return y !== void 0 && y.length > 0 ? y[0] : null;
}, OT = (r, o, s, f, h) => {
  r.fillStyle = f, r.beginPath(), r.arc(o, s, h, 0, 2 * Math.PI), r.closePath(), r.fill();
}, MT = (r, o, s, f) => {
  o.forEach((h) => OT(r, h.x, h.y, s, f));
}, kz = (r, o) => {
  r.strokeStyle = "#111", r.lineWidth = 1;
  const [s, f] = o.x.range(), [h, y] = o.y.range();
  r.moveTo(s, y), r.lineTo(s, h), r.lineTo(f, h), r.stroke(), r.textAlign = "center", r.textBaseline = "middle", (o.x.hasOwnProperty("ticks") ? o.x.ticks() : (
    // continuous variable
    o.x.domain()
  )).forEach((v) => {
    const w = Math.round(o.x(v));
    r.moveTo(w, h), r.lineTo(w, h + 8), r.stroke();
    const E = typeof v == "number" ? v.toFixed(1) : v;
    r.fillText(E, w, h + 15);
  }), o.y.ticks().forEach((v) => {
    const w = Math.round(o.y(v));
    r.moveTo(s, w), r.lineTo(s - 6, w), r.stroke(), r.fillText(v, s - 15, w);
  });
}, Tz = (r, o) => {
  const { stroke: s, points: f } = o;
  f.forEach(({ low: h, high: y, y: S }) => {
    r.lineWidth = 3, r.strokeStyle = s, r.moveTo(h, S), r.lineTo(y, S), r.stroke();
  });
}, Rz = (r, o) => {
  const { points: s, geom: f, ...h } = o;
  f === "point" && MT(r, s, h.fill, h.r), f === "range" && Tz(r, o);
};
function _x({ handler: r, layers: o, onClick: s, onHover: f }) {
  const h = ut.useRef(null);
  ut.useEffect(() => {
    const v = h.current, w = v.getContext("2d"), { width: E, height: R } = v.getBoundingClientRect();
    w.clearRect(0, 0, E, R), v.width = E, v.height = R, w.translate(0.5, 0.5), kz(w, r.scale), r.hasColour ? r.points.forEach((D) => OT(w, D.x, D.y, D.colour, 6)) : MT(w, r.points, "#aaa", 6), o.forEach((D) => {
      D && Rz(w, D);
    });
  }, [r, o]);
  const y = (v) => {
    const w = Dk(v, r);
    s(w == null ? void 0 : w.id);
  }, S = (v) => {
    const w = Dk(v, r);
    f(w == null ? void 0 : w.id);
  };
  return /* @__PURE__ */ V.jsx(
    "canvas",
    {
      ref: h,
      style: { width: "100%", height: "25rem" },
      onClick: y,
      onMouseMove: S
    }
  );
}
function _z({ resources: r, idVariable: o, geneList: s, setGeneList: f, children: h }) {
  const [y, S] = ut.useState(""), [v, w] = ut.useState(500), E = ut.useRef(null), { selectedPoint: R } = ut.useContext(bx), { hoverPoint: D } = ut.useContext(Ex);
  ut.useEffect(() => w(E.current.clientHeight));
  const N = Object.keys(r).filter((X) => X.toLowerCase().includes(y.toLowerCase())).filter((X) => R !== void 0 && !r[X].includes(R.id)), M = Object.keys(r).filter((X) => X.toLowerCase().includes(y.toLowerCase())).filter((X) => R === void 0 || r[X].includes(R.id)), F = (X) => {
    X.key === "Enter" && M.length > 0 ? f(M[0]) : X.key === "Enter" && N.length > 0 && f(N[0]);
  }, $ = ({ x: X }) => {
    const se = "list__item " + (X === s ? "list__item--active" : "");
    return /* @__PURE__ */ V.jsxs("p", { className: se, onClick: () => f(X), children: [
      X,
      R && r[X].includes(R.id) && /* @__PURE__ */ V.jsx("span", { className: "dot dot--marked" }),
      D && r[X].includes(D.id) && /* @__PURE__ */ V.jsx("span", { className: "dot dot--hover" })
    ] }, X);
  }, ce = h.length === 0 ? "30rem" : "8rem";
  return console.log({ children: h, bodyHeight: ce }), /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsxs("div", { ref: E, className: "card__header", children: [
      /* @__PURE__ */ V.jsx(
        "input",
        {
          placeholder: "Search...",
          onChange: (X) => S(X.target.value),
          onKeyDown: F
        }
      ),
      /* @__PURE__ */ V.jsxs("div", { className: "list", style: { height: ce, overflowY: "scroll" }, children: [
        M.map((X) => /* @__PURE__ */ V.jsx($, { x: X }, X)),
        N.map((X) => /* @__PURE__ */ V.jsx($, { x: X }, X))
      ] })
    ] }),
    h
  ] });
}
function NT(r) {
  const [o, s] = ut.useState(0);
  return ut.useLayoutEffect(() => {
    function f() {
      const { width: h } = r.current.getBoundingClientRect();
      s(h);
    }
    return window.addEventListener("resize", f), f(), () => window.removeEventListener("resize", f);
  }, []), o;
}
function Dz({
  data: r,
  geneList: o,
  elements: s,
  selectedPoint: f,
  setGeneList: h,
  drill: y
}) {
  const S = ut.useRef(null), [v, w] = ut.useState(null), E = { x: "category", y: "nlog10pvalue", id: "name" }, R = NT(S), D = ut.useMemo(
    () => (r["__selected-is-element"] = r[E.id].map(
      (se) => f !== void 0 && s[se].includes(f.id)
    ), DT(
      r,
      E,
      ["__selected-is-element"].concat(y),
      R
    )),
    [f, R]
  ), N = D.points.find((se) => se.id === v), M = D.points.find((se) => se.id === o), F = D.points.filter((se) => se["__selected-is-element"]), $ = /* @__PURE__ */ V.jsxs("ul", { className: "legend", children: [
    f && /* @__PURE__ */ V.jsxs("li", { children: [
      /* @__PURE__ */ V.jsx("span", { style: { background: "red" }, className: "legend__dot" }),
      "set contains selected point"
    ] }),
    o && /* @__PURE__ */ V.jsxs("li", { children: [
      /* @__PURE__ */ V.jsx("span", { style: { background: "blue" }, className: "legend__dot" }),
      "selected set"
    ] })
  ] }), ce = y && /* @__PURE__ */ V.jsx(V.Fragment, { children: y.map((se) => {
    const te = N ?? M ?? { [se]: "-" };
    return /* @__PURE__ */ V.jsxs("p", { className: "drill__info font-sm", children: [
      se,
      ": ",
      /* @__PURE__ */ V.jsx("b", { children: te[se] })
    ] }, se);
  }) }), X = [
    v && {
      key: "hover",
      points: [N],
      geom: "point",
      fill: "#57B1FF",
      r: 6
    },
    o && {
      key: "active",
      points: [M],
      geom: "point",
      fill: "blue",
      r: 7
    },
    f && {
      key: "selected-is-element",
      points: F,
      geom: "point",
      fill: "red",
      r: 3
    }
  ];
  return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsx("div", { className: "card__header", style: {
      paddingTop: "0",
      paddingBottom: "0"
    }, children: ce }),
    /* @__PURE__ */ V.jsx("div", { ref: S, children: /* @__PURE__ */ V.jsx(
      _x,
      {
        handler: D,
        layers: X,
        onClick: h,
        onHover: w
      }
    ) }),
    $
  ] });
}
function Oz(r) {
  const o = ut.useRef(), s = (f) => {
    o.current && !o.current.contains(f.target) && r();
  };
  return ut.useEffect(() => (document.addEventListener("click", s), () => window.removeEventListener("click", s))), o;
}
function LT({
  submit: r,
  candidates: o,
  dropdown: s,
  placeHolder: f,
  width: h = "100%",
  block: y
}) {
  const [S, v] = ut.useState(""), [w, E] = ut.useState(!1), R = Oz(() => {
    E(!1);
  }), D = (F) => {
    v(F.target.value), E(!0);
  }, N = (F) => {
    v(""), r(F), E(!1);
  }, M = o.filter((F) => F.toLowerCase().includes(S.toLowerCase())).slice(0, 5);
  return /* @__PURE__ */ V.jsxs("div", { style: { display: "inline-block", position: "relative" }, ref: R, children: [
    /* @__PURE__ */ V.jsx(
      "input",
      {
        style: { width: h },
        className: `${y}__input`,
        value: S,
        autoFocus: !0,
        onClick: () => E(!0),
        placeholder: f,
        onChange: D,
        onKeyDown: (F) => {
          F.key === "Enter" && M.length > 0 && (r(M[0]), v(""), document.activeElement.blur(), E(!1));
        }
      }
    ),
    (w || s === "always") && /* @__PURE__ */ V.jsx("div", { className: "suggestions", children: M.map((F) => /* @__PURE__ */ V.jsx(
      "button",
      {
        className: "search-suggestion",
        onClick: () => N(F),
        children: F
      },
      F
    )) })
  ] });
}
LT.defaultProps = {
  placeHolder: "Search..."
};
function VS({ content: r, handleClick: o, label: s, current: f, block: h }) {
  const [y, S] = ut.useState(!1), v = (R) => {
    o(R), S(!1);
  }, w = f !== null ? f + " selected" : s, E = y ? "Search" : w;
  return /* @__PURE__ */ V.jsxs("span", { className: `${h}__dropdown`, children: [
    /* @__PURE__ */ V.jsx("span", { children: /* @__PURE__ */ V.jsxs("b", { children: [
      " ",
      s,
      " "
    ] }) }),
    /* @__PURE__ */ V.jsx(
      LT,
      {
        style: { display: "inline-block", cursor: "pointer" },
        submit: v,
        candidates: r,
        placeHolder: E,
        block: ""
      }
    )
  ] });
}
const Mz = ut.memo(c6);
function Nz({ data: r, config: o, modules: s, useCanvas: f = !0 }) {
  const [h, y] = ut.useState(null), [S, v] = ut.useState(null), [w, E] = ut.useState(null), [R, D] = ut.useState(o), N = ut.useRef(null), M = NT(N), F = f ? _x : v6, $ = ut.useCallback((ne) => {
    y(ne);
  }, []), ce = ut.useCallback((ne) => {
    v(ne);
  }, []), X = [].concat(
    s.drill ?? [],
    s.url ?? [],
    s.details ?? [],
    s["drill-plots"] ?? [],
    s["confidence-interval"] ? [s["confidence-interval"].high, s["confidence-interval"].low] : []
  ), se = ut.useMemo(
    () => DT(r, R, X, M ?? 500),
    [r, R, M]
  ), te = se.points.find((ne) => ne.id === h), Se = se.points.find((ne) => ne.id === S), Ce = s.title ?? "volcano.view";
  ut.useEffect(() => {
    document.title = Ce;
  }, []);
  const Y = {
    table: /* @__PURE__ */ V.jsx(
      Mz,
      {
        data: r,
        header: !0,
        className: "font-sm",
        selected: h,
        clickRow: $,
        hoverRow: ce,
        idVariable: R.id
      }
    )
  }, Oe = [
    Se && { key: "hover", points: [Se], geom: "point", fill: "orange", r: 7 },
    te && { key: "selected", points: [te], geom: "point", fill: "red", r: 7 }
  ], ze = [], it = [], lt = [];
  if (s["gene-list"]) {
    const ne = s["gene-list"], we = ne.genelist[w] ?? [], de = se.points.filter((Qe) => we.includes(Qe.id)), ge = [];
    ne.hasOwnProperty("enrichment") && ge.push(
      /* @__PURE__ */ V.jsx(
        Dz,
        {
          data: ne.enrichment,
          elements: ne.genelist,
          geneList: w,
          setGeneList: E,
          selectedPoint: te,
          drill: ne.drill
        }
      )
    ), Y.sets = /* @__PURE__ */ V.jsx(
      _z,
      {
        resources: ne.genelist,
        geneList: w,
        setGeneList: E,
        idVariable: R.id,
        children: ge
      }
    ), Oe.unshift({ key: "gene-list", points: de, geom: "point", fill: "blue", r: 7 });
  }
  if (s.drill && ze.push(
    /* @__PURE__ */ V.jsx(V.Fragment, { children: s.drill.map((ne) => {
      const we = Se ?? te ?? { [ne]: "-" };
      return /* @__PURE__ */ V.jsxs("p", { className: "drill__info font-sm", children: [
        ne,
        ": ",
        /* @__PURE__ */ V.jsx("b", { children: we[ne] })
      ] }, ne);
    }) })
  ), s.url) {
    const ne = Se ?? te;
    ze.push(
      /* @__PURE__ */ V.jsx(V.Fragment, { children: ne === void 0 ? /* @__PURE__ */ V.jsx("p", { children: "" }) : s.url.map((we) => /* @__PURE__ */ V.jsx("a", { href: ne[we], className: "drill__button", target: "_blank", children: we }, we)) })
    );
  }
  if (s["confidence-interval"] && te) {
    const ne = s["confidence-interval"], we = te, de = we && Math.max(
      se.scale.x.range()[0],
      se.scale.x(we[ne.low])
    ), ge = we && Math.min(
      se.scale.x.range()[1],
      se.scale.x(we[ne.high])
    );
    Oe.push({
      key: "confidence-interval",
      points: [{ low: de, high: ge, y: we.y }],
      geom: "range",
      stroke: "red"
    });
  }
  if (s.details) {
    const ne = te;
    it.push(
      /* @__PURE__ */ V.jsx(V.Fragment, { children: ne && s.details.map((we) => /* @__PURE__ */ V.jsxs("section", { className: "card__section", children: [
        /* @__PURE__ */ V.jsx("h3", { children: we }),
        /* @__PURE__ */ V.jsx("p", { children: ne[we] })
      ] }, we)) })
    );
  }
  if (s.explore) {
    const ne = (de) => D({ ...R, ...de }), we = Object.keys(r);
    it.push(
      /* @__PURE__ */ V.jsxs("section", { className: "card__section", children: [
        /* @__PURE__ */ V.jsxs("div", { children: [
          "x: ",
          /* @__PURE__ */ V.jsx(
            VS,
            {
              content: we,
              handleClick: (de) => ne({ x: de }),
              current: R.x,
              block: ""
            }
          )
        ] }),
        /* @__PURE__ */ V.jsxs("div", { children: [
          "y: ",
          /* @__PURE__ */ V.jsx(
            VS,
            {
              content: we,
              handleClick: (de) => ne({ y: de }),
              current: R.y,
              block: ""
            }
          )
        ] }),
        /* @__PURE__ */ V.jsxs("div", { children: [
          "colour: ",
          /* @__PURE__ */ V.jsx(
            VS,
            {
              content: we,
              handleClick: (de) => ne({ colour: de }),
              current: R.colour,
              block: ""
            }
          )
        ] })
      ] })
    );
  }
  if (s["drill-plots"] && (te ? Y.plots = /* @__PURE__ */ V.jsx(V.Fragment, { children: s["drill-plots"].map(
    (ne) => /* @__PURE__ */ V.jsxs("section", { className: "card__content", children: [
      /* @__PURE__ */ V.jsx("h3", { children: ne }),
      /* @__PURE__ */ V.jsx("img", { src: te[ne], width: "100%" })
    ] }, ne)
  ) }) : Y.plots = /* @__PURE__ */ V.jsx("section", { className: "card__content", children: /* @__PURE__ */ V.jsx("p", { children: " select point to see plots " }) })), s.hasOwnProperty("nav")) {
    const ne = s.nav.map(
      (we) => /* @__PURE__ */ V.jsx("a", { className: "navbar__link", href: we.url, children: we.label })
    );
    lt.push(
      /* @__PURE__ */ V.jsx("nav", { className: "navbar", children: ne })
    );
  }
  s.about && (Y.about = /* @__PURE__ */ V.jsx("div", { className: "card__content", children: /* @__PURE__ */ V.jsx("table", { className: "about-table", children: s.about.map(
    (ne) => /* @__PURE__ */ V.jsxs("tr", { className: "about-table__row", children: [
      /* @__PURE__ */ V.jsx("td", { className: "about-table__cell", children: /* @__PURE__ */ V.jsx("b", { children: ne.field }) }),
      /* @__PURE__ */ V.jsx("td", { className: "about-table__cell", children: /* @__PURE__ */ V.jsx(o6, { children: ne.text }) })
    ] })
  ) }) }));
  const he = /* @__PURE__ */ V.jsxs("ul", { className: "legend", children: [
    h && /* @__PURE__ */ V.jsxs("li", { children: [
      /* @__PURE__ */ V.jsx("span", { style: { background: "red" }, className: "legend__dot" }),
      "selected point"
    ] }),
    S && /* @__PURE__ */ V.jsxs("li", { children: [
      /* @__PURE__ */ V.jsx("span", { style: { background: "orange" }, className: "legend__dot" }),
      "hovered point"
    ] }),
    w && /* @__PURE__ */ V.jsxs("li", { children: [
      /* @__PURE__ */ V.jsx("span", { style: { background: "blue" }, className: "legend__dot" }),
      "point in selected set"
    ] })
  ] });
  return /* @__PURE__ */ V.jsx(bx.Provider, { value: { selected: h, setSelected: $, selectedPoint: te }, children: /* @__PURE__ */ V.jsx(Ex.Provider, { value: { hover: S, setHover: ce, hoverPoint: Se }, children: /* @__PURE__ */ V.jsxs("main", { className: "container", children: [
    lt,
    /* @__PURE__ */ V.jsxs("div", { className: "main main-2-1", children: [
      /* @__PURE__ */ V.jsxs("div", { className: "card", style: { gridTemplateRows: "auto 1fr" }, children: [
        /* @__PURE__ */ V.jsxs("div", { ref: N, className: "card__header seperator", children: [
          /* @__PURE__ */ V.jsxs("h1", { children: [
            " ",
            Ce
          ] }),
          /* @__PURE__ */ V.jsx("div", { className: "drill", children: ze })
        ] }),
        /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
          /* @__PURE__ */ V.jsx("p", { className: "axis-label", children: R.y }),
          /* @__PURE__ */ V.jsx(F, { handler: se, layers: Oe, onClick: $, onHover: ce }),
          /* @__PURE__ */ V.jsx("p", { className: "axis-label", style: { float: "right" }, children: R.x }),
          [
            he,
            ...it
          ]
        ] })
      ] }),
      /* @__PURE__ */ V.jsx("aside", { className: "card", style: { gridTemplateRows: "auto auto 1fr" }, children: /* @__PURE__ */ V.jsx(f6, { tabs: Y }) })
    ] })
  ] }) }) });
}
function _h(r) {
  return /* @__PURE__ */ V.jsx("tr", { children: Object.keys(r).map((o) => /* @__PURE__ */ V.jsxs("td", { children: [
    " ",
    r[o],
    " "
  ] }, o)) });
}
function Lz() {
  const [r, o] = ut.useState(null), [s, f] = ut.useState(null), [h, y] = ut.useState(null), [S, v] = ut.useState(!1), [w, E] = ut.useState(0), [R, D] = ut.useState(0);
  ut.useEffect(() => {
    const Oe = setInterval($, 5e3);
    return () => clearInterval(Oe);
  }, []);
  const N = () => {
    o(null);
  }, M = (Oe) => {
    D(Number(Oe.target.value));
  }, F = () => {
    o(/* @__PURE__ */ new Date()), f(/* @__PURE__ */ new Date()), y(0), E(R);
  }, $ = () => {
    f(/* @__PURE__ */ new Date());
  }, ce = () => {
    E(w + 1);
  }, X = () => {
    if (f(/* @__PURE__ */ new Date()), S === !1) {
      const Oe = (s - r) / 1e3 / 60;
      y(h + Oe);
    } else
      o(/* @__PURE__ */ new Date());
    v(!S);
  }, se = S ? 0 : (s - r) / 1e3 / 60, te = r === null ? 0 : se + h, Se = `${te.toFixed(2)}m`, Ce = w - R, Y = Ce > 0 ? `${(te / Ce).toFixed(1)}min/k` : "-";
  return /* @__PURE__ */ V.jsx("div", { className: "container main-1-1", children: /* @__PURE__ */ V.jsxs("div", { className: "card", style: { width: "40rem" }, children: [
    r && /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
      /* @__PURE__ */ V.jsx("button", { onClick: ce, children: "+" }),
      /* @__PURE__ */ V.jsx("table", { children: /* @__PURE__ */ V.jsxs("tbody", { children: [
        /* @__PURE__ */ V.jsx(_h, { label: "starting value", value: R }),
        /* @__PURE__ */ V.jsx(_h, { label: "current value", value: w }),
        /* @__PURE__ */ V.jsx(_h, { label: "increase", value: Ce }),
        /* @__PURE__ */ V.jsx(_h, { label: "time passed", value: Se }),
        /* @__PURE__ */ V.jsx(_h, { label: "pace", value: Y })
      ] }) }),
      /* @__PURE__ */ V.jsx("button", { onClick: X, children: S ? "continue" : "pause" }),
      /* @__PURE__ */ V.jsx("button", { onClick: N, children: "reset" })
    ] }),
    r === null && /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
      /* @__PURE__ */ V.jsx("input", { onChange: M, value: R }),
      /* @__PURE__ */ V.jsx("button", { onClick: F, children: "start" })
    ] })
  ] }) });
}
function zz(r) {
  const [o, s] = ut.useState(null);
  return ut.useEffect(() => {
    fetch(r, { mode: "cors" }).then((f) => f.json(), (f) => {
      console.log("API ERROR"), console.log(f);
    }).then((f) => {
      s(f);
    });
  }, []), o;
}
function Az({ getDatasetURL: r, datasetsURL: o, ...s }) {
  const [f, h] = ut.useState(null), [y, S] = ut.useState(null), v = zz(o);
  ut.useEffect(() => {
    v && v.length > 0 && h(v[0]);
  }, [v]), ut.useEffect(() => {
    if (f !== null) {
      const E = "http://localhost:8999/api/configs?name=" + f;
      fetch(E, { mode: "cors" }).then((R) => R.json(), (R) => {
        console.log("API ERROR"), console.log(R);
      }).then((R) => {
        console.log("LOADED"), S(R);
      });
    }
  }, [f]);
  const w = (E) => h(E);
  return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsx("nav", { children: v && v.map(
      (E) => /* @__PURE__ */ V.jsx("button", { onClick: () => w(E), children: /* @__PURE__ */ V.jsx("span", { style: { textDecoration: E === f ? "underline" : "none" }, children: E }) }, E)
    ) }),
    /* @__PURE__ */ V.jsx(zT, { ...y })
  ] });
}
function jz({ data: r }) {
  return /* @__PURE__ */ V.jsx("main", { className: "container main-1-1", children: /* @__PURE__ */ V.jsx("div", { className: "card", children: /* @__PURE__ */ V.jsx(Table, { data: r, header: !0 }) }) });
}
const Uz = {
  table: jz,
  volcano: Nz,
  prod: Lz,
  multi: Az,
  canvas: _x
};
function zT({ view: r, payload: o }) {
  const s = Uz[r] || Fz;
  return /* @__PURE__ */ V.jsx(V.Fragment, { children: /* @__PURE__ */ V.jsx(s, { ...o }) });
}
function Fz() {
  return /* @__PURE__ */ V.jsx("p", { className: "loading-text", children: "Waiting for valid view" });
}
function Pz(r) {
  const [o, s] = ut.useState({
    loaded: !1,
    payload: null
  });
  return ut.useEffect(() => {
    r().then((f) => {
      s({
        loaded: !0,
        view: f.view,
        payload: f.payload
      });
    });
  }, []), o;
}
function Hz({ getConfig: r }) {
  const { loaded: o, view: s, payload: f } = Pz(r);
  return /* @__PURE__ */ V.jsx(V.Fragment, { children: o ? /* @__PURE__ */ V.jsx(zT, { view: s, payload: f }) : /* @__PURE__ */ V.jsx(Iz, {}) });
}
function Iz() {
  return /* @__PURE__ */ V.jsx("p", { className: "loading-text", children: "Loading..." });
}
function Yz(r) {
  return () => fetch(r, { mode: "cors" }).then((o) => o.json(), (o) => {
    console.log("API ERROR"), console.log(o);
  });
}
function Wz(r, o) {
  Oh.createRoot(document.getElementById(r)).render(
    /* @__PURE__ */ V.jsx(kN.StrictMode, { children: /* @__PURE__ */ V.jsx(Hz, { getConfig: o }) })
  );
}
export {
  Yz as getConfigFromAPI,
  Wz as render
};
